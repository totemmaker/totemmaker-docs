{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Product list","text":"Check our support page for more help: Support"},{"location":"#control-boards","title":"Control boards","text":"Totem Mobile App RoboBoard X3 RoboBoard X4 Mini Control Board Totem Modules"},{"location":"#development-kits","title":"Development kits","text":"Mini Lab Micro Lab LabBoard TotemDuino More"},{"location":"#robotics-kits","title":"Robotics kits","text":"Mini Trooper RoboCar Chassis Robotics Kit 4WD Car More"},{"location":"#support","title":"Support","text":"<p>If you have questions or suggestions - do not hesitate to reach out to us! For more information check Support section.</p> <p>Technical, programming, engineering discussions and help:</p> <ul> <li> Totemmaker Discord http://discord.totemmaker.net (https://discord.gg/Rc5bEnKrmG)</li> <li> Totemmaker forum https://forum.totemmaker.net</li> </ul> <p>Product purchase, shipping, warranty and general questions:</p> <ul> <li> Totemmaker email info@totemmaker.net</li> </ul>"},{"location":"support/","title":"Support","text":"<p>If you have questions or suggestions - do not hesitate to reach out to us!</p> <p>Technical, programming, engineering discussions and help:</p> <ul> <li> Totemmaker Discord http://discord.totemmaker.net (https://discord.gg/Rc5bEnKrmG)</li> <li> Totemmaker forum https://forum.totemmaker.net</li> </ul> <p>Product purchase, shipping, warranty and general questions:</p> <ul> <li> Totemmaker email info@totemmaker.net</li> </ul>"},{"location":"support/#news","title":"News","text":"<p>Find latest news and releases in our community forum.</p> <p>https://forum.totemmaker.net \u2192 News</p>"},{"location":"support/#social","title":"Social","text":"<p>Check our social media pages.</p> <ul> <li> Github https://github.com/totemmaker</li> <li> Facebook https://www.facebook.com/totemmaker</li> <li> Instagram https://www.instagram.com/totem_maker</li> <li> YouTube https://www.youtube.com/totemmaker</li> <li> https://x.com/totemmaker</li> </ul>"},{"location":"support/#distributors","title":"Distributors","text":"<p>List of official Totemmaker product distributors.</p> <p>https://totemmaker.net/distributors/</p>"},{"location":"support/#contacts","title":"Contacts","text":"<p>We are located in  Lithuania, Vilnius. For more information visit contacts page.</p> <p>https://totemmaker.net/contacts/</p>"},{"location":"labboard/","title":"Overview","text":"<p>Check firmware version</p> <p>Documentation is written for the latest firmware version. Read Firmware update section to perform this procedure.</p> <p></p> <p> TE-PR-1 This board has a dual use - firstly it can be used as an expansion board to the TotemDuino system, offering easily accessible input and output connections, and secondly - it is a measuring and testing unit, containing multiple features.</p> <p>LabBoard is designed to be mounted onto Totem beams and boards, as well as to the third part surfaces, with a help of a few bolts and brackets.</p>"},{"location":"labboard/#features","title":"Features","text":"<ul> <li>Digital to Analog converter - converter outputting a pre-set voltage:<ul> <li>3 channels in the 0..3.25 Volt range (DAC1, DAC2, DAC3)</li> <li>1 channel in the 3..14 Volt range (VREG)</li> </ul> </li> <li>Voltage measure - three inputs in the \u00b10.5V, \u00b15V and \u00b150V range.</li> <li>Current measure - sensing current up to 800 mA.</li> <li>Frequency meter - digital signal frequency measurement module for signals up to 23 MHz.</li> <li>Pulse counter - digital signal pulse counter, counting up to 999999999 pulses.</li> <li>Pulse generator - unit capable of generating finite or infinite series of pulses, with programmable pulse width and period.</li> <li>Serial monitor - View serial data output from Arduino and control LabBoard itself.</li> <li>I2C scanner - detect HEX address of connected I2C device.</li> <li>DHT11 monitor - display connected DHT11 sensor measurements.</li> <li>AD9833 control - control connected AD9833 chip parameters.</li> </ul>"},{"location":"labboard/#layout","title":"Layout","text":"<p>LabBoard works on its own as a separate device, providing additional functionality and convenience of prototyping. Unmarked headers mirrors TotemDuino pins over connected flat cable and are not used in LabBoard functionality (directly).  </p> <p>Description of board items: </p> <ul> <li>Control keys - SET+ SET- used to increment, decrement values and jump between selections. Left SELECT Middle SELECT Right SELECT used to select certain options, depending on mode LabBoard is running.</li> <li>Display - 7-segment display with 9 digits and individual dots. Displays all information related to currently running mode.</li> <li>LED - contains total of 11 LED. Groups of 3 (near buttons) are used to indicate currently selected parameter in Main screen mode. DIG1 and DIG2 mostly used to show digital state of DIG1 and DIG2 pins.</li> <li>Input / Output - Header for voltage measure and regulated output. There are 3 channels for voltage measurement, 3 channels (DAC) for variable voltage output and 2 digital pins for various functionality.</li> <li>SWD header - initially designed to flash firmware, but repurposed to reuse SCL and SDA pins for additional LabBoard functionality (I2C scanner and AD9833 control).</li> <li>Power out - provides power for breadboard and other circuits. Outputs regulated voltage of: 3.3V, 5V, -5V, VIN - DC input and VREG - variable between 3V and 14V.</li> <li>TXD pin - used to generate configurable output signal in Pulse generator mode. Also used in DHT11 monitor mode.</li> </ul>"},{"location":"labboard/firmware-update/","title":"Firmware update","text":"<p>LabBoard firmware can be updated to the latest version in order to receive new features and improvements. Available update methods:</p> <ul> <li>Update over Arduino (recommended)</li> <li>Update over UART</li> <li>Update over SWD</li> </ul> <p>Note: Factory reset will be applied during update.</p> <p>Select board revision</p> <p>This tutorial differs between board revisions. Please select the one you have:</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <p> v.2.1 v.2.2 v.2.3 </p> <p> v.2.1 v.2.2 v.2.3 </p>"},{"location":"labboard/firmware-update/#check-version","title":"Check version","text":"<p>To get currently installed firmware version:</p> <ol> <li>Press any two keys at the same moment. If menu (<code>1. COUNT</code>) not displayed - version <code>1.02</code> is installed.</li> <li>Select <code>0. SEtUP</code> \u2192 <code>6. UERSI</code>.</li> <li>Current installed version will be displayed on screen (<code>UERSI 2.00</code>).</li> </ol> <p>Menu system is only available from version 2.00. </p>"},{"location":"labboard/firmware-update/#update-over-arduino","title":"Update over Arduino","text":"<p>Simple update procedure using TotemDuino, connected with LabBoard over flat cable. For smooth process - make sure to follow steps in order.  </p>"},{"location":"labboard/firmware-update/#prepare-totemduino","title":"Prepare TotemDuino","text":"<p> Download labboard_update.ino </p> <p>Upload labboard_update.ino to TotemDuino.</p> How to do it? <ol> <li>Click button to download latest firmware update file.  </li> <li>Open labboard_update.ino file. A message may appear requesting to create folder - click ok.</li> <li>Connect TotemDuino to computer over USB.</li> <li>Select <code>Tools</code> \u2192 <code>Port</code>.</li> <li>Upload code to TotemDuino.</li> </ol>"},{"location":"labboard/firmware-update/#prepare-labboard","title":"Prepare LabBoard","text":"<p>Important: Unplug USB cable from TotemDuino.</p> Start LabBoard in boot mode: Hold SET- key and power on MiniLab (plug DC jack into TotemDuino). LabBoard won't turn on, meaning it's in boot mode.   LabBoard v.2.1, v.2.2LabBoard v.2.3 <p>Connect wires to pins D0 to LabBoard TXD and D1 to LabBoard DIG2. </p> <ol> <li>Click TotemDuino reset button to start update. TX (red) LED will start to blink.</li> <li>Wait for (green) LED to turn on and LabBoard to display <code>CALIb run</code>.</li> <li>Firmware update is completed. Proceed to calibration section.  </li> </ol>"},{"location":"labboard/firmware-update/#troubleshot","title":"Troubleshot","text":"<p>In case (green) LED is flashing at 0.5s rate - update procedure failed:</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <ul> <li>Restart update procedure by pressing reset button again.</li> <li>Make sure correct LabBoard revision is selected.</li> <li>Make sure LabBoard is in boot mode. LED \u00b10.5V may be lit on, and will not respond to any key press.</li> <li>Make sure USB cable is unplugged when pressing Reset button.</li> <li>Disconnect everything and repeat steps in order.</li> <li>Connect LabBoard TXD pin to TotemDuino D0 pin directly (bypass flat cable).</li> <li>Follow tutorial recover LabBoard with deleted firmware. !! Only if it does not power on anymore !!.  </li> </ul> <ul> <li>Restart update procedure by pressing reset button again.</li> <li>Make sure correct LabBoard revision is selected.</li> <li>Make sure LabBoard is in boot mode. LED \u00b10.5V may be lit on, and will not respond to any key press.</li> <li>Make sure USB cable is unplugged when pressing Reset button.</li> <li>Disconnect everything and repeat steps in order.</li> <li>Connect LabBoard D0 pin to TotemDuino D0 pin directly (bypass flat cable).</li> </ul>"},{"location":"labboard/firmware-update/#update-over-uart","title":"Update over UART","text":"<p>STM32 has integrated bootloader capable of loading firmware using UART (Serial) peripheral. This requires application on PC side and USB to Serial converter to transfer data to MCU. One application that is capable to do so - STM32CubeProgrammer. Other applications can be used also.</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <p>Wiring instructions:</p> Connect over TotemDuino <ol> <li>Connect pins:<ul> <li>RST to GND (disable TotemDuino)</li> <li>D0 to LabBoard TXD</li> <li>D1 to LabBoard DIG2</li> </ul> </li> <li>Hold SET- button and plug in USB to TotemDuino (power on). LED \u00b10.5V should light up dimly.</li> </ol> <p></p> Connect over USB Serial <ol> <li>Unplug flat cable from LabBoard (or put TotemDuino in Reset: RST to GND).</li> <li>Connect pins:<ul> <li>GND to LabBoard GND</li> <li>TX to LabBoard DIG2</li> <li>RX to LabBoard TXD</li> </ul> </li> <li>Connect 3.3V to LabBoard 3.3V if there is no external power to LabBoard.</li> <li>Hold SET- button and plug in Serial converter (power on). LED \u00b10.5V should light up dimly.</li> </ol> <p></p> <p>Wiring instructions:</p> Connect over USB Serial <ol> <li>Unplug flat cable from LabBoard (or put TotemDuino in Reset: RST to GND).</li> <li>Connect pins:<ul> <li>GND to LabBoard GND</li> <li>TX to LabBoard D0</li> <li>RX to LabBoard D1</li> </ul> </li> <li>Connect 3.3V to LabBoard 3.3V if there is no external power to LabBoard.</li> <li>Hold SET- button and plug in Serial converter (power on). LED \u00b10.5V should light up dimly.</li> </ol> <p></p> <p>In STM32 Cube Programmer application select UART with specified settings. Baudrate value can be different. Click Connect to establish connection.</p> <p></p> <p>Download firmware in .hex or .bin format and flash (download) it to LabBoard. Binary (.bin) file address - <code>0x08000000</code>.</p> <p> Download LabBoard.hex Download LabBoard.bin </p>"},{"location":"labboard/firmware-update/#update-over-swd","title":"Update over SWD","text":"<p>SWD is a programming and debugging interface for ARM chips. A special hardware (ST-Link) and PC software is required to perform update using this method. One application that is capable to do so - STM32CubeProgrammer. Other applications can be used also. Some ST-Link programmers has Mass storage feature where connected board opens as storage device, allowing to simply drag and drop firmware file and automatically flash it to LabBoard.</p> <p></p> <p>Wiring instructions:</p> Connect over ST-Link <ol> <li>Connect ST-Link to LabBoard:<ul> <li>ST-Link SWCLK to LabBoard SWCLK</li> <li>ST-Link GND to LabBoard GND</li> <li>ST-Link SWDIO to LabBoard SWDIO</li> <li>ST-Link NRST to LabBoard RST</li> </ul> </li> <li>Connect 3V3 to LabBoard 3.3V if there is no external power to LabBoard.</li> </ol> <p></p> <p>In STM32 Cube Programmer application select ST-LINK with specified settings and click Connect. Connection should be established if wiring is correct and LabBoard has power.</p> <p></p> <p>Download firmware in .hex or .bin format and flash (download) it to LabBoard. Binary (.bin) file address - <code>0x08000000</code>.</p> <p> Download LabBoard.hex  Download LabBoard.bin </p>"},{"location":"labboard/firmware-update/#downgrading","title":"Downgrading","text":"<p>If you need to install older firmware version (in case of bug in latest one or etc.), browse Releases section (Assets) to download required version labboard_update.ino, LabBoard.hex or LabBoard.bin and follow install guide with selected file.</p>"},{"location":"labboard/main-screen/","title":"Main screen","text":""},{"location":"labboard/main-screen/#about","title":"About","text":"<p>Main \"home\" screen of LabBoard contains most of its functionality. Display and buttons are divided into 3 separate features working in parallel.</p>"},{"location":"labboard/main-screen/#details","title":"Details","text":"<ul> <li>Voltage measure of selected input: \u00b10.5V, \u00b15V, \u00b150V</li> <li>3 channels of variable voltage DAC outputs 0..3.25V</li> <li>1 channel of variable voltage VREG output 3..14V</li> <li>DC input voltage (VIN) display</li> <li>Current measure up to 800 mAmps</li> <li>2 LED to display DIG1 and DIG2 pin state (HIGH, LOW)</li> </ul>"},{"location":"labboard/main-screen/#left-display","title":"Left display","text":""},{"location":"labboard/main-screen/#voltage-measurement","title":"Voltage measurement","text":"<p>LabBoard has a 3 channel voltage measurement module. Each has a pre-set measurement range:</p> <ul> <li>\u00b1 0.5 V - for measuring small scale signals when maximum precision is required.</li> <li>\u00b1 5 V - for measuring TTL logic level signals.</li> <li>\u00b1 50 V - for external signal measuring.</li> </ul> <p>Left display is used in the LabBoard for showing currently measured voltage. Active channel can be selected with a Left SELECT button under the display. Corresponding channel LED will light up.</p> <p>Display shows value in millivolts when using \u00b1 0.5 V channel, otherwise the output is in Volts. <code>---</code> is displayed if measured voltage is out of range. Blinking display indicates that currently measured voltage is negative. If measurements are incorrect - perform Calibration or fine tune with ADC manual offset.</p> <p>Example:</p> <p></p> <ol> <li>Connect the \u00b1 5V input with a +3.3 V output.</li> <li>Press Left SELECT button until the \u00b15V input LED lights up.</li> <li>Observe the display - it should indicate a value close to 3.3 Volts:</li> </ol>"},{"location":"labboard/main-screen/#middle-display","title":"Middle display","text":""},{"location":"labboard/main-screen/#dac-output","title":"DAC output","text":"<p>Inbuilt 3 channel Digital to Analog Converter (DAC) allows you to output any voltage in the 0..3.25 Volt range, at up to 15 mA current. This is useful for experimenting with comparators or operational amplifiers, as they need various reference or input voltages.</p> <p>Middle display shows current output voltage for the active channel, which itself is indicated by the middle column of LED\u2019s. To change DAC output voltage:</p> <ol> <li>Press Middle SELECT to select active channel.</li> <li>Hold Middle SELECT until LED starts to blink.</li> <li>Use SET+ and SET- buttons to adjust currently selected channel voltage. Hold button down for fast increment. It will stop at 0 and 3.25.</li> <li>Press Middle SELECT to exit edit mode.</li> </ol> <p>All other inactive channels will still keep the same preset voltage until it\u2019s changed by SET buttons on the side of the board.</p> <p>Example:</p> <p></p> <ol> <li>Connect the DAC1 output to the \u00b1 5 V voltage measuring channel input.</li> <li>Using Left SELECT button switch the measure channel to \u00b1 5 volts.</li> <li>Using Middle SELECT button switch the current output channel to DAC1 Out.</li> <li>Hold Middle SELECT button until DAC1 Out LED starts to blink.</li> <li>Using SET+ and SET- buttons change the output value of the DAC1 channel.</li> <li>Observe that voltage measure display follows the same value as the DAC output one.</li> </ol>"},{"location":"labboard/main-screen/#right-display","title":"Right display","text":""},{"location":"labboard/main-screen/#vin-measurement","title":"VIN measurement","text":"<p>When VIN mode is selected - it displays current voltage of VIN pin. It depends on DC power adapter. Typically it is 15 Volts. Older kits had 12 V power adapter. <code>---</code> is displayed if DC jack is not connected and VIN is not available. This mode is only for observation and does not contain any more features.</p>"},{"location":"labboard/main-screen/#vreg-output","title":"VREG output","text":"<p>LabBoard has a built-in variable voltage output module, capable of providing up to VIN - 1V at up to 500 mA. VIN is the supply voltage for the Mini Lab. Typically output voltage can be adjusted between 3 and 14 Volts.</p> <p>The selected voltage is shown on the right display when VREG mode is activated. To change output voltage:</p> <ol> <li>Press Right SELECT to select VREG mode.</li> <li>Hold Right SELECT until LED starts to blink.</li> <li>Use SET+ and SET- buttons to adjust output voltage. Hold button down for fast increment.</li> <li>Press Right SELECT to exit edit mode.</li> </ol> <p><code>not</code> is displayed if feature is not available, because DC jack is not connected or below minimum voltage.</p> <p>Example:</p> <p></p> <ol> <li>Connect VREG together with \u00b1 50V input.</li> <li>Set the VREG voltage to some value.</li> <li>Observe that the \u00b1 50V input measurement follows the VREG setting.</li> </ol>"},{"location":"labboard/main-screen/#current-measurement","title":"Current measurement","text":"<p>LabBoard has a current measurement module for up to 800 mAmps. Rightmost display is used for showing current measurement result, when the mAmp mode is selected. As the current sensor reuses the same hardware as used in voltage measurement module - you need to connect the signal from the shunt resistor with \u00b1 0.5V channel.</p> <p>Example:</p> <p></p> <ol> <li>Connect SHUNT and \u00b1 0.5V input together.</li> <li>Connect any external circuit (in this example a 100 Ohm resistor is used), powering it from the LabBoard +5V output, but instead of connecting negative end to ground, connect it to SHUNT GND pin.</li> <li>Using Right SELECT button switch into mAmp mode.</li> <li>Observe that it measures close to 5 mA.</li> </ol>"},{"location":"labboard/main-screen/#digital-input","title":"Digital input","text":"<p>LabBoard has a two channel digital input module, meant to indicate the current logic state of the DIG1 and DIG2 pins with an LED. Default (unconnected) logic level is LOW.</p> <p>0 to 6 Volts are accepted input range. A low input value (0..1.3V) turns off corresponding LED, where a high value (1.8..6V) turns the LED on.  </p> <p>Example:</p> <p></p> <ol> <li>Connect DIG1 input with +5V output</li> <li>Observe that DIG1 LED follows the state of the input by lighting up.</li> </ol>"},{"location":"labboard/revisions/","title":"Revision changelog","text":"<p>Version of hardware changes. Visible above Totem logo.  </p> <p></p>"},{"location":"labboard/revisions/#v23","title":"v.2.3","text":"<p>Manufactured from 2022-Q2.</p> <ul> <li>Changed some components to different alternatives</li> <li>Changed wiring of some components</li> <li>Wired TX and RX to processor for simple firmware update and serial control feature</li> <li>Wired SET- key to start boot mode in a hardware based manner</li> </ul>"},{"location":"labboard/revisions/#v22","title":"v.2.2","text":"<ul> <li>PCB components tidy up</li> <li>More consistent silk screen labels</li> <li>Small PCB fixes</li> </ul>"},{"location":"labboard/revisions/#v21","title":"v.2.1","text":"<ul> <li>First public release</li> </ul>"},{"location":"labboard/schematics/","title":"Schematics","text":""},{"location":"labboard/schematics/#electrical-wiring","title":"Electrical wiring","text":"<p>LabBoard-v2.2.pdf</p>"},{"location":"labboard/serial-protocol/","title":"Serial protocol","text":"<p>Serial protocol to control LabBoard from Arduino or external device, like PC. Command must start with <code>LB</code> prefix, separated by <code>:</code>, ending with new line symbol <code>\\n</code>. Example: <code>Serial.print(\"LB:OUT:DAC1:1500\\n\")</code> or <code>Serial.println(\"LB:OUT:DAC1:1500\")</code> </p> <p>Protocol: </p> Command Description <code>LB:&lt;group&gt;:&lt;cmd&gt;:&lt;value&gt;</code> Write value to specific command <code>LB:&lt;group&gt;:&lt;cmd&gt;:?</code> Request to read specific command <code>LB:&lt;group&gt;:?</code> Request to read all commands in group <code>LB:?</code> Request to read all LabBoard commands <code>LB:&lt;group&gt;:&lt;cmd&gt;:!</code> Enable notify for specific command. <code>!0</code> - disable <code>LB:&lt;group&gt;:!</code> Enable notify for all commands in group. <code>!0</code> - disable <code>LB:!</code> Enable notify for all LabBoard commands. <code>!0</code> - disable <p>Examples: </p> <p>Calling <code>LB:OUT:DAC1:1500</code> will change DAC1 output to 1.5 Volts. Calling <code>LB:OUT:DAC1:?</code> will return current value of DAC1 - <code>LB:OUT:DAC1:1500</code>. Calling <code>LB:IN:?</code> will return of all 5 \"Voltage input\" commands with values. Calling <code>LB:IN:5V:!</code> will stream <code>LB:IN:5V:1000</code> value on each change.  </p>"},{"location":"labboard/serial-protocol/#voltage-input","title":"Voltage input","text":"<p>Read voltage of <code>VIN</code>, <code>\u00b150V</code>, <code>\u00b15V</code>, <code>\u00b10.5V</code> pins and current of <code>SHUNT</code> pin.</p> Command Parameter Description <code>LB:IN:VIN:</code> <code>6000</code> - <code>30000</code> mV VIN pin voltage <code>LB:IN:50V:</code> <code>-50000</code> - <code>50000</code> mV \u00b150V pin voltage <code>LB:IN:5V:</code> <code>-6150</code> - <code>6150</code> mV \u00b15V pin voltage <code>LB:IN:05V:</code> <code>-700</code> - <code>700</code> mV \u00b10.5V pin voltage <code>LB:IN:AMP:</code> <code>0</code> - <code>800</code> mA SHUNT pin current <p><code>LB:IN:50V</code> and <code>LB:IN:05V</code> limits can vary a bit. Read instructions how to setup current measurement. <code>-100000</code> is returned if measurement is invalid or over the limit. Channel overvoltage may invalidate measurements of other channels also.  </p>"},{"location":"labboard/serial-protocol/#voltage-output","title":"Voltage output","text":"<p>Set voltage to <code>VREG</code>, <code>DAC1</code>, <code>DAC2</code>, <code>DAC3</code> pins.</p> Command Parameter Description <code>LB:OUT:VREG:</code> <code>3000</code> - <code>VIN - 1000</code> mV VREG pin voltage <code>LB:OUT:DAC1:</code> <code>0</code> - <code>3250</code> mV DAC1 pin voltage <code>LB:OUT:DAC2:</code> <code>0</code> - <code>3250</code> mV DAC2 pin voltage <code>LB:OUT:DAC3:</code> <code>0</code> - <code>3250</code> mV DAC3 pin voltage <p><code>LB:OUT:VREG</code> maximum voltage depends on <code>VIN</code> voltage, which is 15V with provided DC power supply. In this case, output range is - <code>3000</code> - <code>14000</code> mV.  </p>"},{"location":"labboard/serial-protocol/#frequency-generator","title":"Frequency generator","text":"<p>Output configurable Pulse-width modulation to <code>TXD</code> pin.</p> <p></p> Command Parameter Description <code>LB:TXD:RUN:</code> <code>0</code> - stop  <code>1</code> - start TXD  <code>2</code> - start TXD burst Generator control <code>LB:TXD:FHZ:</code> <code>1</code> - <code>1000000</code> Hz Frequency in hertz <code>LB:TXD:FUS:</code> <code>1</code> - <code>1000000</code> \u03bcs Frequency in microseconds <code>LB:TXD:DUS:</code> <code>0</code> - <code>1000000</code> \u03bcs Duty cycle in microseconds <code>LB:TXD:DPCT:</code> <code>0</code> - <code>1000</code> % Duty cycle percentage (<code>% * 10</code>) <code>LB:TXD:CNT:</code> <code>0</code> - <code>65535</code> Pulses count in burst mode <p><code>LB:TXD:FHZ</code> is tied to <code>LB:TXD:FUS</code>. Both control output frequency but with different units. <code>LB:TXD:DUS</code> is tied to <code>LB:TXD:DPCT</code>. Both control output duty cycle but with different units. <code>LB:TXD:DUS</code> maximum value is limited by <code>LB:TXD:FUS</code>. Pulse width can't be longer than Period. <code>LB:TXD:DPCT</code> is percentage multiplied by 10 for more precision. <code>LB:TXD:CNT</code> is a number of pulses to generate when calling command <code>LB:TXD:RUN:2</code>.  </p>"},{"location":"labboard/serial-protocol/#frequency-monitor","title":"Frequency monitor","text":"<p>Measure frequency with <code>DIG1</code> pin.</p> Command Parameter Description <code>LB:RXD:RUN:</code> <code>0</code> - disable RXD  <code>1</code> - enable RXD Monitor control <code>LB:RXD:EDGE:</code> <code>0</code> - LOW edge  <code>1</code> - HIGH edge Sample (detect) edge.  Default: HIGH <code>LB:RXD:CNT:</code> write: <code>0</code> - reset to 0  read: pulses count Number of pulses <code>LB:RXD:FHZ:</code> read: <code>0</code> - <code>23000000</code> hertz Measured frequency"},{"location":"labboard/serial-protocol/#digital-inputs","title":"Digital inputs","text":"<p>Read state of digital <code>DIG1</code> and <code>DIG2</code> pins.</p> Command Parameter Description <code>LB:DIG1:</code> <code>0</code> - LOW  <code>1</code> - HIGH Digital pin state <code>LB:DIG2:</code> <code>0</code> - LOW  <code>1</code> - HIGH Digital pin state"},{"location":"labboard/serial-protocol/#display-control","title":"Display control","text":"Command Parameter Description <code>LB:DISP:TXT:&lt;text&gt;</code> string Put text on display (align left) <code>LB:DISP:TXT:&lt;seg&gt;:&lt;text&gt;</code> <code>&lt;seg&gt;</code> : <code>0</code> - <code>8</code> <code>&lt;text&gt;</code> : string Put text on display (offset from left) <code>LB:DISP:DIM:</code> <code>0</code> - <code>15</code> Display brightness <code>LB:DISP:BLI:&lt;rate&gt;</code> <code>&lt;rate&gt;</code> : milliseconds Display blink rate <code>LB:DISP:BLI:&lt;hex&gt;:&lt;rate&gt;</code> <code>&lt;hex&gt;</code> : HEX value <code>0</code> - <code>1FF</code> <code>&lt;rate&gt;</code> : milliseconds Display segment blink rate <code>LB:DISP:MON:</code> <code>0</code> - disabled  <code>1</code> - enabled Serial monitor mode  Default: enabled <p><code>&lt;text&gt;</code> is a string of 9 characters. Symbols <code>.</code> <code>,</code> will use dot segment. Example: <code>DISP 4.567</code>. <code>&lt;hex&gt;</code> is map of segments that will be affected. There are 9 segments, starting at from left. <code>&lt;rate&gt;</code> is blinking frequency in milliseconds. Setting <code>0</code> will disable blinking. <code>LB:DISP:MON</code> is a feature to print <code>Serial.println()</code> content to display in <code>4. SERIAL</code> mode.  </p>"},{"location":"labboard/serial-protocol/#key-press","title":"Key press","text":"<p>Read currently pressed LabBoard keys.</p> Command Parameter Description <code>LB:KEY:&lt;hex&gt;</code> <code>&lt;hex&gt;</code>: HEX value <code>0</code> - <code>1F</code> Binary map of pressed keys <p><code>&lt;hex&gt;</code>: <code>B00001</code> - SET- <code>B00010</code> - SET+ <code>B00100</code> - Right SELECT <code>B01000</code> - Middle SELECT <code>B10000</code> - Left SELECT <code>LB:KEY</code> returns HEXdecimal value. Example: <code>LB:KEY:C</code> converts to <code>B01100</code>. This means that keys Right SELECT and Middle SELECT are currently pressed.  </p>"},{"location":"labboard/serial-protocol/#led-control","title":"LED control","text":"<p>Control individual LabBoard LED.</p> Command Parameter Description <code>LB:LED:&lt;hex&gt;</code> <code>&lt;hex&gt;</code>: HEX value <code>0</code> - <code>7FF</code> Binary map of LED state <code>LB:LED:&lt;num&gt;:&lt;state&gt;</code> <code>&lt;num&gt;</code>: LED number <code>1</code> - <code>11</code> <code>&lt;state&gt;</code>: <code>0</code> - off, <code>1</code> - on State of specific LED LED names Number Name on board Binary map 0 All <code>B00000000000</code> 1 DIG1 <code>B00000000001</code> 2 DIG2 <code>B00000000010</code> 3 \u00b150V <code>B00000000100</code> 4 \u00b15V <code>B00000001000</code> 5 \u00b10.5V <code>B00000010000</code> 6 DAC1 <code>B00000100000</code> 7 DAC2 <code>B00001000000</code> 8 DAC3 <code>B00010000000</code> 9 VIN <code>B00100000000</code> 10 VREG <code>B01000000000</code> 11 mAmp <code>B10000000000</code> <p><code>&lt;hex&gt;</code> is binary map on turned on LEDs. <code>&lt;num&gt;</code> is number of LED in a list from DIG1 to mAmp. Starting at digit <code>1</code> to <code>11</code>. <code>0</code> - all. <code>&lt;state&gt;</code> is state of LED. <code>0</code> - lit off, <code>1</code> - lit on. Example: command <code>LB:LED:2C</code> will turn on <code>\u00b150V</code>, <code>\u00b15V</code> and <code>DAC1</code>. All other - off. Example: command <code>LB:LED:10:1</code> will turn on <code>mAmp</code>. Does not change other LED.  </p>"},{"location":"labboard/serial-protocol/#configuration","title":"Configuration","text":"<p>Control LabBoard settings.</p> Command Parameter Description <code>LB:CFG:REV:</code> <code>22</code> <code>23</code> Revision number <code>LB:CFG:VER:</code> <code>200</code> Firmware version <code>LB:CFG:SBAUD:</code> <code>57600</code> Default serial baud rate <code>LB:CFG:SMODE:</code> <code>0</code> - PC <code>1</code> - Arduino Default serial mode  Default: Arduino <code>LB:CFG:SON:</code> <code>0</code> - off  <code>1</code> - on Background serial mode  Default: off <code>LB:CFG:DISP:</code> <code>7</code> Display brightness <code>LB:CFG:VREG:</code> <code>0</code> Calibration offset <code>LB:CFG:DAC1:</code> <code>0</code> Calibration offset <code>LB:CFG:DAC2:</code> <code>0</code> Calibration offset <code>LB:CFG:DAC3:</code> <code>0</code> Calibration offset <code>LB:CFG:VIN:</code> <code>0</code> Calibration offset <code>LB:CFG:50V:</code> <code>0</code> Calibration offset <code>LB:CFG:5V:</code> <code>0</code> Calibration offset <code>LB:CFG:05V:</code> <code>0</code> Calibration offset <code>LB:CFG:RST:</code> <code>1</code> Reset all configuration Restart required after. <p><code>LB:CFG:REV</code> is board revision number. v.2.1 and v.2.2 both returns <code>22</code>. <code>LB:CFG:VER</code> is firmware version number. <code>250</code> converts to 2.50. <code>LB:CFG:DISP</code> is default display brightness. Value between <code>0</code> and <code>15</code>. Calibration offset is a drift from correct measurement in mV. Can be negative.  </p>"},{"location":"labboard/serial-protocol/#system-control","title":"System control","text":"Command Parameter Description <code>LB:BOOT:</code> <code>1</code> Restart in boot mode <code>LB:RST:</code> <code>1</code> Restart LabBoard <p>Boot mode is used during firmware update.  </p>"},{"location":"labboard/features/","title":"Features","text":"<p>Starting with firmware version v2.00, LabBoard incorporates menu system to switch between different modes and change settings. This page describes how to navigate it.</p>"},{"location":"labboard/features/#menu-system","title":"Menu system","text":"<p>Menu can be opened and controlled using LabBoard buttons:</p> <ul> <li>Any two key press - menu open  </li> <li>SET+ - menu scroll up  </li> <li>SET- - menu scroll down  </li> <li>Left SELECT - menu go back or exit to Main screen </li> <li>Right SELECT - menu item select  </li> <li>Middle SELECT - not used </li> </ul>"},{"location":"labboard/features/#changing-working-mode","title":"Changing working mode","text":"<ol> <li><code>SEtUP</code> - Setup menu (settings)</li> <li><code>COUNt</code> - Pulse counter mode</li> <li><code>FREq</code> - Frequency meter mode</li> <li><code>PULSE</code> - Pulse generator mode</li> <li><code>SERIAL</code> - Serial monitor mode</li> <li><code>I2C</code> - I2C scanner mode</li> <li><code>dHt11</code> - DHT11 monitor mode</li> <li><code>AD9833</code> - AD9833 control mode</li> </ol>"},{"location":"labboard/features/#setup-menu-options","title":"Setup menu options","text":"<ol> <li><code>dISP</code> - Display brightness</li> <li><code>dAC</code> - DAC output manual adjust</li> <li><code>AdC</code> - Voltage measure manual adjust</li> <li><code>CALIb</code> - Auto calibration</li> <li><code>SERIAL</code> - Default Serial mode baud rate</li> <li><code>UERSI</code> - Firmware version</li> <li><code>rESEt</code> - Factory reset</li> <li><code>boot</code> - Enter boot mode</li> </ol> <p>For more details see setup menu page</p>"},{"location":"labboard/features/ad9833-control/","title":"7. AD9833 control","text":"<p>Control AD9833 chip directly from LabBoard. Allows to control output frequency and waveform without requiring to hook up Arduino. It can be found in Audio side panel ver 3.7.</p>"},{"location":"labboard/features/ad9833-control/#setup","title":"Setup","text":"<ol> <li>Hook up power to side panel. Chip requires 3.3V.</li> <li>Connect wires:  <ul> <li>+3.3V to LabBoard 3.3V</li> <li>+5V to LabBoard 5V</li> <li>GND to LabBoard GND</li> <li>CLK to LabBoard SCL</li> <li>DATA to LabBoard SDA</li> <li>SYNC to LabBoard TXD</li> </ul> </li> <li>Select mode <code>7. AD9833</code></li> <li>Display will show <code>1000H</code> and \"OUT signal\" pin (green wire) start output 1000 Hz frequency. Lower pins is simply connected to GND.</li> </ol>"},{"location":"labboard/features/ad9833-control/#control-frequency","title":"Control frequency","text":"<p>Numerical value can be entered using button combination:</p> <ul> <li>Left SELECT, Middle SELECT - select digit to edit (indicated by a blinking dot).</li> <li>SET+, SET- - change selected digit.</li> </ul> <p>Frequency is updated on value change.</p>"},{"location":"labboard/features/ad9833-control/#change-waveform","title":"Change waveform","text":"<p>4 different waveforms available:</p> <ul> <li>Sine</li> <li>Triangular</li> <li>Square</li> <li>Half-Square</li> </ul> <p>Click Right SELECT to switch between waveforms. Pressing other buttons returns back to frequency select.</p>"},{"location":"labboard/features/dht11-monitor/","title":"6. DHT11 monitor","text":""},{"location":"labboard/features/dht11-monitor/#about","title":"About","text":"<p>Will display temperature and humidity of connected DHT11 sensor.</p>"},{"location":"labboard/features/dht11-monitor/#details","title":"Details","text":"<ul> <li>Connect sensor DATA I/O to TXD pin.</li> <li>Displays environment temperature in Celsius.</li> <li>Displays environment humidity in percentage.</li> </ul>"},{"location":"labboard/features/dht11-monitor/#controls","title":"Controls","text":"<p>Enter mode:</p> <ul> <li>Select Menu &gt; <code>6. dHt11</code>.</li> </ul> <p>Exit mode:</p> <ul> <li>Open menu and select other mode.</li> </ul>"},{"location":"labboard/features/dht11-monitor/#example","title":"Example","text":"<p> Click image to make it larger.</p> <ol> <li>Enter DHT11 mode by selecting Menu &gt; <code>6. dHt11</code>.</li> <li>Connect sensor to 3.3V and GND.</li> <li>Connect sensor DATA I/O to TDX pin.</li> <li>Temperature and humidity readout will be displayed. In case of communication error - <code>no con.</code> will be shown.</li> </ol>"},{"location":"labboard/features/frequency-meter/","title":"2. Frequency meter","text":""},{"location":"labboard/features/frequency-meter/#about","title":"About","text":"<p>Mode used for measuring signal frequency. Display shows current reading in Hertz or Megahertz units.</p>"},{"location":"labboard/features/frequency-meter/#details","title":"Details","text":"<ul> <li>Measure signal frequency at DIG1 pin.</li> <li>Maximum frequency up to 23 MHz*.</li> <li>Input pin is pulled HIGH (default state).</li> <li>Display is updated each second.</li> <li>Display will show value in Hertz. If number exceeds 1Mhz - it will switch to Mhz mode.</li> <li>Signal HIGH level should be in the amplitude from 2 V to 5 V.</li> <li>Left corner LED DIG1 will blink according to input frequency. It is not directly tied to input pin. Only for visual representation.</li> </ul> <p>* Frequencies larger than 10MHz can be affected by electrical conditions (contacts, wire length, no shielding, etc.). Make sure wires are short and signal is stable enough.</p>"},{"location":"labboard/features/frequency-meter/#controls","title":"Controls","text":"<p>Enter mode:</p> <ul> <li>Select Menu &gt; <code>2. FREq</code>.</li> <li>(deprecated) In Main screen hold SET-  for 3 seconds.</li> </ul> <p>Exit mode:</p> <ul> <li>Open menu and select other mode.</li> <li>(deprecated) Press SET- to exit to Main screen.</li> </ul>"},{"location":"labboard/features/frequency-meter/#example","title":"Example","text":"<ol> <li>Connect D9 digital pin to DIG1 frequency meter input.</li> <li>Enter frequency meter mode by selecting Menu &gt; <code>2. FREq</code>.</li> <li>Load code sketch to TotemDuino. This will output 1kHz frequency on pin D9. LabBoard should display <code>1000 HZ</code>. Uses tone() function. <pre><code>void setup() {\n  pinMode(9, OUTPUT); // Set pin D9 to output\n  tone(9, 1000); // Output 1kHz frequency to pin D9\n}\nvoid loop() {\n\n}\n</code></pre></li> <li>Load code sketch to TotemDuino. This will output 8Mhz frequency on pin D9. LabBoard should display <code>8.00000mHZ</code>. Letter 'm' displayed as 2 segments. <pre><code>void setup() {\n  // Set pin D9 to output\n  DDRB |= (1 &lt;&lt; PB1);\n  // Set timer TOP and compare values\n  ICR1 = 1;  // TOP\n  OCR1A = 0; // compare (duty cycle)\n  // Set no prescaler, Fast PWM mode (14)\n  TCCR1A = (1 &lt;&lt; COM1A1) | (1 &lt;&lt; WGM11) ;\n  TCCR1B = (1 &lt;&lt; CS10) | (1 &lt;&lt; WGM12) | (1 &lt;&lt; WGM13);\n}\nvoid loop() {\n\n}\n</code></pre> This code snippet directly writes ATmega328P registers to configure timer 1 to output 8Mhz frequency on pin PB1 (D9).</li> </ol>"},{"location":"labboard/features/i2c-scanner/","title":"5. I2C scanner","text":""},{"location":"labboard/features/i2c-scanner/#about","title":"About","text":"<p>Find address of connected I2C device.</p>"},{"location":"labboard/features/i2c-scanner/#details","title":"Details","text":"<ul> <li>Connect I2C device to SCL and SDA pins.</li> <li>Displays HEX address of I2C device.</li> <li>Up to 10 devices can be connected.</li> </ul>"},{"location":"labboard/features/i2c-scanner/#controls","title":"Controls","text":"<p>Enter mode:</p> <ul> <li>Select Menu &gt; <code>5. I2C</code>.</li> </ul> <p>Exit mode:</p> <ul> <li>Open menu and select other mode.</li> </ul>"},{"location":"labboard/features/i2c-scanner/#example","title":"Example","text":"<p> Click image to make it larger.</p> <ol> <li>Connect I2C device to 3.3V and GND.</li> <li>Connect I2C device to SCL and SDA pins.</li> <li>Enter I2C mode by selecting Menu &gt; <code>5. I2C</code>.</li> <li><code>SCAn...</code> will be displayed until any device is found.</li> <li>Discovered device address will be displayed in the right corner. Represented as hexadecimal value. If multiple found - will scroll between every second.</li> </ol>"},{"location":"labboard/features/pulse-counter/","title":"1. Pulse counter","text":""},{"location":"labboard/features/pulse-counter/#about","title":"About","text":"<p>Mode used for counting number of pulses in a signal. Display shows total number of pulses and increments with each new one. Count value can be reset any time with a button press.</p>"},{"location":"labboard/features/pulse-counter/#details","title":"Details","text":"<ul> <li>Count signal pulses at DIG1 pin.</li> <li>Maximum frequency up to 23 MHz*.</li> <li>Input pin is pulled HIGH (default state).</li> <li>Display is updated each pulse. Value will overflow after 999999999.</li> <li>Signal HIGH level should be in the amplitude from 2 V to 5 V.</li> <li>Left corner LED DIG1 will light up according to signal state (HIGH or LOW). It is not directly tied to input pin. Only for visual representation.</li> </ul> <p>* Frequencies over 10MHz can be affected by electrical conditions (contacts, wire length, voltage, no shielding, etc.). Make sure wires are short and signal is stable enough.</p>"},{"location":"labboard/features/pulse-counter/#controls","title":"Controls","text":"<p>Reset counter to <code>0</code>:</p> <ul> <li>Click Left SELECT</li> </ul> <p>Switch between detection edge (does not change pull-up):</p> <ul> <li>Click Right SELECT to change mode:<ul> <li><code>On HI</code> - count on rising edge \u23bd/\u23ba (default)</li> <li><code>On LO</code> - count on falling edge \u23ba\\\u23bd</li> </ul> </li> </ul> <p>Enter mode:</p> <ul> <li>Select Menu &gt; <code>1. COUNt</code>.</li> <li>(deprecated) In Main screen hold SET+  for 3 seconds.</li> </ul> <p>Exit mode:</p> <ul> <li>Open menu and select other mode.</li> <li>(deprecated) Press SET+ to exit to Main screen.</li> </ul>"},{"location":"labboard/features/pulse-counter/#example","title":"Example","text":"<ol> <li>Connect D9 digital pin to DIG1 pulse counter input.</li> <li>Enter pulse counter mode by selecting Menu &gt; <code>1. COUNt</code>.</li> <li>Load code sketch to TotemDuino: <pre><code>void setup() {\n  pinMode(9, OUTPUT); // Set pin D9 to output\n}\nvoid loop() {\n  for (int i=0; i&lt;10; i++) { // Repeat 10 times\n    digitalWrite(9, HIGH); // Set pin D9 HIGH\n    digitalWrite(9, LOW); // Set pin D9 LOW\n  }\n  delay(500); // Wait 500ms\n}\n</code></pre></li> <li>Observe that the counter increments by 10 every 0.5 second.</li> <li>Click Left SELECT to reset counter value.</li> </ol>"},{"location":"labboard/features/pulse-generator/","title":"3. Pulse generator","text":""},{"location":"labboard/features/pulse-generator/#about","title":"About","text":"<p>Mode used to generate rectangular waveform with configurable frequency and duty cycle. Can work in infinite mode or output burst of preset number of pulses.</p> <p></p>"},{"location":"labboard/features/pulse-generator/#details","title":"Details","text":"<ul> <li>Output configured signal at TXD pin.</li> <li>Inactive TXD pin state - LOW.</li> <li>Output voltage is 3.3V (but works with Arduino 5V logic).</li> <li>Configurable frequency (period) up to 1 MHz.</li> <li>Configurable duty cycle (pulse width).</li> <li>Output continuos signal.</li> <li>Output burst of up to 65535 pulses.</li> <li>Default settings: 10Hz, 50% duty, 5 cnt burst.</li> </ul>"},{"location":"labboard/features/pulse-generator/#controls","title":"Controls","text":"<p>Consists of 1 main screen to activate signal output and 5 screens to set signal generator parameters.</p> <ol> <li><code>___ _ SEL</code> - main screen. Launch continuos mode | launch burst mode | change settings.</li> <li><code>10FHZ</code> - configure frequency (Hz).</li> <li><code>100000FuS</code> - configure frequency in microseconds (\u00b5s).</li> <li><code>50.0d %</code> - configure duty cycle (percentage).</li> <li><code>50000duS</code> - configure duty cycle in microseconds (\u00b5s).</li> <li><code>5cnt</code> - configure burst count (number).</li> </ol> <p>Numerical value can be entered using button combination:</p> <ul> <li>Left SELECT, Middle SELECT - select digit to edit (indicated by a blinking segment).</li> <li>SET+, SET- - change selected digit.</li> <li>Right SELECT - jump to next parameter.  </li> </ul> <p></p>"},{"location":"labboard/features/pulse-generator/#frequency-configuration","title":"Frequency configuration","text":"<p>Signal frequency (pulse period) can be entered in 2 formats:  </p> <ul> <li>hertz: option <code>FHZ</code>, between <code>1</code> and <code>999999</code> Hz.</li> <li>microseconds: option <code>FuS</code>, between <code>1</code> and <code>999999</code> \u00b5s.</li> </ul> <p>Entered values are automatically converted between formats. Changing value updates signal output instantly.  </p> <p>Example: to enter 2000Hz frequency press Right SELECT until <code>FHZ</code> is displayed. Enter number <code>2000</code> and go to <code>___ _ SEL</code>. Example: to enter 500\u00b5s pulse press Right SELECT until <code>FuS</code> is displayed. Enter number <code>500</code> and go to <code>___ _ SEL</code>.  </p> <p>Mathematical relation between hertz and microseconds: <code>frequency = 1000000 / microseconds</code> <code>microseconds = 1000000 / frequency</code> </p>"},{"location":"labboard/features/pulse-generator/#duty-cycle-configuration","title":"Duty cycle configuration","text":"<p>Signal duty cycle (pulse width) can be entered in 2 formats:  </p> <ul> <li>percentage: option <code>d %</code>, between <code>0.0</code> and <code>100.0</code> %.</li> <li>microseconds: option <code>duS</code>, between <code>0</code> and <code>FuS</code> \u00b5s (pulse width can't be higher than period).</li> </ul> <p>Entered values are automatically converted between formats. Changing value updates signal output instantly.  </p> <p>Example: to enter 23.7% duty cycle press Right SELECT until <code>d %</code> is displayed. Enter number <code>23.7</code> and go to <code>___ _ SEL</code>. Example: to enter 500\u00b5s pulse width press Right SELECT until <code>duS</code> is displayed. Enter number <code>500</code> and go to <code>___ _ SEL</code>.  </p> <p>Mathematical relation between hertz, microseconds and percentage: <code>frequency = 1000000 / microseconds</code> <code>microseconds = 1000000 / frequency</code> <code>microseconds = pulse_period_us * duty_cycle / 100</code> </p> <p>Duty cycle is a percentage 0..100% of pulse period (frequency). It specifies how long signal is in HIGH state after pulse start. For example: If we set 400Hz as frequency (2500\u00b5s period) and want 35% time HIGH and 65% time LOW, we need to set duty cycle to: <code>35.0</code>. It means signal will stay HIGH (\u23bd/\u23ba) for 875\u00b5s and then LOW (\u23ba\\\u23bd) for 1625\u00b5s.</p>"},{"location":"labboard/features/pulse-generator/#pulse-count-configuration","title":"Pulse count configuration","text":"<ul> <li>pulse count: option <code>cnt</code>, between <code>1</code> and <code>65535</code>.</li> </ul> <p>This mode allows to output burst of pulses (_|\u23ba|_) when button is pressed. Only used when Middle SELECT key is clicked in <code>___ _ SEL</code> screen.</p> <p>Example waveform of 3 pulse output: ___|\u23ba|__|\u23ba|__|\u23ba|___</p>"},{"location":"labboard/features/pulse-generator/#control-screen","title":"Control screen","text":"<ul> <li>Left SELECT - start/stop infinite series of pulse generation with current settings. Once active, this is indicated by series of square symbols.</li> <li>Middle SELECT - start/stop finite generation of pulses, making number of pulses entered in pulse count (<code>cnt</code>). Once finished, indicate value goes back to a single underscore symbol. When active - incrementing percent of pulses emitted, until end.</li> <li>Right SELECT - (<code>SEL</code>) go back to configuration.</li> </ul> <p>Enter mode:</p> <ul> <li>Select Menu &gt; <code>3. PULSE</code>.</li> <li>(deprecated) In Main screen hold Left SELECT for 3 seconds.</li> </ul> <p>Exit mode:</p> <ul> <li>Open menu and select other mode.</li> </ul>"},{"location":"labboard/features/pulse-generator/#example","title":"Example","text":"<ol> <li>Enter pulse generation mode, select continuous pulse mode with following parameters: Frequency = 100Hz Duty cycle = 50%  </li> <li>Enable infinite pulse mode by pressing Left SELECT button.  </li> <li>Connect TXD pin to an LED.  </li> <li>Observe that LED lights up. Experiment by changing duty cycle and see that LED dims or brightens. Now you\u2019ve got a working PWM module.  </li> </ol>"},{"location":"labboard/features/serial-monitor/","title":"4. Serial monitor","text":"<p>Select board revision</p> <p>This tutorial differs between board revisions. Please select the one you have:</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <p> v.2.1 v.2.2 v.2.3 </p> <p> v.2.1 v.2.2 v.2.3 </p> <p>Check firmware version</p> <p>Documentation is written for the latest firmware version. Read Firmware update section to perform this procedure.</p> <p>Exit serial mode</p> <p>To exit back to menu from serial mode - press both SET+ SET- keys at the same time (instead of any two keys). This is done to allow freely use of LabBoard keys without interruption.</p> <p>Serial mode allows to communicate with LabBoard over serial (UART) and control its features. This interaction can read or write values using Serial protocol commands, enabling external LabBoard control from TotemDuino or PC. This can be used for debugging or as integral part of application (view and control). Multiple features are available:</p> <ul> <li>Read measurements</li> <li>Set output voltage</li> <li>Control signal generator</li> <li>Interact with keys, LED and display</li> <li>Print serial on display <code>Serial.println(\"Arduino\")</code></li> <li>Control LabBoard features over Serial protocol</li> <li>Control LabBoard features with Totem Library from Arduino</li> </ul>"},{"location":"labboard/features/serial-monitor/#main-settings","title":"Main settings","text":"<p>There are multiple ways to use serial communication. When enabling serial mode, LabBoard will ask to choose required configuration:</p> <ul> <li>Baud rate: Communication speed. Must match with one used in <code>Serial.begin(baudrate)</code> or serial terminal application</li> <li>Direction: Selection between <code>PC</code> and <code>Arduino</code>. Swaps TX, RX pins depending on endpoint device (the one who sends commands to LabBoard)</li> <li>Background mode: Enabled in settings (\"Always on\"). Activates serial in normal LabBoard operation mode to work concurrently</li> </ul>"},{"location":"labboard/features/serial-monitor/#connect-to-arduino","title":"Connect to Arduino","text":"<p>Enables communication with Arduino boards over D0 and D1 pins. Serial protocol commands can be sent using Serial: <code>Serial.println(\"LB:OUT:DAC1:500\")</code>. Totem Library provides convenient wrapper functions <code>LB.volt.setDAC1(500)</code> to use within Arduino environment. Read Serial API reference for more information. Arduino examples: Github</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <p>Wiring instructions:</p> Connect with TotemDuino <p>Direction: Arduino. Control: From sketch running on TotemDuino. Power: From TotemDuino DC jack or USB. Required wiring:  </p> <ul> <li>TotemDuino D0 to LabBoard SCL (SWD header pinout)  </li> <li>LabBoard D1 to LabBoard DIG2</li> </ul> <p></p> Connect with Arduino boards <p>Direction: Arduino. Control: From sketch running on Arduino board. Power: From Arduino board DC jack or USB. Flat cable is not connected. Voltages 3.3V, 5V, VIN are provided by Arduino board. LabBoard does not have voltage regulator (Power scheme). Required wiring:  </p> <ul> <li>D0 to LabBoard SCL (SWD header pinout)  </li> <li>D1 to LabBoard DIG2</li> <li>3V3 to LabBoard 3.3V</li> <li>5V to LabBoard 5V</li> <li>GND to LabBoard GND</li> <li>VIN to LabBoard VIN</li> </ul> <p></p> <p>Wiring instructions:</p> Connect with TotemDuino <p>Direction: Arduino. Control: From sketch running on TotemDuino. Power: From TotemDuino DC jack or USB. Required wiring:  </p> <ul> <li>TotemDuino D0 to LabBoard D0 </li> </ul> <p></p> Connect with  Arduino boards <p>Direction: Arduino. Control: From sketch running on Arduino board. Power: From Arduino board DC jack or USB. Flat cable is not connected. Voltages 3.3V, 5V, VIN are provided by Arduino board. LabBoard does not have voltage regulator (Power scheme). Required wiring:  </p> <ul> <li>D0 to LabBoard D0</li> <li>D1 to LabBoard D1</li> <li>3V3 to LabBoard 3.3V</li> <li>5V to LabBoard 5V</li> <li>GND to LabBoard GND</li> <li>VIN to LabBoard VIN</li> </ul> <p></p> <ol> <li>Select serial mode - <code>4. SERIAL</code>.</li> <li>Change value with SET+, SET-. Confirm with Right SELECT.</li> <li>Select baud rate (speed) - <code>bAU 57600</code>.  Must match the one set in <code>Serial.begin(57600)</code>.</li> <li>Select direction - <code>Arduino</code>.</li> <li>Mode is active and displays <code>Serial</code>.</li> </ol>"},{"location":"labboard/features/serial-monitor/#connect-to-pc","title":"Connect to PC","text":"<p>Enables communication with external devices, capable to interpret serial data. This allows to connect data stream to PC over USB or use other device to communicate over TX and RX. LabBoard control can be achieved using Serial protocol commands. Python examples: Github</p> LabBoard v.2.1, v.2.2LabBoard v.2.3 <p>Wiring instructions:</p> Connect over TotemDuino <p>Direction: PC. Control: From PC over TotemDuino as passthrough. Power: From TotemDuino DC jack or USB. TotemDuino will be disabled to act as passthrough for direct LabBoard communication with PC. Required wiring:  </p> <ul> <li>TotemDuino D0 to LabBoard SCL (SWD header pinout)  </li> <li>LabBoard D1 to LabBoard DIG2</li> <li>RST to GND (disable TotemDuino)</li> </ul> <p></p> Connect over USB-Serial converter with TotemDuino <p>Direction: PC. Control: From PC over USB-Serial converter. Power: From TotemDuino DC jack or USB. Required wiring:  </p> <ul> <li>TX to LabBoard SCL (SWD header pinout)</li> <li>RX to LabBoard DIG2</li> <li>GND to LabBoard GND</li> </ul> <p></p> Connect over USB-Serial converter without TotemDuino <p>Direction: PC. Control: From PC over USB-Serial converter. Power: From USB-Serial converter. Flat cable is not connected. VIN not available!. Certain LabBoard functionality will not work. Voltages 3.3V, 5V are provided by USB-Serial converter. LabBoard does not have voltage regulator (Power scheme). Required wiring:  </p> <ul> <li>TX to LabBoard SCL (SWD header pinout)</li> <li>RX to LabBoard DIG2</li> <li>GND to LabBoard GND</li> <li>3v to LabBoard 3.3V</li> <li>5v to LabBoard 5V</li> </ul> <p></p> Connect over Arduino board <p>Direction: PC. Control: From PC over Arduino board as passthrough. Power: From Arduino board DC jack or USB. Flat cable is not connected. Voltages 3.3V, 5V, VIN are provided by Arduino board. LabBoard does not have voltage regulator (Power scheme). Arduino board will be disabled to act as passthrough for direct LabBoard communication with PC. Required wiring:  </p> <ul> <li>D0 to LabBoard SCL (SWD header pinout)</li> <li>D1 to LabBoard DIG2</li> <li>3V3 to LabBoard 3.3V</li> <li>5V to LabBoard 5V</li> <li>GND to LabBoard GND</li> <li>VIN to LabBoard VIN</li> <li>RESET to GND (disable Arduino)</li> </ul> <p></p> <p>Wiring instructions:</p> Connect over TotemDuino <p>Direction: PC. Control: From PC over TotemDuino as passthrough. Power: From TotemDuino DC jack or USB. TotemDuino will be disabled to act as passthrough for direct LabBoard communication with PC. Required wiring:  </p> <ul> <li>RST to GND (disable TotemDuino)</li> </ul> <p></p> Connect over USB-Serial converter <p>Direction: PC. Control: From PC over USB-Serial converter. Power: From USB-Serial converter. Flat cable is not connected. VIN not available!. Certain LabBoard functionality will not work. Voltages 3.3V, 5V are provided by USB-Serial converter. LabBoard does not have voltage regulator (Power scheme). Required wiring:  </p> <ul> <li>TX to LabBoard D0</li> <li>RX to LabBoard D1</li> <li>GND to LabBoard GND</li> <li>3v to LabBoard 3.3V</li> <li>5v to LabBoard 5V</li> </ul> <p></p> Connect over Arduino board <p>Direction: PC. Control: From PC over Arduino board as passthrough. Power: From Arduino board DC jack or USB. Flat cable is not connected. Voltages 3.3V, 5V, VIN are provided by Arduino board. LabBoard does not have voltage regulator (Power scheme). Required wiring:  </p> <ul> <li>D0 to LabBoard D0</li> <li>D1 to LabBoard D1</li> <li>3V3 to LabBoard 3.3V</li> <li>5V to LabBoard 5V</li> <li>GND to LabBoard GND</li> <li>VIN to LabBoard VIN</li> <li>RESET to GND (disable Arduino)</li> </ul> <p></p> <ol> <li>Select serial mode - <code>4. SERIAL</code>.</li> <li>Change value with SET+, SET-. Confirm with Right SELECT.</li> <li>Select baud rate (speed) - <code>bAU 57600</code>.  Select same speed in terminal application.</li> <li>Select direction - <code>PC</code>.</li> <li>Mode is active and displays <code>Serial</code>.</li> </ol> <p>Testing communication with PC: </p> <ol> <li>Open Arduino IDE, select port, open Serial Monitor.</li> <li>Select <code>57600 baud</code>.</li> <li>Type in <code>LB:IN:5V:?</code>, press Enter.</li> <li>Observe received value <code>LB:IN:5V:0</code>.</li> </ol>"},{"location":"labboard/features/serial-monitor/#serial-print-display","title":"Serial print display","text":"<p>In serial mode (except background) - LabBoard will display data sent using <code>Serial.println()</code> function, acting similar as Arduino IDE Serial Monitor. Because it is limited by showing 9 symbols ant the same moment - it will only display last received line (ending with new line symbol \"\\n\") and aligned to right. Start of longer text will be cut off. It recognizes whole alphabet, but certain letters and symbols are limited by 7 segments.</p> <p>Example:</p> <pre><code>Serial.println(\"Hi\");\nSerial.print(\"This\");\nSerial.print(\"HELLO.\");\nSerial.println(\" 123.\");\n</code></pre> <p>Arduino IDE Serial Monitor would print: <pre><code>Hi\nThis HELLO. 123.\n</code></pre></p> <p>LabBoard will display only <code>HELLO. 123.</code>, because last new line symbol \"\\n\" was sent by <code>Serial.println(\" 123.\")</code>. \"This\" didn't fit as line of text is aligned to its end. Symbols '.' and ',' are converted to dot segment on display.</p> <p>It can be disabled with LB.display.setMonitor(<code>false</code>) function or <code>LB:DISP:MON:0</code>. Any data stream not recognized by Serial protocol will be skipped.</p>"},{"location":"labboard/features/serial-monitor/#always-on-background-mode","title":"Always on (background) mode","text":"<p>In this mode - serial is always enabled to control LabBoard during normal operation (not limited to \"4. Serial mode\"). This can be used to run LabBoard normally and read measurements externally at the same time.</p> <p>Note: Serial wiring has to be done according selected endpoint device. Features \"I2C scan\" and \"AD9833 control\" will be disabled on v.2.1, v.2.2 boards if \"always on\" mode is enabled. SCL pin is occupied with serial communication. </p> <p>To enable background mode:  </p> <ol> <li>Open menu &gt; <code>0. SEtUP</code></li> <li>Select <code>5. SERIAL</code></li> <li>Click Middle SELECT key to switch between settings. Change using SET+ SET- keys.  </li> <li>Set default baud rate <code>bAU 57600</code></li> <li>Set endpoint device - <code>Arduino</code> or <code>PC</code></li> <li>Set <code>ALVAYS</code> mode to <code>On</code></li> </ol> <p>Serial mode will be active on TX, RX (SCL, DIG2 or D0, D1) pins all the time.</p>"},{"location":"labboard/features/setup/","title":"0. Setup","text":"<p>Menu to access various LabBoard configuration options. These setting are stored in memory and used during LabBoard operation. To exit selected option - press Left SELECT button. Settings are saved when value is changed. No need to press a button for confirmation. Some menu options required to press and hold <code>run</code> button (Right SELECT) to execute specified action.</p> <ol> <li><code>dISP</code> - Display brightness</li> <li><code>dAC</code> - DAC output manual adjust</li> <li><code>AdC</code> - Voltage measure manual adjust</li> <li><code>CALIb</code> - Auto calibration</li> <li><code>SERIAL</code> - Default Serial mode baud rate</li> <li><code>UERSI</code> - Firmware version</li> <li><code>rESEt</code> - Factory reset</li> <li><code>boot</code> - Enter boot mode</li> </ol>"},{"location":"labboard/features/setup/#setup-menu-options","title":"Setup menu options","text":""},{"location":"labboard/features/setup/#display","title":"1. Display brightness","text":"<p>Change display and LED brightness.  </p> <p><code>diSP 7</code> will be shown and LED will light up to indicate current brightness level.  </p> <p>Using SET+ and SET- increase or decrease brightness level between <code>0</code> and <code>15</code>.  </p>"},{"location":"labboard/features/setup/#dac-offset","title":"2. DAC manual offset","text":"<p>Manually adjust DAC offset. Can be used to fine tune DAC channel output if value displayed on screen differs from multimeter reading.  </p> <p><code>dAC 0.000</code> will be shown and selected DAC channel LED will light up.  </p> <p>Click Middle SELECT to switch active DAC channel to configure. Using SET+ and SET- increase or decrease offset.  </p>"},{"location":"labboard/features/setup/#adc-offset","title":"3. ADC manual offset","text":"<p>Manually adjust ADC offset. Can be used to fine tune voltage measurements if value displayed on screen differs from multimeter readings. These values are auto generated during calibration, but can be manually adjusted if required.  </p> <p><code>AdC 0.000</code> will be shown and selected voltage channel LED will light up.  </p> <p>Click Middle SELECT to switch active voltage channel to configure. Using SET+ and SET- increase or decrease offset.  </p>"},{"location":"labboard/features/setup/#calibration","title":"4. Auto calibration","text":"<p>This feature will calibrate ADC channels for more precise voltage measurements.  </p> <p><code>CALIb run</code> will be shown. It is in  waiting state until \"run\" button is pressed.</p> <ol> <li>Connect wires as specified:<ul> <li>\u00b150V to GND</li> <li>\u00b15V to GND</li> <li>\u00b10.5V to DAC1</li> </ul> </li> <li>Press and hold Right SELECT for 1s until calibration starts</li> <li><code>888888888</code> lights up. Wait for display <code>donE</code></li> <li>Press Left SELECT to exit</li> </ol>"},{"location":"labboard/features/setup/#serial","title":"5. Serial settings","text":"<p>Contains 3 different serial settings:</p> <ul> <li>Default baud rate: selected default speed of serial mode <code>baud 57600</code></li> <li>Communication direction: selected value of endpoint device <code>Arduino</code> or <code>PC</code></li> <li>Always on (background mode): enable of disable Always on serial mode</li> </ul> <p>Jump between settings by pressing Middle SELECT key. Use SET+ and SET- to change value.  </p>"},{"location":"labboard/features/setup/#firmware","title":"6. Firmware version","text":"<p>Display current firmware version.  </p> <p><code>UERSI x.xx</code> will be shown indicating installed firmware version.</p>"},{"location":"labboard/features/setup/#reset","title":"7. Factory reset","text":"<p>Factory reset option will reset all settings to default state. Calibration will be requested after reset is done.  </p> <p><code>rESEt run</code> will be shown. It is in waiting state until \"run\" button is pressed.</p> <ol> <li>Press and hold Right SELECT for 1s until reset starts</li> <li><code>donE</code> will be displayed briefly</li> <li><code>CALIb run</code> will be shown. Follow calibration section to proceed</li> </ol>"},{"location":"labboard/features/setup/#boot","title":"8. Enter boot mode","text":"<p>Enter system bootloader for firmware update.</p> <p><code>boot  run</code> will be shown. It is in waiting state until \"run\" button is pressed.</p> <ol> <li>Press and hold Right SELECT for 1s</li> <li><code>boot   on</code> will be displayed</li> <li>Run firmware download. Follow firmware update section</li> </ol>"},{"location":"mini-lab/","title":"Overview","text":"<p>Check firmware version</p> <p>Documentation is written for the latest firmware version. Read Firmware update section to perform this procedure.</p> <p></p> <p> TKM-ML1 Totem Mini Lab contains all the necessities for starting your path in the world of electronics and programming. Using it, should be simple and fun! While building it, we tried to address and improve all the negative parts about prototyping - no longer you\u2019ll have to deal with messy wiring, fragile connections and headaches of where to mount every separate part of your experiment.</p> <p>Mini Lab is meant to be used together with Totem construction system which allows users to build solid workbenches with integrated breadboards, as well as available expansion boards which can expand the capabilities of the Mini Lab even further.</p>"},{"location":"mini-lab/#who-is-it-for","title":"Who is it for","text":"<p>Main goal of Mini Lab is to provide a platform which would give an easy and approachable way for students and young makers communities to build up on, using it as a stepping stone into the world of electronics and programming.</p> <p>While not intended to be used in place of a professional level equipment, Mini Lab has its own advantages - small size, speed of setup and versatility could find its place in any makers shop.</p>"},{"location":"mini-lab/#whats-in-the-kit","title":"What\u2019s in the kit","text":"<p>In the Mini Lab you\u2019ll find:  </p> <ul> <li>TotemDuino - our improved version of Arduino UNO platform</li> <li>LabBoard - a capable experimentation and measuring platform</li> <li>34-pin flat cable - use it to connect TotemDuino and LabBoard together</li> <li>Collection of Totem construction parts - for building Totem workbench</li> <li>Power supply - to power Mini Lab from the mains</li> <li>Breadboards - to extend your experimentation area</li> <li>Breadboard cables - short male to male cables useful for experimentation</li> <li>Building instructions - suggested use of Totem parts for building a workbench where everything neatly mounts together</li> </ul> <p>Sold separately:</p> <ul> <li>I/O side panel - a kit of buttons, switches and indicators</li> <li>Sensor side panel - a kit of microphone, display, temperature sensor and DC motor controller</li> <li>Audio side panel - a kit of speaker and audio amplifiers</li> <li>Side panel stand - structure for more stable side panel mounting or placing on the table</li> </ul>"},{"location":"mini-lab/#assembly-guide","title":"Assembly guide","text":"<p>Totem-mini-lab-building-instructions.pdf</p> <p>Totem-Building-Good-practises-Mini-LaB.pdf</p>"},{"location":"mini-lab/getting-started/","title":"Getting started","text":"<p>The kit provides easy way to connect components, use LabBoard for measurements and TotemDuino for programming. Additional side panels contains many useful components, conveniently accessible on a single board.</p> <p>Assembly guide can be found in Mini Lab section.</p>"},{"location":"mini-lab/getting-started/#power-up","title":"Power up","text":"<p>Mini Lab can be powered with supplied DC adapter or trough USB. These inputs are located in TotemDuino board. It is suggested to use DC adapter for all available features to work. Both cables can be plugged also (e.g. to power up and program TotemDuino from PC). For more information about power distribution read Power scheme section.</p>"},{"location":"mini-lab/getting-started/#layout","title":"Layout","text":"<p>LabBoard is a main central area that provides power, measurement features and extends TotemDuino to make all the pins easy accessible. There are a lot of pin headers, each one with different functionality. Check image and description below for more information. To control LabBoard and its features read LabBoard features section.</p> <ul> <li>Red area - TotemDuino pins mirrored to LabBoard over flat cable. Both are Arduino UNO form factor (shields compatible), has same markings and can be used interchangeably. Top ones are easier to reach.</li> <li>Green area - TotemDuino pins (red ones) mirrored to additional pin header for easier layout.</li> <li>Blue area - LabBoard specific pins (separated from TotemDuino) for measurements and other features.</li> <li>Yellow area - Pins for regulated power output. Read power scheme section for more information on how power rails are distributed across Mini Lab.</li> </ul> TotemDuino detail layout LabBoard detail layout"},{"location":"mini-lab/getting-started/#breadboard","title":"Breadboard","text":"<p>Breadboards are used to make circuit prototypes or to connect components together. They can be snapped in to the grid of holes with contacts underneath. This allows to make circuitry using jumper cables, without require to solder. Holes are connected together in a certain way (see picture above). Breadboard has numbers and letters to identify hole location. Make sure to mount ir correct way up.  </p> <ul> <li>\u2501 Horizontal lines - mainly used to distribute power (3V,5V,GND) as it covers whole length of the board.</li> <li>\u2503 Vertical lines - mainly used to place components. Lines can be connected together using jumper wires.</li> </ul> <p>Example of using breadboard: </p>"},{"location":"mini-lab/getting-started/#programming","title":"Programming","text":"<p>TotemDuino is a programmable development board and can be used to control components during experiments with Mini Lab. It is fully backwards compatible with Arduino UNO platform, so Arduino IDE can be used to upload firmware for TotemDuino as well.</p> <p>Using mini USB cable you can transfer new firmware sketches into TotemDuino. While you can use different programming environments to write firmware for it, using Arduino is one of the most friendliest and quickest way to start.</p>"},{"location":"mini-lab/getting-started/#setup-arduino","title":"Setup Arduino","text":"<p>To write code for TotemDuino board, an Arduino IDE application is required. Follow Setup instructions. Setup Arduino</p>"},{"location":"mini-lab/getting-started/#understand-arduino","title":"Understand Arduino","text":"<p>Arduino code is based on C++ programming language. Also there is an additional set of functions to control pins and other features. Arduino language reference</p>"},{"location":"mini-lab/getting-started/#learn-arduino","title":"Learn Arduino","text":"<p>TotemDuino is used to attach and control various components like LED, buttons, potentiometers and much more. To learn about basic components read Arduino lessons. Arduino lessons</p>"},{"location":"mini-lab/getting-started/#use-side-panels-with-arduino","title":"Use side panels with Arduino","text":"<p>Totem Side panels nicely packs standard components that are fundamental to learn electronics. To see how to use them with TotemDuino - see example projects. Side panel example projects</p>"},{"location":"mini-lab/power/","title":"Power scheme","text":"<p>Mini Lab comes with a 15 V, 2 Amp external power supply (older units with 12V). Internally, supply voltage is regulated into several voltages needed to run various parts of the system. Each of these can be used during measurements or experiments, as they do have easily accessible pins that equipment can be connected to.</p> <p>While Mini Lab can easily use any of the available voltage for your experiments, digital signals going to and from TotemDuino shouldn\u2019t be higher than the currently selected running voltage for it. A selector switch on the TotemDuino board can set the supply voltage for the TotemDuino microcontroller either at 5 or 3.3 volts. This allows you to set the logic level interfacing with various external equipment that could only be used at one of these voltages without any additional voltage level converters. Refer to TotemDuino section for explanation on how to set the voltage.</p> <p>Available voltage sources are:  </p> <ul> <li>15 V, 2.0 A - (VIN) direct supply voltage (12V older units).</li> <li>5 V, 0.5 A - (+5V) regulated supply voltage, shared with TotemDuino.</li> <li>-5 V, 0.5 A - (-5V) separate regulated voltage, for experimentation with operation amplifiers.</li> <li>3.3 V, 0.25 A - (+3.3V) regulated supply voltage, shared with TotemDuino and LabBoard processor.</li> <li>0 .. 3.25 V - (DAC1, DAC2, DAC3) programmable regulated voltage output, up to 0.35 A.</li> <li>3 .. 14 V - (VREG) programmable, high voltage, regulated voltage output, up to 0.35 A.</li> </ul> <p>It is possible to run only from USB power, but in that case modules relying on higher voltage, such as programmable regulator (VREG) and direct supply (VIN) will not be available. </p>"},{"location":"modules/","title":"Totem modules","text":"<p>A list of Totem products controllable with Totem Arduino library.</p> Totem Library headers<pre><code>// Control over Bluetooth\n#include &lt;TotemBLE.h&gt;              // Discover Totem boards (scan)\n#include &lt;TotemMiniControlBoard.h&gt; // Connect Mini Control Board\n#include &lt;TotemRoboBoardX3.h&gt;      // Connect RoboBoard X3\n#include &lt;TotemRoboBoardX4.h&gt;      // Connect RoboBoard X4\n// Control over Serial\n#include &lt;TotemLabBoard.h&gt;         // Interface Mini Lab\n</code></pre> <ul> <li> <p> Bluetooth boards</p> <p>Boards featuring remote control option over Bluetooth.</p> <p> BLE Modules</p> </li> <li> <p> Mini Lab</p> <p>Monitor and control Mini Lab from TotemDuino over Serial.</p> <p> LabBoard</p> </li> <li> <p> X4 TBUS modules</p> <p>Control RoboBoard X4 extension modules over TBUS.</p> <p> X4 modules</p> </li> </ul>"},{"location":"modules/#install-library","title":"Install library","text":"<p>This functionality requires Totem Arduino library. Install it before using in a project.  </p> <ol> <li>Select <code>Sketch</code> \u2192 <code>Include Library</code> \u2192 <code>Manage libraries..</code> </li> <li>In search field type in <code>totem</code>.  </li> <li>Click Install and wait for it to complete.  </li> <li>Close Library Manager window. </li> </ol>"},{"location":"modules/11/","title":"[11] Distance module","text":""},{"location":"modules/11/#description","title":"Description","text":"<p>Module designed for measuring distance to an obstacle. It uses infrared laser sensor to avoid limitations of ultrasonic counterparts. With included 8 color LED, module can be used for car headlights or distance indication.  </p> <p>Features: </p> <ul> <li>Laser distance sensing (range 3-130 cm)  </li> <li>8 individual controllable RGB lights  </li> </ul> <p></p>"},{"location":"modules/11/#code-examples","title":"Code examples","text":"<p>Arduino projects: 11_distance</p> <pre><code>#include &lt;TotemModule11.h&gt;\nTotemModule11 module;\n</code></pre> Function usage (click to expand) <p><pre><code>/* Distance */\n// Read distance in millimeters\nfloat distMM = module.getMM();\n// Read distance in centimeters\nfloat distCm = module.getCm();\n// Read distance in foot\nfloat distFoot = module.getFoot();\n// Read distance in inches\nfloat distInch = module.getInch();\n// Check if some objet is detected\nbool inRange = module.isDetected();\n</code></pre> <pre><code>/* All RGB lights control */\n// Set all LED to \"Totem\" colors\nmodule.rgb.colorTotem();\n// Set all LED to green color\nmodule.rgb.color(0, 255, 0);\nmodule.rgb.color(0x00FF00);\n// Turn all LED on\nmodule.rgb.on();\n// Turn all LED off\nmodule.rgb.off();\n// Set all LED to on\nmodule.rgb.set(HIGH);\n// Toggle all LED state on / off\nmodule.rgb.toggle();\n// Check if any LED is on\nbool isOn = module.rgb.isOn();\n// Enable bright mode\nmodule.rgb.setBrightMode(true);\n</code></pre> <pre><code>/* Single RGB light control */\n// Set LED 1 to color red\nmodule.rgb[0].color(255, 0, 0);\n// Set LED 4 to color green\nmodule.rgb[3].color(0, 255, 0);\n// Set LED 8 to color blue\nmodule.rgb[7].color(0, 0, 255);\n</code></pre></p>"},{"location":"modules/11/#functions","title":"Functions","text":""},{"location":"modules/11/#distance","title":"Distance","text":"<p>Get distance between module and barrier in millimeters. Returns: <code>distance</code> - millimeters to object ~[<code>30</code>:<code>1300</code>]mm. <code>0</code> - not detected.  </p> <p>Get distance between module and barrier in centimeters. Returns: <code>distance</code> - centimeters to object ~[<code>3</code>:<code>130</code>]cm. <code>0</code> - not detected.  </p> <p>Get distance between module and barrier in foot. Returns: <code>distance</code> - foot to object (float) ~[<code>0.098</code>:<code>4.265</code>]ft. <code>0</code> - not detected.  </p> <p>Get distance between module and barrier in inches. Returns: <code>distance</code> - inches to object (float) ~[<code>1.181</code>:<code>51.181</code>]inch. <code>0</code> - not detected.  </p> <p>Check if object is in sensing range (detected). Returns: <code>isDetected</code> - object detected [<code>true</code>:<code>false</code>].  </p>"},{"location":"modules/11/#getMM","title":"<code>distance</code> module.getMM()","text":""},{"location":"modules/11/#getCm","title":"<code>distance</code> module.getCm()","text":""},{"location":"modules/11/#getFoot","title":"<code>distance</code> module.getFoot()","text":""},{"location":"modules/11/#getInch","title":"<code>distance</code> module.getInch()","text":""},{"location":"modules/11/#isDetected","title":"<code>isDetected</code> module.isDetected()","text":""},{"location":"modules/11/#all-rgb-lights-control","title":"All RGB lights control","text":"<p>Set all LED to \"Totem\" colors (blue, yellow, green).  </p>"},{"location":"modules/11/#colorTotem","title":"module.rgb.colorTotem()","text":""},{"location":"modules/11/#color-rgb","title":"module.rgb.color(<code>red</code>, <code>green</code>, <code>blue</code>)","text":"<p>Set LED color with automatic RGB or HEX parameter. More convenient to use compared to ones with explicit format. Alpha value in <code>hex</code> is ignored. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0x000000</code>:<code>0xFFFFFF</code>]  </p> <p>Turn all LED on to last used color.  </p> <p>Turn all LED off.  </p> <p>Set all LED to specific state (on / off). Parameter: <code>state</code> - state on / off [<code>HIGH</code>:<code>LOW</code>] or [<code>true</code>:<code>false</code>]  </p> <p>Toggle all LED between on / off states.  </p> <p>Check if any of RGB light is on. Returns: <code>state</code> - is any LED on [<code>true</code>:<code>false</code>] or [<code>HIGH</code>:<code>LOW</code>].  </p> <p>Disable multiplexing if all LED is set to the same color. This results in much more brightness. This mode is required to be enabled each time module is powered up. This is disabled by default to match brightness when using <code>color</code>, <code>colorX</code> commands. Parameter: <code>state</code> - bright mode is on [<code>true</code>:<code>false</code>]. Default: <code>false</code> </p>"},{"location":"modules/11/#color-hex","title":"module.rgb.color(<code>hex</code>)","text":""},{"location":"modules/11/#on","title":"module.rgb.on()","text":""},{"location":"modules/11/#off","title":"module.rgb.off()","text":""},{"location":"modules/11/#set","title":"module.rgb.set(<code>state</code>)","text":""},{"location":"modules/11/#toggle","title":"module.rgb.toggle()","text":""},{"location":"modules/11/#isOn","title":"<code>state</code> module.rgb.isOn()","text":""},{"location":"modules/11/#setBrightMode","title":"module.rgb.setBrightMode(<code>state</code>)","text":""},{"location":"modules/11/#single-rgb-light-control","title":"Single RGB light control","text":"<p>Individual LED can be accessed by specifying index: <code>module.rgb[0].on()</code>. LED from 1 to 8 is identified as indexes <code>0</code>-<code>7</code>. Accessing \"without index\" will affect all LED.</p>"},{"location":"modules/11/#low-level-commands","title":"Low level commands","text":"<p>These are low level TotemBUS commands accepted by module. Is not required when using objective API described above.</p> Command list Command Parameters Description <code>distance</code> Returns:(<code>int</code>) Get distance to object in mm <code>rgbAll/totem</code> None Set LED to Totem colors <code>rgbAll/bright</code> (<code>bool</code>) Enable bright LED mode <code>rgbAll</code> (<code>byte</code>, <code>byte</code>, <code>byte</code>) Set all LED color <code>rgbX</code> (<code>byte</code>, <code>byte</code>, <code>byte</code>, <code>byte</code>) Set specific LED color"},{"location":"modules/14/","title":"[14] Line follower module","text":""},{"location":"modules/14/#description","title":"Description","text":"<p>White and black line detector for following some path on the floor. It reports line offset underneath the sensor which is used to steer a robot in the correct direction.</p> <p>Features: </p> <ul> <li>White/Black line position detection  </li> <li>Junction detection  </li> <li>Automatic line color detection  </li> <li>Automatic contrast calibration  </li> </ul> <p></p>"},{"location":"modules/14/#code-examples","title":"Code examples","text":"<p>Arduino projects: 14_lineFollower</p> <pre><code>#include &lt;TotemModule14.h&gt;\nTotemModule14 module;\n</code></pre> Function usage (click to expand) <pre><code>/* Reading sensor data */\n// Get line position \"3\"\nint pos = module.getPos();\n// Get line color 'W'\nchar color = module.getColor();\n// Check if color is white \"true\"\nbool isWhite = module.isWhite();\n// Check if color is black \"false\"\nbool isBlack = module.isBlack();\n// Check if color (line) is detected \"true\"\nbool isColor = module.isDetected();\n// Check if junction is detected \"false\"\nbool isJunction = module.isJunction();\n// Get current detection accuracy \"50\"\nint accuracy = module.getAccuracy();\n// Set new detection threshold\nmodule.setThreshold(20);\n// Get raw sensor reading\nuint8_t *contrast = NULL;\nmodule.getRaw(contrast);\n// contrast contains array: {21,30,65,70,70,68,36,20}\nint sensorA = contrast[0]; // 21\nint sensorD = contrast[3]; // 70\nint sensorH = contrast[7]; // 20\n</code></pre> <pre><code>/* All LED control */\n// Turn all LED on\nmodule.led.on();\n// Turn all LED off\nmodule.led.off();\n// Set all LED on\nmodule.led.set(HIGH);\n// Toggle all LED on / off\nmodule.led.toggle();\n// Is any of LED on \"true\"\nbool isAllOn = module.led.isOn();\n// Set LEDs : on|off|off|on|on|off|off|on\nmodule.led.setBinary(B10011001);\n// Reset LEDs to default behavior\nmodule.led.reset();\n</code></pre> <pre><code>/* Single LED control */\n// Turn LED A on\nmodule.led[0].on();\n// Turn LED D off\nmodule.led[3].off();\n// Toggle LED B on / off\nmodule.led[1].toggle();\n// Set LED A off\nmodule.led[0].set(LOW);\n// Check if LED A is on \"false\"\nbool isAOn = module.led[0].isOn();\n</code></pre>"},{"location":"modules/14/#functions","title":"Functions","text":""},{"location":"modules/14/#reading-sensor-data","title":"Reading sensor data","text":"<p>Line position below sensor. (negative, 0, positive) = (left, center, right). Returns: <code>position</code> - line position [<code>-35</code>:<code>35</code>]. <code>0</code> - center  </p> <p>Get currently detected line color. This can be White or Black. Color is returned in ASCII character. Use <code>'W'</code>, <code>'B'</code> expression. Returns: <code>color</code> -  line color (char) [<code>'W'</code> - white, <code>'B'</code> - black]. <code>0</code> - not detected.</p> <p>Returns 8 byte array of contrast reading from each sensor. <code>0</code>% - light does not reflect (black), <code>100</code>% - light does reflect (white). Array index 0 corresponds to sensor A, 1 - B, ..., 7 - H. Data is returned trough <code>data</code> array parameter. Returns: <code>data[8]</code> -  8 byte array of each sensor contrast [<code>0</code>:<code>100</code>]%  </p> <p>Check if white line is detected. Returns: <code>state</code> -  white line detected [<code>true</code>:<code>false</code>]  </p> <p>Check if black line is detected. Returns: <code>state</code> -  black line detected [<code>true</code>:<code>false</code>]  </p> <p>Check if line color is detected. Returns: <code>state</code> -  line detected [<code>true</code>:<code>false</code>]  </p> <p>Check if sensor is currently detecting line junction (cross). A horizontal lines in its follow path. This is used for invoking some kind of action or to change direction (turn robot left or right) NOTE: This will also return <code>true</code> if line is not detected at all. Returns: <code>state</code> -  junction detected [<code>true</code>:<code>false</code>]  </p> <p>Percentage of current contrast difference between line and ground (maximum values). Higher value means better detection accuracy. If value is lower than <code>setThreshold()</code>, sensor won't be able to work properly. In this case lower <code>setThreshold()</code> value or improve surface contrast. Returns: <code>contrast</code> -  contrast difference [<code>0</code>:<code>100</code>]%  </p> <p>Minimum contrast difference between line and ground required to start detection. Lower value means more sensitivity when detecting line, but more susceptible to noise and misreadings. Should be changed only when there is an issue with detection on particular surface. Parameter: <code>contrast</code> -  detection start contrast [<code>10</code>:<code>80</code>]%. Default: <code>20</code> </p> <p>Set line color to improve accuracy. This can be White or Black. Parameter: <code>color</code> -  line color (char) [<code>'W'</code> - white, <code>'B'</code> - black]. <code>0</code> - auto.</p>"},{"location":"modules/14/#getPos","title":"<code>position</code> module.getPos()","text":""},{"location":"modules/14/#getColor","title":"<code>color</code> module.getColor()","text":""},{"location":"modules/14/#getRaw","title":"module.getRaw(<code>data[8]</code> )","text":""},{"location":"modules/14/#isWhite","title":"<code>state</code> module.isWhite()","text":""},{"location":"modules/14/#isBlack","title":"<code>state</code> module.isBlack()","text":""},{"location":"modules/14/#isDetected","title":"<code>state</code> module.isDetected()","text":""},{"location":"modules/14/#isJunction","title":"<code>state</code> module.isJunction()","text":""},{"location":"modules/14/#getAccuracy","title":"<code>contrast</code> module.getAccuracy()","text":""},{"location":"modules/14/#setThreshold","title":"module.setThreshold(<code>contrast</code>)","text":""},{"location":"modules/14/#setColor","title":"module.setColor(<code>color</code>)","text":""},{"location":"modules/14/#all-led-control","title":"All LED control","text":"<p>Turn all LED on.  </p> <p>Turn all LED off.  </p> <p>Set all LED to specific state (on / off). Parameter: <code>state</code> - state on / off [<code>HIGH</code>:<code>LOW</code>] or [<code>true</code>:<code>false</code>]  </p> <p>Toggle all LED between on / off states.  </p> <p>Check if any of LED is on. Returns: <code>state</code> - is any LED on [<code>true</code>:<code>false</code>] or [<code>HIGH</code>:<code>LOW</code>].  </p> <p>Set all LED state with single value mask. Each bit in 8-bit value represents individual LED state. 1 - on, 0 - off. Parameter: <code>state</code> - binary mask [<code>B00000000</code>:<code>B11111111</code>].  </p> <p>Re-enable default behavior of LED. It is switched off when any of LED function is used.  </p>"},{"location":"modules/14/#led.on","title":"module.led.on()","text":""},{"location":"modules/14/#led.off","title":"module.led.off()","text":""},{"location":"modules/14/#led.set","title":"module.led.set(<code>state</code>)","text":""},{"location":"modules/14/#led.toggle","title":"module.led.toggle()","text":""},{"location":"modules/14/#led.isOn","title":"<code>state</code> module.led.isOn()","text":""},{"location":"modules/14/#led.setBinary","title":"module.led.setBinary(<code>mask</code>)","text":""},{"location":"modules/14/#led.reset","title":"module.led.reset()","text":""},{"location":"modules/14/#single-led-control","title":"Single LED control","text":"<p>Control specific LED by providing its number. 0 - A, 1 - B, ..., 7 - H.  </p> <p>Individual LED can be accessed by specifying index: <code>module.rgb[0].on()</code>. LED from A to H is identified as indexes <code>0</code>-<code>7</code>. Accessing \"without index\" will affect all LED.</p>"},{"location":"modules/14/#low-level-commands","title":"Low level commands","text":"<p>These are low level TotemBUS commands accepted by module. Is not required when using objective API described above.</p> Command list Command Parameters Description <code>sensor/threshold</code> (<code>int</code>) Sensor threshold <code>sensor/range</code> Returns:(<code>int</code>) Accuracy <code>sensor/raw</code> Returns:(<code>byte[8]</code>) Raw each sensor contrast <code>line/junction</code> Returns:(<code>bool</code>) Is junction detected <code>line/color</code> Returns:(<code>char</code>) Detected line color <code>line/pos</code> Returns:(<code>int</code>) Detected line position <code>led</code> (<code>byte</code>) Write 8-bit mask of each LED on/off"},{"location":"modules/15/","title":"[15] Potentiometer module","text":""},{"location":"modules/15/#description","title":"Description","text":"<p>Module designed to provide input for robotic application. 3 analog knobs and 3 buttons allow to execute specific actions or adjust parameters. Can be used for motor speed, PID adjusting, servo position, RGB color and anything other.</p> <p>Features: </p> <ul> <li>3 analog knobs  </li> <li>3 buttons  </li> <li>3 individual brightness leds  </li> </ul> <p></p>"},{"location":"modules/15/#code-examples","title":"Code examples","text":"<p>Arduino projects: 15_potentiometer</p> <pre><code>#include &lt;TotemModule15.h&gt;\nTotemModule15 module;\n</code></pre> Function usage (click to expand) <pre><code>/* Knob control */\n// Read knob A value \"128\"\nint knobA = module.getKnobA();\n// Change knob resolution to 12 bits\nmodule.setKnobBits(12);\n// Read knob B value \"2048\"\nint knobB = module.getKnobB();\n// Read knob C value \"0\"\nint knobC = module.getKnobC();\n</code></pre> <pre><code>/* Button */\n// Check if button A is pressed\nbool isInA = module.getButtonA();\n// Check if button B is pressed or released\nbool isInB = module.getButtonB();\n// Check if button C is pressed or released\nbool isInC = module.getButtonC();\n</code></pre> <pre><code>/* All LED control */\n// Turn all LED on\nmodule.led.on();\n// Turn all LED off\nmodule.led.off();\n// Set all LED to on\nmodule.led.set(HIGH);\n// Toggle all LED state on / off\nmodule.led.toggle();\n// Check if any LED is on\nbool isOn = module.led.isOn();\n// Set all LED brightness to 50%\nmodule.led.setAlpha(128);\n// Set all LED state to: A:on, B:off, C:on\nmodule.led.setBinary(B101);\n// Reset all LED to default behavior\nmodule.led.reset();\n</code></pre> <pre><code>/* Single LED control */\n// Set LED A on\nmodule.led[0].on();\n// Set LED B off\nmodule.led[1].off();\n// Set LED C to off\nmodule.led[2].set(LOW);\n// Toggle LED A state on / off\nmodule.led[0].toggle();\n// Check if LED B is on \"false\"\nbool isOn = module.led[1].isOn();\n// Set LED C brightness to 100%\nmodule.led[2].setAlpha(255);\n</code></pre>"},{"location":"modules/15/#functions","title":"Functions","text":""},{"location":"modules/15/#knob-control","title":"Knob control","text":""},{"location":"modules/15/#getKnobA","title":"<code>position</code> module.getKnobA()","text":""},{"location":"modules/15/#getKnobB","title":"<code>position</code> module.getKnobB()","text":"<p>Get knob position. (0, 128, 255) = (left, center, right). Returned value range depends on <code>setKnobBits()</code> (resolution) setting. Returns: <code>position</code> - knob position [<code>0</code>:<code>255</code>]  </p> <p>Set knob resolution. <code>knobX.get()</code> will return value according to this parameter. Allowed values: <code>6</code> - [0:64] <code>8</code> - [0:256] (default) <code>10</code> - [0:1024] <code>12</code> - [0:4096] Parameter: <code>resolution</code> - knob analog resolution in bits. [<code>6</code>,<code>8</code>,<code>10</code>,<code>12</code>], Default: <code>8</code> </p>"},{"location":"modules/15/#getKnobC","title":"<code>position</code> module.getKnobC()","text":""},{"location":"modules/15/#setKnobBits","title":"module.setKnobBits(<code>resolution</code>)","text":""},{"location":"modules/15/#button","title":"Button","text":""},{"location":"modules/15/#getButtonA","title":"<code>state</code> module.getButtonA()","text":""},{"location":"modules/15/#getButtonB","title":"<code>state</code> module.getButtonB()","text":"<p>Check if button is pressed. Returns: <code>status</code> - yes / no [<code>true</code>:<code>false</code>]  </p>"},{"location":"modules/15/#getButtonC","title":"<code>state</code> module.getButtonC()","text":""},{"location":"modules/15/#all-led-control","title":"All LED control","text":"<p>Turn all LED on.  </p> <p>Turn all LED off.  </p> <p>Set all LED to specific state (on / off). Parameter: <code>state</code> - state on / off [<code>HIGH</code>:<code>LOW</code>] or [<code>true</code>:<code>false</code>]  </p> <p>Toggle all LED between on / off states.  </p> <p>Check if any of LED is on. Returns: <code>state</code> - is any LED on [<code>true</code>:<code>false</code>] or [<code>HIGH</code>:<code>LOW</code>].  </p> <p>Set all LED brightness. Parameter: <code>alpha</code> - brightness [<code>0</code>:<code>255</code>].  </p> <p>Set all LED state with single value mask. Each bit represents individual LED state. B100 - A, B010 - B, B001 - C. Parameter: <code>state</code> - binary mask [<code>B000</code>:<code>B111</code>].  </p> <p>Re-enable default behavior of LED. It is switched off when any of LED function is used.  </p>"},{"location":"modules/15/#led.on","title":"module.led.on()","text":""},{"location":"modules/15/#led.off","title":"module.led.off()","text":""},{"location":"modules/15/#led.set","title":"module.led.set(<code>state</code>)","text":""},{"location":"modules/15/#led.toggle","title":"module.led.toggle()","text":""},{"location":"modules/15/#led.isOn","title":"<code>state</code> module.led.isOn()","text":""},{"location":"modules/15/#led.setAlpha","title":"module.led.setAlpha(<code>alpha</code>)","text":""},{"location":"modules/15/#led.setBinary","title":"module.led.setBinary(<code>mask</code>)","text":""},{"location":"modules/15/#led.reset","title":"module.led.reset()","text":""},{"location":"modules/15/#single-led-control","title":"Single LED control","text":"<p>Control specific LED by providing its number. 0 - A, 1 - B, 2 - C.  </p> <p>Individual LED can be accessed by specifying index: <code>module.rgb[0].on()</code>. LED from A to C is identified as indexes <code>0</code>-<code>2</code>. Accessing \"without index\" will affect all LED.</p>"},{"location":"modules/15/#low-level-commands","title":"Low level commands","text":"<p>These are low level TotemBUS commands accepted by module. Is not required when using objective API described above.</p> Command list Command Parameters Description <code>knobA</code> Returns:(<code>int</code>) Knob A position <code>knobB</code> Returns:(<code>int</code>) Knob B position <code>knobC</code> Returns:(<code>int</code>) Knob C position <code>knobAll/bits</code> (<code>int</code>) Set knob resolution in bits <code>ledAll/reset</code> None Reset LED to default behavior <code>ledAll</code> (<code>int</code>) Set all LED brightness (%) <code>ledA</code> (<code>int</code>) Set LED A brightness (%) <code>ledB</code> (<code>int</code>) Set LED B brightness (%) <code>ledC</code> (<code>int</code>) Set LED C brightness (%) <code>buttonA</code> Returns:(<code>bool</code>) Is button A pressed <code>buttonB</code> Returns:(<code>bool</code>) Is button B pressed <code>buttonC</code> Returns:(<code>bool</code>) Is button C pressed"},{"location":"modules/22/","title":"[22] Environment sensor","text":""},{"location":"modules/22/#description","title":"Description","text":"<p>Module with multiple integrated sensors for measuring environment conditions. It contains light, humidity and barometer sensors, allowing to monitor a variety of parameters.  </p> <p>Features: </p> <p>Detection of:  </p> <ul> <li>Luminosity  </li> <li>Infrared  </li> <li>Color (RGB)  </li> <li>Air temperature (internal &amp; external NTC)  </li> <li>Air humidity  </li> <li>Atmospheric pressure  </li> <li>Altitude  </li> </ul> <p></p>"},{"location":"modules/22/#code-examples","title":"Code examples","text":"<p>Arduino projects: 22_sensor</p> <pre><code>#include &lt;TotemModule22.h&gt;\nTotemModule22 module;\n</code></pre> Function usage (click to expand) <p><pre><code>/* Light */\n// Get  amount of red color \"1561\"\nint colorR = module.getColorR();\n// Get  amount of green color \"156581\"\nint colorG = module.getColorG();\n// Get  amount of green color \"215017\"\nint colorB = module.getColorB();\n// Get amount of infrared light\nint getIR = module.getIR();\n// Get luminosity\nint getLumen = module.getLumen();\n// Set light sensor gain\nmodule.setLightSensorGain(18);\n</code></pre> <pre><code>/* Temperature */\n// Get air temperature Celsius\nfloat tempC = module.getTempC();\n// Get air temperature Fahrenheit \nfloat tempF = module.getTempF();\n// Get air temperature Kelvin\nfloat tempK = module.getTempK();\n</code></pre> <pre><code>/* NTC temperature */\n// Get NTC sensor air temperature Celsius\nfloat ntcTempC = module.getNtcC();\n// Get NTC sensor air temperature Fahrenheit\nfloat ntcTempF = module.getNtcF();\n// Get NTC sensor air temperature Kelvin\nfloat ntcTempK = module.getNtcK();\n// Get NTC sensor resistance\nint ntcR = module.getNtcResistance();\n</code></pre> <pre><code>/* Humidity */\n// Get air humidity\nint humidity = module.getHumidity();\n</code></pre> <pre><code>/* Pressure */\n// Get air pressure Pascal\nfloat pressurePa = module.getPressurePa();\n// Get air pressure Hectopascal\nfloat pressurehPa = module.getPressurehPa();\n// Get air pressure Millibar\nfloat pressureMbar = module.getPressureMbar();\n// Get air pressure Bar\nfloat pressureBar = module.getPressureBar();\n// Get air pressure Pound per Square Inch\nfloat pressurePsi = module.getPressurePsi();\n</code></pre> <pre><code>/* Altitude */\n// Get altitude Meters\nfloat altitudeM = module.getAltitudeMeter();\n// Get altitude Foot\nfloat altitudeFt = module.getAltitudeFoot();\n// Get altitude Inches\nfloat altitudeInch = module.getAltitudeInch();\n// Set sea level air pressure\nmodule.setAltitudeSeaLevel(101325);\n</code></pre> <pre><code>/* LED control */\n// Turn LED on\nmodule.led.on();\n// Turn LED off\nmodule.led.off();\n// Set LED to on\nmodule.led.set(HIGH);\n// Toggle LED state on / off\nmodule.led.toggle();\n// Check if LED is on\nbool isOn = module.led.isOn();\n</code></pre></p>"},{"location":"modules/22/#functions","title":"Functions","text":""},{"location":"modules/22/#light","title":"Light","text":"<p>Light sensor is able to read amount of detected light and its color saturation. If you trying to get precise measurements, turn of on-board red LED which may induce some red shade into sensor. Use function <code>module.led.off()</code> for that.  </p>"},{"location":"modules/22/#getColorR","title":"<code>saturation</code> module.getColorR()","text":""},{"location":"modules/22/#getColorG","title":"<code>saturation</code> module.getColorG()","text":"<p>Get precise amount of specified color. Higher value means more color in light is detected. Returns: <code>saturation</code> - 18-bit amount of red color [<code>0</code>:<code>262143</code>]  </p> <p>Get precise amount of infrared light hitting the sensor. Returns: <code>saturation</code> - 18-bit amount of infrared light [<code>0</code>:<code>262143</code>]  </p> <p>Get precise amount of light (luminosity) hitting the sensor. Returns: <code>saturation</code> - 18-bit amount of light [<code>0</code>:<code>262143</code>]  </p> <p>Set light sensor gain. Parameter: <code>gain</code> - gain value [<code>1</code>,<code>3</code>,<code>6</code>,<code>9</code>,<code>18</code>]. Default: <code>18</code> </p>"},{"location":"modules/22/#getColorB","title":"<code>saturation</code> module.getColorB()","text":""},{"location":"modules/22/#getIR","title":"<code>saturation</code> module.getIR()","text":""},{"location":"modules/22/#getLumen","title":"<code>saturation</code> module.getLumen()","text":""},{"location":"modules/22/#setLightSensorGain","title":"module.setLightSensorGain(<code>gain</code>)","text":""},{"location":"modules/22/#temperature","title":"Temperature","text":""},{"location":"modules/22/#getTempC","title":"<code>temperatureC</code> module.getTempC()","text":""},{"location":"modules/22/#getTempF","title":"<code>temperatureF</code> module.getTempF()","text":"<p>Get air temperature. Multiple units available. Returns: <code>temperatureC</code> - Celsius (float) (<code>24.75</code>)C <code>temperatureF</code> - Fahrenheit (float) (<code>76.55</code>)F <code>temperatureK</code> - Kelvin (float) (<code>297.9</code>)K  </p>"},{"location":"modules/22/#getTempK","title":"<code>temperatureK</code> module.getTempK()","text":""},{"location":"modules/22/#ntc-temperature","title":"NTC temperature","text":"<p>Module supports external Thermistor. It should be soldered or connected to NTC pins. Once connected, module will start measurements automatically.</p>"},{"location":"modules/22/#getNtcC","title":"<code>temperatureC</code> module.getNtcC()","text":""},{"location":"modules/22/#getNtcF","title":"<code>temperatureF</code> module.getNtcF()","text":"<p>Get NTC sensor temperature. Multiple units available. Returns: <code>temperatureC</code> - Celsius (float) (<code>24.75</code>)C <code>temperatureF</code> - Fahrenheit (float) (<code>76.55</code>)F <code>temperatureK</code> - Kelvin (float) (<code>297.9</code>)K  </p> <p>Get NTC sensor resistance in (Ohms). Module use it to compute air temperature. Returns: <code>resistance</code> - thermistor resistance in Ohms. <code>0</code> - not connected  </p>"},{"location":"modules/22/#getNtcK","title":"<code>temperatureK</code> module.getNtcK()","text":""},{"location":"modules/22/#getNtcResistance","title":"<code>resistance</code> module.getNtcResistance()","text":""},{"location":"modules/22/#humidity","title":"Humidity","text":"<p>Get percentage of air humidity. Returns: <code>humidity</code> - humidity [<code>0</code>:<code>100</code>]%  </p>"},{"location":"modules/22/#getHumidity","title":"<code>humidity</code> module.getHumidity()","text":""},{"location":"modules/22/#pressure","title":"Pressure","text":""},{"location":"modules/22/#getPressurePa","title":"<code>pressurePa</code> module.getPressurePa()","text":""},{"location":"modules/22/#getPressurehPa","title":"<code>pressurehPa</code> module.getPressurehPa()","text":""},{"location":"modules/22/#getPressureMbar","title":"<code>pressureMbar</code> module.getPressureMbar()","text":""},{"location":"modules/22/#getPressureBar","title":"<code>pressureBar</code> module.getPressureBar()","text":"<p>Get atmospheric air pressure. Multiple units available. Returns: <code>pressurePa</code> - Pascal (float) (<code>90000</code>)Pa <code>pressurehPa</code> - Hectopascal (float) (<code>900</code>)hPa <code>pressureMbar</code> - Millibar (float) (<code>900</code>)mbar <code>pressureBar</code> - Bar (float) (<code>0.9</code>)bar <code>pressurePsi</code> - Pound per Square Inch (float) (<code>13.05</code>)psi  </p>"},{"location":"modules/22/#getPressurePsi","title":"<code>pressurePsi</code> module.getPressurePsi()","text":""},{"location":"modules/22/#altitude","title":"Altitude","text":"<p>Altitude calculation (altimeter) works by comparing current air pressure to a reference point (sea level). Sea level air pressure vary between locations and weather. For precise measurements - set it with function <code>setSeaLevel()</code>. Default setting is <code>101325</code> Pascals (1013.25 mbar). </p>"},{"location":"modules/22/#getAltitudeMeter","title":"<code>altitudeM</code> module.getAltitudeMeter()","text":""},{"location":"modules/22/#getAltitudeFoot","title":"<code>altitudeFt</code> module.getAltitudeFoot()","text":"<p>Get sensor altitude above sea level. Multiple units available. Returns: <code>altitudeM</code> - Meters (float) (<code>100</code>)m <code>altitudeFt</code> - Foot (float) (<code>328.084</code>)ft <code>altitudeInch</code> - Inches (float) (<code>3937.01</code>)inch  </p> <p>Set air pressure at sea level for altitude calculation. Parameter: <code>pressure</code> - pressure at sea level in Pascal units. Default: <code>101325</code>Pa  </p>"},{"location":"modules/22/#getAltitudeInch","title":"<code>altitudeInch</code> module.getAltitudeInch()","text":""},{"location":"modules/22/#setAltitudeSeaLevel","title":"module.setAltitudeSeaLevel(<code>pressure</code>)","text":""},{"location":"modules/22/#led-control","title":"LED control","text":"<p>Turn LED on.  </p> <p>Turn LED off.  </p> <p>Set LED to specific state (on / off). Parameter: <code>state</code> - state on / off [<code>HIGH</code>:<code>LOW</code>] or [<code>true</code>:<code>false</code>]  </p> <p>Toggle LED between on / off states. </p> <p>Check if LED is on. Returns: <code>state</code> - LED is on [<code>true</code>:<code>false</code>] or [<code>HIGH</code>:<code>LOW</code>].  </p>"},{"location":"modules/22/#led.on","title":"module.led.on()","text":""},{"location":"modules/22/#led.off","title":"module.led.off()","text":""},{"location":"modules/22/#led.set","title":"module.led.set(<code>state</code>)","text":""},{"location":"modules/22/#led.toggle","title":"module.led.toggle()","text":""},{"location":"modules/22/#led.isOn","title":"<code>state</code> module.led.isOn()","text":""},{"location":"modules/22/#low-level-commands","title":"Low level commands","text":"<p>These are low level TotemBUS commands accepted by module. Is not required when using objective API described above.</p> Command list Command Parameters Description <code>color</code> Returns:(<code>int</code>) Get RGB HEX color <code>color/R</code> Returns:(<code>int</code>) Get precise red color <code>color/G</code> Returns:(<code>int</code>) Get precise blue color <code>color/B</code> Returns:(<code>int</code>) Get precise green color <code>light/IR</code> Returns:(<code>int</code>) Get infrared amount <code>light/lumen</code> Returns:(<code>int</code>) Get lumen amount <code>light/gain</code> (<code>byte</code>) Set sensor gain <code>nfc</code> Returns:(<code>int</code>) Get external NTC temperature Celsius <code>nfc/C</code> Returns:(<code>int</code>) Get external NTC temperature Celsius <code>nfc/F</code> Returns:(<code>int</code>) Get external NTC temperature Fahrenheit <code>nfc/K</code> Returns:(<code>int</code>) Get external NTC temperature Kelvin <code>nfc/R</code> Returns:(<code>int</code>) Get external NTC resistance (Ohms) <code>temperature</code> Returns:(<code>int</code>) Get temperature Celsius <code>temperature/C</code> Returns:(<code>int</code>) Get temperature Celsius <code>temperature/F</code> Returns:(<code>int</code>) Get temperature Fahrenheit <code>temperature/K</code> Returns:(<code>int</code>) Get temperature Kelvin <code>humidity</code> Returns:(<code>int</code>) Get humidity (%) <code>pressure</code> Returns:(<code>int</code>) Get pressure Millibar <code>pressure/mbar</code> Returns:(<code>int</code>) Get pressure Millibar <code>pressure/Pa</code> Returns:(<code>int</code>) Get pressure Pascal <code>pressure/hPa</code> Returns:(<code>int</code>) Get pressure Hectopascal <code>pressure/psi</code> Returns:(<code>int</code>) Get pressure Pound per square inch <code>altitude</code> Returns:(<code>int</code>) Get altitude meters <code>altitude/m</code> Returns:(<code>int</code>) Get altitude meters <code>altitude/ft</code> Returns:(<code>int</code>) Get altitude foot <code>altitude/seaLevel</code> (<code>int</code>) Set sea level pressure (Pascal) <code>led</code> (<code>bool</code>) Set LED on/off"},{"location":"modules/labboard/","title":"LabBoard","text":"<p>Control LabBoard from TotemDuino over Totem Library. To setup serial communication - read Serial setup section. Make sure <code>Serial.begin(57600)</code> speed matches with the one selected in LabBoard.  </p> <p>Example code executed on TotemDuino: <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  LB.led.on(); // Turn all LabBoard LED on\n  delay(1000); // Wait 1s\n  LB.led.off(); // Turn all LabBoard LED off\n  delay(1000); // Wait 1s\n}\n</code></pre></p>"},{"location":"modules/labboard/#voltage-read-adc","title":"Voltage read (ADC)","text":"<p>Read voltage of LabBoard analog inputs.</p> <p>Read VIN pin voltage. Returns: (float) <code>6.0</code> - <code>30.0</code> V | <code>-100.0</code> - invalid.</p> <p>Read \u00b150V pin voltage. Returns: (float) <code>-50.0</code> - <code>50.0</code> V | <code>-100.0</code> - invalid.</p> <p>Read \u00b15V pin voltage. Returns: (float) <code>-6.15</code> - <code>6.15</code> V | <code>-100.0</code> - invalid.</p> <p>Read \u00b10.5V pin voltage. Returns: (float) <code>-0.7</code> - <code>0.7</code> V | <code>-100.0</code> - invalid.</p> <p>Read SHUNT pin current. Returns: (float) <code>0.0</code> - <code>0.8</code> A | <code>-100.0</code> - invalid.</p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n  LB.display.setMonitor(0); // Don't print \"Serial.print\" to LabBoard display.\n  LB.display.clear(); // Clear LabBoard display.\n}\nvoid loop() {\n  // Read LabBoard voltages\n  float v05 = LB.volt.get05V();\n  float v5 = LB.volt.get5V();\n  float v50 = LB.volt.get50V();\n  float vin = LB.volt.getVIN();\n  // Print voltages to Arduino IDE Serial Monitor\n  Serial.print(\"Pin 0.5V : \");\n  Serial.println(v05);\n  Serial.print(\"Pin 5V : \");\n  Serial.println(v5);\n  Serial.print(\"Pin 50V : \");\n  Serial.println(v50);\n  Serial.print(\"Pin VIN : \");\n  Serial.println(vin);\n  delay(300);\n}\n</code></pre>"},{"location":"modules/labboard/#volt.getVIN","title":"LB.volt.getVIN()","text":""},{"location":"modules/labboard/#volt.get50V","title":"LB.volt.get50V()","text":""},{"location":"modules/labboard/#volt.get5V","title":"LB.volt.get5V()","text":""},{"location":"modules/labboard/#volt.get05V","title":"LB.volt.get05V()","text":""},{"location":"modules/labboard/#volt.getAmp","title":"LB.volt.getAmp()","text":""},{"location":"modules/labboard/#voltage-write-dac","title":"Voltage write (DAC)","text":"<p>Write voltage to LabBoard analog outputs.</p> <p>Write VREG pin voltage. Maximum output voltage depends on VIN voltage. <code>voltage</code>: (float) <code>3.0</code> - <code>VIN - 1.0</code> V.</p> <p>Write DAC1 pin voltage. <code>voltage</code>: (float) <code>0.0</code> - <code>3.25</code> V.</p> <p>Write DAC2 pin voltage. <code>voltage</code>: (float) <code>0.0</code> - <code>3.25</code> V.</p> <p>Write DAC3 pin voltage. <code>voltage</code>: (float) <code>0.0</code> - <code>3.25</code> V.</p> <p>Read VREG pin voltage. Returns: (float) <code>3.0</code> - <code>VIN - 1.0</code> V.</p> <p>Read DAC1 pin voltage. Returns: (float) <code>0.0</code> - <code>3.25</code> V.</p> <p>Read DAC2 pin voltage. Returns: (float) <code>0.0</code> - <code>3.25</code> V.</p> <p>Read DAC3 pin voltage. Returns: (float) <code>0.0</code> - <code>3.25</code> V.</p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  LB.volt.setDAC1(0.5); // Set DAC1 to 0.5V\n  LB.volt.setDAC2(1.0); // Set DAC2 to 1.0V\n  LB.volt.setDAC3(1.5); // Set DAC3 to 1.5V\n  delay(2000); // Wait 2s\n  LB.volt.setDAC1(1.5); // Set DAC1 to 1.5V\n  LB.volt.setDAC2(2.0); // Set DAC2 to 2.0V\n  LB.volt.setDAC3(2.5); // Set DAC3 to 2.5V\n  delay(2000); // Wait 2s\n}\n</code></pre>"},{"location":"modules/labboard/#volt.setVREG","title":"LB.volt.setVREG(<code>voltage</code>)","text":""},{"location":"modules/labboard/#volt.setDAC1","title":"LB.volt.setDAC1(<code>voltage</code>)","text":""},{"location":"modules/labboard/#volt.setDAC2","title":"LB.volt.setDAC2(<code>voltage</code>)","text":""},{"location":"modules/labboard/#volt.setDAC3","title":"LB.volt.setDAC3(<code>voltage</code>)","text":""},{"location":"modules/labboard/#volt.getVREG","title":"LB.volt.getVREG()","text":""},{"location":"modules/labboard/#volt.getDAC1","title":"LB.volt.getDAC1()","text":""},{"location":"modules/labboard/#volt.getDAC2","title":"LB.volt.getDAC2()","text":""},{"location":"modules/labboard/#volt.getDAC3","title":"LB.volt.getDAC3()","text":""},{"location":"modules/labboard/#frequency-generator","title":"Frequency generator","text":"<p>Control LabBoard frequency generator on TXD pin.</p> <p></p> <p>Stop signal generator on TXD pin.  </p> <p>Start signal generator on TXD pin.  </p> <p>Start signal generator on TXD pin and stop after number of pulses elapsed.   Configured with with <code>setBurstCount(count)</code>.  </p> <p>Write amount of pulses to output during burst mode.   Generator will stop when configured number is reached. <code>count</code>: <code>0</code> - <code>65535</code>.  </p> <p>Write output signal frequency in hertz. <code>frequency</code>: <code>1</code> - <code>1000000</code> Hz  </p> <p>Write output signal duty cycle in percentage. <code>0.1</code> precision. <code>percentage</code>: (float) <code>0.0</code> - <code>100.0</code> %</p> <p>Write output signal frequency (period) in microseconds. <code>period</code>: <code>1</code> - <code>1000000</code> \u03bcs  </p> <p>Write output signal duty cycle (pulse width) in microseconds. Value can't be larger than period! <code>pulse</code>: <code>0</code> - <code>1000000</code> \u03bcs  </p> <p>Read if generator is running in burst mode.  </p> <p>Read if generator is running.  </p> <p>Read output signal frequency in hertz. Returns: <code>1</code> - <code>1000000</code> Hz  </p> <p>Read output signal duty cycle in percentage. Returns: (float) <code>0.0</code> - <code>100.0</code> %</p> <p>Read output signal frequency (period) in microseconds. Returns: <code>1</code> - <code>1000000</code> \u03bcs  </p> <p>Read output signal duty cycle (pulse width) in microseconds. Returns: <code>0</code> - <code>1000000</code> \u03bcs  </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n  LB.txd.setFrequency(2000); // Set frequency to 2kHz\n  LB.txd.setDutyCycle(20); // Set duty cycle to 20%\n  LB.txd.start(); // Enable signal generator on TXD pin\n}\nvoid loop() {\n  LB.txd.setDutyCycle(20); // Set duty cycle to 20%\n  delay(2000); // Wait 2s\n  LB.txd.setDutyCycle(80); // Set duty cycle to 80%\n  delay(2000); // Wait 2s\n}\n</code></pre>"},{"location":"modules/labboard/#txd.stop","title":"LB.txd.stop()","text":""},{"location":"modules/labboard/#txd.start","title":"LB.txd.start()","text":""},{"location":"modules/labboard/#txd.startBurst","title":"LB.txd.startBurst()","text":""},{"location":"modules/labboard/#txd.setBurstCount","title":"LB.txd.setBurstCount(<code>count</code>)","text":""},{"location":"modules/labboard/#txd.setFrequency","title":"LB.txd.setFrequency(<code>frequency</code>)","text":""},{"location":"modules/labboard/#txd.setDutyCycle","title":"LB.txd.setDutyCycle(<code>percentage</code>)","text":""},{"location":"modules/labboard/#txd.setPeriod","title":"LB.txd.setPeriod(<code>period</code>)","text":""},{"location":"modules/labboard/#txd.setPulseWidth","title":"LB.txd.setPulseWidth(<code>pulse</code>)","text":""},{"location":"modules/labboard/#txd.isBurst","title":"LB.txd.isBurst()","text":""},{"location":"modules/labboard/#txd.isRunning","title":"LB.txd.isRunning()","text":""},{"location":"modules/labboard/#txd.getFrequency","title":"LB.txd.getFrequency()","text":""},{"location":"modules/labboard/#txd.getDutyCycle","title":"LB.txd.getDutyCycle()","text":""},{"location":"modules/labboard/#txd.getPeriod","title":"LB.txd.getPeriod()","text":""},{"location":"modules/labboard/#txd.getPulseWidth","title":"LB.txd.getPulseWidth()","text":""},{"location":"modules/labboard/#frequency-monitor","title":"Frequency monitor","text":"<p>Control LabBoard frequency monitor and counter on DIG1 pin.</p> <p>Stop signal monitor on DIG1 pin.  </p> <p>Start signal monitor on DIG1 pin.  </p> <p>Read input signal frequency in hertz. Returns: <code>0</code> - <code>23000000</code> Hz  </p> <p>Read input signal frequency (period) in microseconds. Returns: <code>0.04</code> - <code>1000000.0</code> \u03bcs  </p> <p>Read number of signal pulses elapsed. Returns: number  </p> <p>Reset pulse counter to 0 (value returned by <code>getCount()</code>).  </p> <p>Write sample (detect) edge. Default: HIGH <code>edge</code>: \u00a0<code>0</code> - LOW edge (falling) <code>1</code> - HIGH edge (rising)  </p> <p>Read sample (detect) edge. Returns: <code>0</code> - LOW edge (falling) <code>1</code> - HIGH edge (rising)  </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n  LB.txd.start(); // Enable signal monitor on DIG1 pin\n}\nvoid loop() {\n  // Read measured frequency on DIG1 pin\n  int frequency = LB.rxd.getFrequency();\n  // Print measured frequency on LabBoard display\n  Serial.println(frequency);\n  delay(500); // Wait 0.5s\n}\n</code></pre>"},{"location":"modules/labboard/#rxd.stop","title":"LB.rxd.stop()","text":""},{"location":"modules/labboard/#rxd.start","title":"LB.rxd.start()","text":""},{"location":"modules/labboard/#rxd.getFrequency","title":"LB.rxd.getFrequency()","text":""},{"location":"modules/labboard/#rxd.getPeriod","title":"LB.rxd.getPeriod()","text":""},{"location":"modules/labboard/#rxd.getCount","title":"LB.rxd.getCount()","text":""},{"location":"modules/labboard/#rxd.resetCount","title":"LB.rxd.resetCount()","text":""},{"location":"modules/labboard/#rxd.setSampleEdge","title":"LB.rxd.setSampleEdge(<code>edge</code>)","text":""},{"location":"modules/labboard/#rxd.getSampleEdge","title":"LB.rxd.getSampleEdge()","text":""},{"location":"modules/labboard/#digital-read","title":"Digital read","text":"<p>Read digital state of LabBoard pins DIG1 and DIG2.</p> <p>Read LabBoard pin DIG1 digital state. Returns: <code>0</code> - LOW | <code>1</code> - HIGH  </p> <p>Read LabBoard pin DIG2 digital state. Returns: <code>0</code> - LOW | <code>1</code> - HIGH  </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  // Read DIG pins state\n  int dig1 = LB.getDIG1();\n  int dig2 = LB.getDIG2();\n  // Print pins state to LabBoard display\n  Serial.print(\"1\");\n  Serial.println(dig1 ? \"HI\" : \"LO\");\n  Serial.print(\"   2\");\n  Serial.println(dig2 ? \"HI\" : \"LO\");\n}\n</code></pre>"},{"location":"modules/labboard/#getDIG1","title":"LB.getDIG1()","text":""},{"location":"modules/labboard/#getDIG2","title":"LB.getDIG2()","text":""},{"location":"modules/labboard/#display-control","title":"Display control","text":"<p>Control LabBoard 7-segment display.  </p> <p>Write value to display. Aligned to right. <code>value</code>: any value or string.  </p> <p>Write value to display. Aligned to left. <code>value</code>: any value or string.  </p> <p>Write value to display. Aligned to left. Allows to set writing start point. <code>offset</code>: number of segments to push from left. <code>value</code>: any value or string.  </p> <p>Clear display (set to empty).  </p> <p>Write whole display blinking rate in milliseconds. <code>rate</code>: <code>0</code> - <code>1000</code> ms | <code>0</code> - stop blink.  </p> <p>Write specific segment blinking rate in milliseconds. <code>segment</code>: <code>1</code> - <code>9</code> number from left. <code>rate</code>: <code>0</code> - <code>1000</code> ms | <code>0</code> - stop blink.  </p> <p>Write binary map of segments group to set blinking rate in milliseconds. <code>map</code>: <code>B000000000</code> - <code>B111111111</code> | <code>0x0</code> - <code>0x1FF</code>. <code>rate</code>: <code>0</code> - <code>1000</code> ms | <code>0</code> - stop blink.  </p> <p>Write display brightness. <code>brightness</code>: <code>0</code> - <code>15</code> </p> <p>Write serial monitor feature state (on / off).   Will print all data from <code>Serial.println()</code> to display. Default: on. <code>state</code>: <code>0</code> - off | <code>1</code> - on  </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nint counter = 0;\nvoid loop() {\n  // Clean display before printing\n  LB.display.clear();\n  counter++; // Increment counter value\n  LB.display.print(0, counter); // Print to first segment\n  counter++;\n  LB.display.print(3, counter); // Print to fourth segment\n  counter++;\n  LB.display.print(6, counter); // Print to seventh segment\n  delay(1000);\n}\n</code></pre>"},{"location":"modules/labboard/#Serial.println","title":"Serial.println(<code>value</code>)","text":""},{"location":"modules/labboard/#display.print","title":"LB.display.print(<code>value</code>)","text":""},{"location":"modules/labboard/#display.print","title":"LB.display.print(<code>offset</code>,<code>value</code>)","text":""},{"location":"modules/labboard/#display.clear","title":"LB.display.clear()","text":""},{"location":"modules/labboard/#display.setBlink","title":"LB.display.setBlink(<code>rate</code>)","text":""},{"location":"modules/labboard/#display.setBlink-seg","title":"LB.display.setBlink(<code>segment</code>,<code>rate</code>)","text":""},{"location":"modules/labboard/#display.setBlinkBinary","title":"LB.display.setBlinkBinary(<code>map</code>,<code>rate</code>)","text":""},{"location":"modules/labboard/#display.setBrightness","title":"LB.display.setBrightness(<code>brightness</code>)","text":""},{"location":"modules/labboard/#display.setMonitor","title":"LB.display.setMonitor(<code>state</code>)","text":""},{"location":"modules/labboard/#led-control","title":"LED control","text":"<p>Control 11 available LabBoard LED. Each one can be individually turned on / off.  </p> LED names Number Name on board Name in code Binary map 0 All LabBoard::LED_ALL <code>B00000000000</code> 1 DIG1 LabBoard::LED_DIG1 <code>B00000000001</code> 2 DIG2 LabBoard::LED_DIG2 <code>B00000000010</code> 3 \u00b150V LabBoard::LED_50V <code>B00000000100</code> 4 \u00b15V LabBoard::LED_5V <code>B00000001000</code> 5 \u00b10.5V LabBoard::LED_05V <code>B00000010000</code> 6 DAC1 LabBoard::LED_DAC1 <code>B00000100000</code> 7 DAC2 LabBoard::LED_DAC2 <code>B00001000000</code> 8 DAC3 LabBoard::LED_DAC3 <code>B00010000000</code> 9 VIN LabBoard::LED_VIN <code>B00100000000</code> 10 VREG LabBoard::LED_VREG <code>B01000000000</code> 11 mAmp LabBoard::LED_mAmp <code>B10000000000</code> <p>Write all LED to turn on.  </p> <p>Write all LED to turn off.  </p> <p>Write specific LED to turn on. <code>number</code>: <code>1</code> - <code>11</code> | <code>0</code> - all LED.  </p> <p>Write specific LED to turn off. <code>number</code>: <code>1</code> - <code>11</code> | <code>0</code> - all LED.  </p> <p>Write specific LED state (on / off). <code>number</code>: <code>1</code> - <code>11</code> | <code>0</code> - all LED. <code>state</code>: <code>0</code> - off | <code>1</code> - on.  </p> <p>Read specific LED state. <code>number</code>: <code>1</code> - <code>11</code> | <code>0</code> - all LED. Returns: <code>0</code> - off | <code>1</code> - on.  </p> <p>Write binary map of turned on LED. <code>map</code>: <code>B00000000000</code> - <code>B11111111111</code> | <code>0x0</code> - <code>0x7FF</code> </p> <p>Read binary map of turned on LED. Returns: <code>B00000000000</code> - <code>B11111111111</code> | <code>0x0</code> - <code>0x7FF</code> </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  LB.led.on(); // Turn all LED on\n  delay(1000); // Wait 1s\n  LB.led.off(LabBoard::LED_DAC2); // Turn DAC2 LED off\n  delay(1000); // Wait 1s\n  LB.led.off(LabBoard::LED_5V); // Turn 5V LED off\n  delay(1000); // Wait 1s\n  LB.led.off(); // Turn all LED off\n  delay(1000); // Wait 1s\n}\n</code></pre>"},{"location":"modules/labboard/#led.on","title":"LB.led.on()","text":""},{"location":"modules/labboard/#led.off","title":"LB.led.off()","text":""},{"location":"modules/labboard/#led.on-number","title":"LB.led.on(<code>number</code>)","text":""},{"location":"modules/labboard/#led.off-number","title":"LB.led.off(<code>number</code>)","text":""},{"location":"modules/labboard/#led.set","title":"LB.led.set(<code>number</code>,<code>state</code>)","text":""},{"location":"modules/labboard/#led.get","title":"LB.led.get(<code>number</code>)","text":""},{"location":"modules/labboard/#led.setBinary","title":"LB.led.setBinary(<code>map</code>)","text":""},{"location":"modules/labboard/#led.getBinary","title":"LB.led.getBinary()","text":""},{"location":"modules/labboard/#key-read","title":"Key read","text":"<p>Read specific key state. Returns: <code>0</code> - not pressed <code>1</code> - is pressed  </p> <p>Read binary map of pressed keys. Returns: <code>B00000</code> - <code>B11111</code> | <code>0x0</code> - <code>0x1F</code> </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  // Get keys state\n  int kLeft = LB.key.get(LabBoard::KEY_LEFT);\n  int kMid = LB.key.get(LabBoard::KEY_MIDDLE);\n  int kRight = LB.key.get(LabBoard::KEY_RIGHT);\n  // Display \"---\" if key is pressed\n  LB.display.clear();\n  LB.display.print(0, kLeft ? \"---\" : \"   \");\n  LB.display.print(3, kMid ? \"---\" : \"   \");\n  LB.display.print(6, kRight ? \"---\" : \"   \");\n  delay(50);\n}\n</code></pre>"},{"location":"modules/labboard/#key.get","title":"LB.key.get(<code>number</code>)","text":""},{"location":"modules/labboard/#key.getBinary","title":"LB.key.getBinary()","text":""},{"location":"modules/labboard/#configuration","title":"Configuration","text":"<p>Control LabBoard stored settings.  </p> Settings list Name Description REV Revision number (readonly) VERS Firmware version (readonly) SBAUD Default serial baud rate SMODE Default serial mode SON Background serial mode DISP Display brightness VREG Calibration offset DAC1 Calibration offset DAC2 Calibration offset DAC3 Calibration offset VIN Calibration offset 50V Calibration offset 5V Calibration offset 05V Calibration offset RST Write <code>1</code> to factory reset <p>For more information read Serial protocol - Configuration.</p> <p>Write configuration (setting) value. <code>name</code>: setting name (<code>\"DISP\"</code>) <code>value</code>: setting value  </p> <p>Read configuration (setting) value. <code>name</code>: setting name (<code>\"DISP\"</code>) Returns: setting value  </p> <pre><code>#include &lt;TotemLabBoard.h&gt;\nTotemLabBoard LB;\nvoid setup() {\n  Serial.begin(57600); // Set baudrate to 57600\n}\nvoid loop() {\n  // Get revision and version\n  int rev = LB.config.get(\"REV\");\n  int vers = LB.config.get(\"VERS\");\n  // Print to display\n  Serial.print(rev);\n  Serial.print(\" \");\n  Serial.println(vers);\n  delay(1000); // Wait 1s\n}\n</code></pre>"},{"location":"modules/labboard/#config.set","title":"LB.config.set(<code>name</code>,<code>value</code>)","text":""},{"location":"modules/labboard/#config.get","title":"LB.config.get(<code>name</code>)","text":""},{"location":"modules/labboard/#power","title":"Power","text":"<p>Control LabBoard power state.  </p> <p>Restart LabBoard into boot mode (for firmware update).  </p> <p>Restart LabBoard  </p>"},{"location":"modules/labboard/#runBoot","title":"LB.runBoot()","text":""},{"location":"modules/labboard/#restart","title":"LB.restart()","text":""},{"location":"modules/mini-control-board/","title":"Mini Control Board","text":"<p>Remote control board with 4 motors, 2 servos and RGB lights. Operate Mini Control Board remotely using Totem App and Arduino Library.</p>  Mobile control  ESP32 control  Arduino library <p>Discontinued</p> <p>This product was discontinued in 2023-Q2. All new robotic kits includes programmable RoboBoard X3.</p>"},{"location":"modules/mini-control-board/#user-manual","title":"User manual","text":"Feature list (click to expand) <p>Connectivity: \u2022 Bluetooth (BLE)  </p> <p>Board features: \u2022 2 Servo ports (3.7 Volts) \u2022 4 DC ports (3.7 Volts) \u2022 4 RGB lights \u2022 On/off switch \u2022 Battery input, integrated charger  </p> <p>Power: \u2022 USB-C: (only for charging) \u2022 Battery: LiPo, 3.7V, 250 mAh  </p> <p>Dimensions: \u2022 65 x 25 x 8 mm (L x W x H)  </p>"},{"location":"modules/mini-control-board/#motors","title":"Motors","text":"<p>Connectors on the board allow for the direct plug-in of 4 DC motors and 2 Servos. Motors are powered straight from the battery (around 3.7V). Each port is identified by letter A, B, C, D.</p> <p>4 DC ports has control of: spin direction, PWM duty cycle [<code>0</code>:<code>100</code>]%, braking (v2.0 only). 2 Servo ports has control of: arm position [<code>-100</code>:<code>100</code>]% ([<code>-</code>] left, [<code>0</code>] center, [<code>+</code>] right). Servo is predefined to [<code>500</code>:<code>2500</code>]us range.  </p> <p></p>"},{"location":"modules/mini-control-board/#bluetooth","title":"Bluetooth","text":"<p>Once powered on, board will show up in Totem App connection menu and becomes connectable using Arduino Library. Bluetooth is always enabled. Only singe device can be connected at the same time.</p>"},{"location":"modules/mini-control-board/#power-charging","title":"Power &amp; charging","text":"<p> \u2460\u00a0Push switch up to power on. \u2461\u00a0Battery level is displayed in color:  - battery is full  - battery is medium  - battery is low  - battery is discharged \u2022 Boards v1.4, v1.5 don't have power switch.  </p> <p> \u2460\u00a0Plug-in USB-C cable \u2461  battery is charging \u2462  battery is charged \u2022 Charging will override ON, OFF switch. \u2022 Board is not operational while charging. \u2022 Use computer or phone charger to power. \u2022 Boards v1.4, v1.5 don't have built in charger.  </p>"},{"location":"modules/mini-control-board/#rgb-light-bar","title":"RGB light bar","text":"<p>Light bar can be used for robot appearance and indicating certain states. Note: Boards v1.4, v1.5 has 12 individual red LED, controlled using setLED(). </p> <ul> <li>Running animation - no connection</li> <li>Steady color - connected to robot</li> <li>Change color - click Settings when connected with Totem App</li> <li>Control color - set any with rgbColor()</li> </ul> <p></p>"},{"location":"modules/mini-control-board/#api-reference","title":"API Reference","text":"<p>Control Mini Control Board remotely using any ESP32 development board. Arduino interface is provided by Totem Arduino Library.</p> <pre><code>#include &lt;TotemMiniControlBoard.h&gt;\nTotemMiniControlBoard board;\nvoid setup() {\n  // Connect to Mini Control Board (over Bluetooth)\n  board.connect();\n  // Set RGB to red\n  board.rgbColor(125,0,0);\n  // Spin Motor\n  board.dcSpinA(40);\n  // Spin Servo\n  board.servoSpinA(50);\n}\nvoid loop() { }\n</code></pre>"},{"location":"modules/mini-control-board/#connection","title":"Connection","text":"<p>Functions to establish and control Bluetooth connection.</p>"},{"location":"modules/mini-control-board/#connect","title":"<code>state</code> board.connect()","text":""},{"location":"modules/mini-control-board/#connectName","title":"<code>state</code> board.connectName(<code>name</code>)","text":"<p>Initiate Bluetooth connection to the board. Parameter: <code>name</code> - connect only if name matches <code>address</code> - connect only if BLE address matches Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] failed  </p> <p>Is connection active. Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] disconnected  </p> <p>Terminate active connection  </p> <p>Get connected board BLE address. Returns: <code>address</code> - String object containing address <code>XX:XX:XX:XX:XX</code> </p> <p>Register connection state change event. Parameter: <code>function</code> - function name <code>void onConnectionChange()</code> </p>"},{"location":"modules/mini-control-board/#connectAddress","title":"<code>state</code> board.connectAddress(<code>address</code>)","text":""},{"location":"modules/mini-control-board/#isConnected","title":"<code>state</code> board.isConnected()","text":""},{"location":"modules/mini-control-board/#disconnect","title":"board.disconnect()","text":""},{"location":"modules/mini-control-board/#getAddress","title":"<code>address</code> board.getAddress()","text":""},{"location":"modules/mini-control-board/#addOnConnectionChange","title":"board.addOnConnectionChange(<code>function</code>)","text":""},{"location":"modules/mini-control-board/#information","title":"Information","text":"<p>Functions to receive board information and configuration.</p> <p>Read battery voltage. Returns: <code>voltage</code> - [<code>2700</code>:<code>4200</code>] voltage in millivolts.  </p> <p>Get firmware version. Returns: <code>version</code> - String object containing firmware version.  </p> <p>Get board revision. Returns: <code>version</code> - String object containing board revision.  </p> <p>Get configured board name. Returns: <code>name</code> - String object containing</p> <p>Get type of robot board is installed in (configured with <code>setModel()</code>). Note: not used at the moment. Returns: <code>name</code> - 16-bit identifier  </p> <p>Get configured board appearance color. Returns: <code>hex</code> - [<code>0</code>:<code>0xFFFFFF</code>] 24-bit color code.  </p> <p>Get if all DC motor ports are inverted. Returns: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted</p> <p>Get if all DC motor autobrake is enabled. Returns: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast</p>"},{"location":"modules/mini-control-board/#getBattery","title":"<code>voltage</code> board.getBattery()","text":""},{"location":"modules/mini-control-board/#getVersion","title":"<code>version</code> board.getVersion()","text":""},{"location":"modules/mini-control-board/#getRevision","title":"<code>version</code> board.getRevision()","text":""},{"location":"modules/mini-control-board/#getName","title":"<code>name</code> board.getName()","text":""},{"location":"modules/mini-control-board/#getModel","title":"<code>model</code> board.getModel()","text":""},{"location":"modules/mini-control-board/#getColor","title":"<code>hex</code> board.getColor()","text":""},{"location":"modules/mini-control-board/#getInvertDC","title":"<code>state</code> board.getInvertDC()","text":""},{"location":"modules/mini-control-board/#getAutobrakeDC","title":"<code>state</code> board.getAutobrakeDC()","text":""},{"location":"modules/mini-control-board/#motor-control","title":"Motor control","text":"<p>Servo and DC motors control functions.</p>"},{"location":"modules/mini-control-board/#servoSpinA","title":"board.servoSpinA(<code>pos</code>)","text":"<p>Spin servo motor to position. Parameter: <code>pos</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p> <p>Spin all servo motors to individual position with a single command. Parameter: <code>A</code>,<code>B</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p>"},{"location":"modules/mini-control-board/#servoSpinB","title":"board.servoSpinB(<code>pos</code>)","text":""},{"location":"modules/mini-control-board/#servoSpinABCD","title":"board.servoSpinAB(<code>A</code>,<code>B</code>)","text":""},{"location":"modules/mini-control-board/#dcSpinA","title":"board.dcSpinA(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcSpinB","title":"board.dcSpinB(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcSpinC","title":"board.dcSpinC(<code>power</code>)","text":"<p>Spin DC motor. Parameter: <code>power</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p>"},{"location":"modules/mini-control-board/#dcSpinD","title":"board.dcSpinD(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcBrakeA","title":"board.dcBrakeA(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcBrakeB","title":"board.dcBrakeB(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcBrakeC","title":"board.dcBrakeC(<code>power</code>)","text":"<p>Brake DC motor. Only supported in v2.0 Parameter: <code>power</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p> <p>Apply individual spin power to all DC motors with a singe command. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p> <p>Apply individual brake to all DC motors with a singe command. Only supported in v2.0 Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p>"},{"location":"modules/mini-control-board/#dcBrakeD","title":"board.dcBrakeD(<code>power</code>)","text":""},{"location":"modules/mini-control-board/#dcSpinABCD","title":"board.dcSpinABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/mini-control-board/#dcBrakeABCD","title":"board.dcBrakeABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/mini-control-board/#lights-control","title":"Lights control","text":"<p>RGB lights (or 12 LED) control functions.</p> <p>Set LED strip state (boards v1.4, v1.5). Each bit in 12bit value represents individual on-board LED. [<code>0</code>] off, [<code>1</code>] on. Parameter: <code>map</code> - [<code>0</code>:<code>0b111111111111</code>] LED state map  </p> <p>Turn full brightness RGB mode (change color to take effect). Parameter: <code>state</code> - [<code>true</code>] full, [<code>false</code>] medium  </p> <p>Check if board has RGB lights (revision 2.0). Returns: <code>state</code> - [<code>true</code>] has RGB, [<code>false</code>] has LED strip  </p>"},{"location":"modules/mini-control-board/#setLED","title":"board.setLED(<code>map</code>)","text":""},{"location":"modules/mini-control-board/#rgbBrightMode","title":"board.rgbBrightMode(<code>state</code>)","text":""},{"location":"modules/mini-control-board/#hasRGB","title":"<code>state</code> board.hasRGB()","text":""},{"location":"modules/mini-control-board/#rgbColorA","title":"board.rgbColorA(<code>hex</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorB","title":"board.rgbColorB(<code>hex</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorC","title":"board.rgbColorC(<code>hex</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorD","title":"board.rgbColorD(<code>hex</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorA-rgb","title":"board.rgbColorA(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorB-rgb","title":"board.rgbColorB(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorC-rgb","title":"board.rgbColorC(<code>red</code>,<code>green</code>,<code>blue</code>)","text":"<p>Set color to individual RGB light. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p>"},{"location":"modules/mini-control-board/#rgbColorD-rgb","title":"board.rgbColorD(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/mini-control-board/#rgbColor","title":"board.rgbColor(<code>hex</code>)","text":"<p>Set color to all RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Set all RGB lights to Totem color.  </p> <p>Set RGB lights to default board color (configured with setColor()).  </p>"},{"location":"modules/mini-control-board/#rgbColor-rgb","title":"board.rgbColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/mini-control-board/#rgbColorTotem","title":"board.rgbColorTotem()","text":""},{"location":"modules/mini-control-board/#rgbColorReset","title":"board.rgbColorReset()","text":""},{"location":"modules/mini-control-board/#configuration","title":"Configuration","text":"<p>Configure board settings (retained after power off).</p> <p>Change board name. Parameter: <code>name</code> - board discovery name (30 bytes max)  </p>"},{"location":"modules/mini-control-board/#setName","title":"board.setName(<code>name</code>)","text":""},{"location":"modules/mini-control-board/#setColor","title":"board.setColor(<code>hex</code>)","text":"<p>Change board initial color. It may be displayed inside mobile application or on-board RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Assign type of robot board is installed in. Note: not used at the moment. Parameter: <code>model</code> - [0:0xFFFF] 16-bit identifier  </p> <p>Invert all DC motor ports. Parameter: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted  </p> <p>Brake all DC motors when power is set to <code>0</code>. Only supported in v2.0 Parameter: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast  </p> <p>Reset stored configuration (factory reset).  </p> <p>Restart connected board.  </p>"},{"location":"modules/mini-control-board/#setColor-rgb","title":"board.setColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/mini-control-board/#setModel","title":"board.setModel(<code>model</code>)","text":""},{"location":"modules/mini-control-board/#setInvertDC","title":"board.setInvertDC(<code>state</code>)","text":""},{"location":"modules/mini-control-board/#setAutobrakeDC","title":"board.setAutobrakeDC(<code>state</code>)","text":""},{"location":"modules/mini-control-board/#resetConfig","title":"board.resetConfig()","text":""},{"location":"modules/mini-control-board/#restart","title":"board.restart()","text":""},{"location":"modules/mini-control-board/#known-behavior","title":"Known behavior","text":"<p>Board revision v2.0 will enable DC channel C and D for a short period of time (25ms) during power on. This will result in slight robot wheel spin and doesn't indicate defective product or firmware. Most robotic kits use channels A and B.</p>"},{"location":"modules/mini-control-board/#revision-changelog","title":"Revision changelog","text":"<p>We are always looking to improve our products. Any physical change (components, layout) is indicated with board revision number (printed on top). Each revision may have different features or functionality.</p> <p>Discontinued in 2023-Q2 and replaced by RoboBoard X3.</p>"},{"location":"modules/mini-control-board/#v20","title":"v2.0","text":"<p>Manufactured from 2022-Q1.</p> <ul> <li>Visual, design and layout</li> <li>Rename to Mini Control Board</li> <li>12 red LED switched to 4 RGB</li> <li>Switched MCU from nRF52 to ESP32</li> <li>Improved battery connector</li> <li>Integrated battery charger (USB-C)</li> <li>Added on/off switch</li> <li>Motor braking feature</li> </ul>"},{"location":"modules/mini-control-board/#v15","title":"v1.5","text":"<p>Also known as Totem X3-FBI or MiniTrooper board.</p> <ul> <li>Layout changes</li> <li>Shorter by 1.0 cm</li> <li>Removed speaker (not good enough)</li> </ul>"},{"location":"modules/mini-control-board/#v14","title":"v1.4","text":"<p>Also known as Totem X3-FBI or MiniTrooper board.</p> <ul> <li>First public release</li> </ul>"},{"location":"modules/roboboard-x3/","title":"RoboBoard X3","text":"<p>Operate RoboBoard X3 remotely using Totem App and Arduino Library. For user manual read documentation section.  </p>  Mobile control  ESP32 control  Arduino library"},{"location":"modules/roboboard-x3/#api-reference","title":"API Reference","text":"<p>Arduino code to connect RoboBoard X3 remotely. Note: RoboBoard has to run TotemApp service in order to be discoverable.</p> <pre><code>#include &lt;TotemRoboBoardX3.h&gt;\nTotemRoboBoardX3 board;\nvoid setup() {\n  // Connect to RoboBoard X3 (over Bluetooth)\n  board.connect();\n  // Set RGB to red\n  board.rgbColor(125,0,0);\n  // Spin Motor\n  board.dcSpinA(40);\n  // Spin Servo\n  board.servoSpinA(50);\n}\nvoid loop() { }\n</code></pre>"},{"location":"modules/roboboard-x3/#connection","title":"Connection","text":"<p>Functions to establish and control Bluetooth connection.</p>"},{"location":"modules/roboboard-x3/#connect","title":"<code>state</code> board.connect()","text":""},{"location":"modules/roboboard-x3/#connectName","title":"<code>state</code> board.connectName(<code>name</code>)","text":"<p>Initiate Bluetooth connection to the board. Parameter: <code>name</code> - connect only if name matches <code>address</code> - connect only if BLE address matches Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] failed  </p> <p>Is connection active. Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] disconnected  </p> <p>Terminate active connection  </p> <p>Get connected board BLE address. Returns: <code>address</code> - String object containing address <code>XX:XX:XX:XX:XX</code> </p> <p>Register connection state change event. Parameter: <code>function</code> - function name <code>void onConnectionChange()</code> <pre><code>#include &lt;TotemRoboBoardX3.h&gt;\nTotemRoboBoardX3 roboboard;\n// Detect connection state change event\nvoid onConnectionChange() {\n  if (roboboard.isConnected())\n    { /* Connected */ }\n  else\n    { /* Disconnected */ }\n}\n// Initialize program\nvoid setup() {\n  // Register connection state event\n  roboboard.addOnConnectionChange(onConnectionChange);\n  // Connect to RoboBoard over Bluetooth\n  roboboard.connect();\n}\n</code></pre></p>"},{"location":"modules/roboboard-x3/#connectAddress","title":"<code>state</code> board.connectAddress(<code>address</code>)","text":""},{"location":"modules/roboboard-x3/#isConnected","title":"<code>state</code> board.isConnected()","text":""},{"location":"modules/roboboard-x3/#disconnect","title":"board.disconnect()","text":""},{"location":"modules/roboboard-x3/#getAddress","title":"<code>address</code> board.getAddress()","text":""},{"location":"modules/roboboard-x3/#addOnConnectionChange","title":"board.addOnConnectionChange(<code>function</code>)","text":""},{"location":"modules/roboboard-x3/#information","title":"Information","text":"<p>Functions to receive board information and configuration.</p> <p>Read button (BOOT) state. Returns: <code>state</code> - [<code>true</code>] is pressed, [<code>false</code>] not pressed.  </p> <p>Read battery voltage. Returns: <code>voltage</code> - [<code>2700</code>:<code>4200</code>] voltage in millivolts.  </p> <p>Get firmware version. Returns: <code>version</code> - String object containing firmware version.  </p> <p>Get board revision. Returns: <code>version</code> - String object containing board revision.  </p> <p>Get configured board name. Returns: <code>name</code> - String object containing</p> <p>Get type of robot board is installed in (configured with <code>setModel()</code>). Note: not used at the moment. Returns: <code>name</code> - 16-bit identifier  </p> <p>Get configured board appearance color. Returns: <code>hex</code> - [<code>0</code>:<code>0xFFFFFF</code>] 24-bit color code.  </p> <p>Get if all DC motor ports are inverted. Returns: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted</p> <p>Get if all DC motor autobrake is enabled. Returns: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast</p>"},{"location":"modules/roboboard-x3/#getButton","title":"<code>state</code> board.getButton()","text":""},{"location":"modules/roboboard-x3/#getBattery","title":"<code>voltage</code> board.getBattery()","text":""},{"location":"modules/roboboard-x3/#getVersion","title":"<code>version</code> board.getVersion()","text":""},{"location":"modules/roboboard-x3/#getRevision","title":"<code>version</code> board.getRevision()","text":""},{"location":"modules/roboboard-x3/#getName","title":"<code>name</code> board.getName()","text":""},{"location":"modules/roboboard-x3/#getModel","title":"<code>model</code> board.getModel()","text":""},{"location":"modules/roboboard-x3/#getColor","title":"<code>hex</code> board.getColor()","text":""},{"location":"modules/roboboard-x3/#getInvertDC","title":"<code>state</code> board.getInvertDC()","text":""},{"location":"modules/roboboard-x3/#getAutobrakeDC","title":"<code>state</code> board.getAutobrakeDC()","text":""},{"location":"modules/roboboard-x3/#motor-control","title":"Motor control","text":"<p>Servo and DC motors control functions.</p>"},{"location":"modules/roboboard-x3/#servoSpinA","title":"board.servoSpinA(<code>pos</code>)","text":""},{"location":"modules/roboboard-x3/#servoSpinB","title":"board.servoSpinB(<code>pos</code>)","text":""},{"location":"modules/roboboard-x3/#servoSpinC","title":"board.servoSpinC(<code>pos</code>)","text":"<p>Spin servo motor to position. Note: revision 3.0 has only 2 servos. Parameter: <code>pos</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p> <p>Spin all servo motors to individual position with a single command. Note: revision 3.0 has only 2 servos. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p>"},{"location":"modules/roboboard-x3/#servoSpinD","title":"board.servoSpinD(<code>pos</code>)","text":""},{"location":"modules/roboboard-x3/#servoSpinABCD","title":"board.servoSpinABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/roboboard-x3/#dcSpinA","title":"board.dcSpinA(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcSpinB","title":"board.dcSpinB(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcSpinC","title":"board.dcSpinC(<code>power</code>)","text":"<p>Spin DC motor. Parameter: <code>power</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p>"},{"location":"modules/roboboard-x3/#dcSpinD","title":"board.dcSpinD(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcBrakeA","title":"board.dcBrakeA(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcBrakeB","title":"board.dcBrakeB(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcBrakeC","title":"board.dcBrakeC(<code>power</code>)","text":"<p>Brake DC motor. Parameter: <code>power</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p> <p>Apply individual spin power to all DC motors with a singe command. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p> <p>Apply individual brake to all DC motors with a singe command. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p>"},{"location":"modules/roboboard-x3/#dcBrakeD","title":"board.dcBrakeD(<code>power</code>)","text":""},{"location":"modules/roboboard-x3/#dcSpinABCD","title":"board.dcSpinABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/roboboard-x3/#dcBrakeABCD","title":"board.dcBrakeABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/roboboard-x3/#lights-control","title":"Lights control","text":"<p>RGB lights control functions.</p>"},{"location":"modules/roboboard-x3/#rgbColorA","title":"board.rgbColorA(<code>hex</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorB","title":"board.rgbColorB(<code>hex</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorC","title":"board.rgbColorC(<code>hex</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorD","title":"board.rgbColorD(<code>hex</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorA-rgb","title":"board.rgbColorA(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorB-rgb","title":"board.rgbColorB(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorC-rgb","title":"board.rgbColorC(<code>red</code>,<code>green</code>,<code>blue</code>)","text":"<p>Set color to individual RGB light. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p>"},{"location":"modules/roboboard-x3/#rgbColorD-rgb","title":"board.rgbColorD(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColor","title":"board.rgbColor(<code>hex</code>)","text":"<p>Set color to all RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Set all RGB lights to Totem color.  </p> <p>Set RGB lights to default board color (configured with setColor()).  </p>"},{"location":"modules/roboboard-x3/#rgbColor-rgb","title":"board.rgbColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x3/#rgbColorTotem","title":"board.rgbColorTotem()","text":""},{"location":"modules/roboboard-x3/#rgbColorReset","title":"board.rgbColorReset()","text":""},{"location":"modules/roboboard-x3/#user-commands","title":"User commands","text":"<p>Send user defined data between RoboBoard X3 and Totem Library.</p> <p>Send value to remote RoboBoard. Parameter: <code>id</code> - 32-bit identifier <code>value</code> - 32-bit value Returns: <code>status</code> - [<code>true</code>] success, [<code>false</code>] error  </p>"},{"location":"modules/roboboard-x3/#sendValue","title":"<code>status</code> board.sendValue(<code>id</code>,<code>value</code>)","text":""},{"location":"modules/roboboard-x3/#sendString","title":"<code>status</code> board.sendString(<code>id</code>,<code>string</code>)","text":"<p>Send string (text) or data array to remote RoboBoard. Parameter: <code>id</code> - 32-bit identifier <code>string</code> - String object <code>data</code> - pointer to array <code>length</code> - array length Returns: <code>status</code> - [<code>true</code>] success, [<code>false</code>] error  </p> <p>Read value from remote RoboBoard. Calls <code>TotemApp.addOnRead()</code> handler. Parameter: <code>id</code> - 32-bit identifier Returns: <code>status</code> - [<code>0</code>:<code>0xFFFFFFFF</code>] value  </p> <p>Read string (text) from remote RoboBoard. Calls <code>TotemApp.addOnRead()</code> handler. Parameter: <code>id</code> - 32-bit identifier Returns: <code>string</code> - String object  </p> <p>Register event to intercept data sent from remote RoboBoard with functions <code>TotemApp.sendValue()</code>, <code>TotemApp.sendString()</code>. It accepts value and string functions. Both can be added at the same time. Parameter: <code>function</code> - <code>void onReceiveValue(int id, int value)</code> <code>function</code> - <code>void onReceiveString(int id, String string)</code> <pre><code>#include &lt;TotemRoboBoardX3.h&gt;\nTotemRoboBoardX3 roboboard;\n// Intercept value sent by TotemApp.sendValue() (from RoboBoard)\nvoid onReceiveValue(int id, int value) {\n\n}\n// Intercept string sent by TotemApp.sendString() (from RoboBoard)\nvoid onReceiveString(int id, String string) {\n\n}\n// Initialize program\nvoid setup() {\n  // Register value and string receive functions\n  roboboard.addOnReceive(onReceiveValue);\n  roboboard.addOnReceive(onReceiveString);\n  // Connect to RoboBoard over Bluetooth\n  roboboard.connect();\n}\n</code></pre></p>"},{"location":"modules/roboboard-x3/#sendString","title":"<code>status</code> board.sendString(<code>id</code>,<code>data</code>,<code>length</code>)","text":""},{"location":"modules/roboboard-x3/#readValue","title":"<code>value</code> board.readValue(<code>id</code>)","text":""},{"location":"modules/roboboard-x3/#readString","title":"<code>string</code> board.readString(<code>id</code>)","text":""},{"location":"modules/roboboard-x3/#addOnReceive","title":"board.addOnReceive(<code>function</code>)","text":""},{"location":"modules/roboboard-x3/#functionA","title":"board.functionA(<code>value</code>)","text":""},{"location":"modules/roboboard-x3/#functionB","title":"board.functionB(<code>value</code>)","text":""},{"location":"modules/roboboard-x3/#functionC","title":"board.functionC(<code>value</code>)","text":"<p>Send value to RoboBoard function event. Parameter: <code>value</code> - any 32-bit value  </p>"},{"location":"modules/roboboard-x3/#functionD","title":"board.functionD(<code>value</code>)","text":""},{"location":"modules/roboboard-x3/#configuration","title":"Configuration","text":"<p>Configure board settings (retained after power off).</p> <p>Change board name. Parameter: <code>name</code> - board discovery name (30 bytes max)  </p>"},{"location":"modules/roboboard-x3/#setName","title":"board.setName(<code>name</code>)","text":""},{"location":"modules/roboboard-x3/#setColor","title":"board.setColor(<code>hex</code>)","text":"<p>Change board initial color. It may be displayed inside mobile application or on-board RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Assign type of robot board is installed in. Note: not used at the moment. Parameter: <code>model</code> - [0:0xFFFF] 16-bit identifier  </p> <p>Invert all DC motor ports. Parameter: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted  </p> <p>Brake all DC motors when power is set to <code>0</code>. Parameter: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast  </p> <p>Reset stored configuration (factory reset).  </p> <p>Restart connected board.  </p>"},{"location":"modules/roboboard-x3/#setColor-rgb","title":"board.setColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x3/#setModel","title":"board.setModel(<code>model</code>)","text":""},{"location":"modules/roboboard-x3/#setInvertDC","title":"board.setInvertDC(<code>state</code>)","text":""},{"location":"modules/roboboard-x3/#setAutobrakeDC","title":"board.setAutobrakeDC(<code>state</code>)","text":""},{"location":"modules/roboboard-x3/#resetConfig","title":"board.resetConfig()","text":""},{"location":"modules/roboboard-x3/#restart","title":"board.restart()","text":""},{"location":"modules/roboboard-x4/","title":"RoboBoard X4","text":"<p>Operate RoboBoard X4 remotely using Totem App and Arduino Library. For user manual read documentation section.  </p>  Mobile control  ESP32 control  Arduino library"},{"location":"modules/roboboard-x4/#api-reference","title":"API Reference","text":"<p>Arduino code to connect RoboBoard X4 remotely. Note: RoboBoard has to run TotemApp service in order to be discoverable.</p> <pre><code>#include &lt;TotemRoboBoardX4.h&gt;\nTotemRoboBoardX4 board;\nvoid setup() {\n  // Connect to RoboBoard X4 (over Bluetooth)\n  board.connect();\n  // Set RGB to red\n  board.rgbColor(125,0,0);\n  // Spin Motor\n  board.dcSpinA(40);\n  // Spin Servo\n  board.servoSpinA(50);\n}\nvoid loop() { }\n</code></pre>"},{"location":"modules/roboboard-x4/#connection","title":"Connection","text":"<p>Functions to establish and control Bluetooth connection.</p>"},{"location":"modules/roboboard-x4/#connect","title":"<code>state</code> board.connect()","text":""},{"location":"modules/roboboard-x4/#connectName","title":"<code>state</code> board.connectName(<code>name</code>)","text":"<p>Initiate Bluetooth connection to the board. Parameter: <code>name</code> - connect only if name matches <code>address</code> - connect only if BLE address matches Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] failed  </p> <p>Is connection active. Returns: <code>state</code> - [<code>true</code>] connected, [<code>false</code>] disconnected  </p> <p>Terminate active connection  </p> <p>Get connected board BLE address. Returns: <code>address</code> - String object containing address <code>XX:XX:XX:XX:XX</code> </p> <p>Register connection state change event. Parameter: <code>function</code> - function name <code>void onConnectionChange()</code> <pre><code>#include &lt;TotemRoboBoardX4.h&gt;\nTotemRoboBoardX4 roboboard;\n// Detect connection state change event\nvoid onConnectionChange() {\n  if (roboboard.isConnected())\n    { /* Connected */ }\n  else\n    { /* Disconnected */ }\n}\n// Initialize program\nvoid setup() {\n  // Register connection state event\n  roboboard.addOnConnectionChange(onConnectionChange);\n  // Connect to RoboBoard over Bluetooth\n  roboboard.connect();\n}\n</code></pre></p>"},{"location":"modules/roboboard-x4/#connectAddress","title":"<code>state</code> board.connectAddress(<code>address</code>)","text":""},{"location":"modules/roboboard-x4/#isConnected","title":"<code>state</code> board.isConnected()","text":""},{"location":"modules/roboboard-x4/#disconnect","title":"board.disconnect()","text":""},{"location":"modules/roboboard-x4/#getAddress","title":"<code>address</code> board.getAddress()","text":""},{"location":"modules/roboboard-x4/#addOnConnectionChange","title":"board.addOnConnectionChange(<code>function</code>)","text":""},{"location":"modules/roboboard-x4/#information","title":"Information","text":"<p>Functions to receive board information and configuration.</p> <p>Read button (BOOT) state. Returns: <code>state</code> - [<code>true</code>] is pressed, [<code>false</code>] not pressed.  </p> <p>Read battery voltage. Returns: <code>voltage</code> - [<code>8400</code>:<code>12600</code>] voltage in millivolts.  </p> <p>Get firmware version. Returns: <code>version</code> - String object containing firmware version.  </p> <p>Get motor driver firmware version. Returns: <code>version</code> - String object containing firmware version.  </p> <p>Get board revision. Returns: <code>version</code> - String object containing board revision.  </p> <p>Get configured board name. Returns: <code>name</code> - String object containing</p> <p>Get type of robot board is installed in (configured with <code>setModel()</code>). Note: not used at the moment. Returns: <code>name</code> - 16-bit identifier  </p> <p>Get configured board appearance color. Returns: <code>hex</code> - [<code>0</code>:<code>0xFFFFFF</code>] 24-bit color code.  </p> <p>Get if all DC motor ports are inverted. Returns: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted</p> <p>Get if all DC motor autobrake is enabled. Returns: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast</p>"},{"location":"modules/roboboard-x4/#getButton","title":"<code>state</code> board.getButton()","text":""},{"location":"modules/roboboard-x4/#getBattery","title":"<code>voltage</code> board.getBattery()","text":""},{"location":"modules/roboboard-x4/#getVersion","title":"<code>version</code> board.getVersion()","text":""},{"location":"modules/roboboard-x4/#getDriverVersion","title":"<code>version</code> board.getDriverVersion()","text":""},{"location":"modules/roboboard-x4/#getRevision","title":"<code>version</code> board.getRevision()","text":""},{"location":"modules/roboboard-x4/#getName","title":"<code>name</code> board.getName()","text":""},{"location":"modules/roboboard-x4/#getModel","title":"<code>model</code> board.getModel()","text":""},{"location":"modules/roboboard-x4/#getColor","title":"<code>hex</code> board.getColor()","text":""},{"location":"modules/roboboard-x4/#getInvertDC","title":"<code>state</code> board.getInvertDC()","text":""},{"location":"modules/roboboard-x4/#getAutobrakeDC","title":"<code>state</code> board.getAutobrakeDC()","text":""},{"location":"modules/roboboard-x4/#motor-control","title":"Motor control","text":"<p>Servo and DC motors control functions.</p>"},{"location":"modules/roboboard-x4/#servoSpinA","title":"board.servoSpinA(<code>pos</code>)","text":""},{"location":"modules/roboboard-x4/#servoSpinB","title":"board.servoSpinB(<code>pos</code>)","text":"<p>Spin servo motor to position. Parameter: <code>pos</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p> <p>Spin all servo motors to individual position with a single command. Parameter: <code>A</code>,<code>B</code>,<code>C</code> - [<code>-100</code>:<code>100</code>]% position. [<code>0</code>] center  </p>"},{"location":"modules/roboboard-x4/#servoSpinC","title":"board.servoSpinC(<code>pos</code>)","text":""},{"location":"modules/roboboard-x4/#servoSpinABC","title":"board.servoSpinABC(<code>A</code>,<code>B</code>,<code>C</code>)","text":""},{"location":"modules/roboboard-x4/#dcSpinA","title":"board.dcSpinA(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcSpinB","title":"board.dcSpinB(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcSpinC","title":"board.dcSpinC(<code>power</code>)","text":"<p>Spin DC motor. Parameter: <code>power</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p>"},{"location":"modules/roboboard-x4/#dcSpinD","title":"board.dcSpinD(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcBrakeA","title":"board.dcBrakeA(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcBrakeB","title":"board.dcBrakeB(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcBrakeC","title":"board.dcBrakeC(<code>power</code>)","text":"<p>Brake DC motor. Parameter: <code>power</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p> <p>Apply individual spin power to all DC motors with a singe command. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>-100</code>:<code>100</code>]% power. [<code>0</code>] stop  </p> <p>Apply individual brake to all DC motors with a singe command. Parameter: <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> - [<code>0</code>:<code>100</code>]% power. Default 100%  </p>"},{"location":"modules/roboboard-x4/#dcBrakeD","title":"board.dcBrakeD(<code>power</code>)","text":""},{"location":"modules/roboboard-x4/#dcSpinABCD","title":"board.dcSpinABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/roboboard-x4/#dcBrakeABCD","title":"board.dcBrakeABCD(<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>)","text":""},{"location":"modules/roboboard-x4/#lights-control","title":"Lights control","text":"<p>RGB lights and single LED control functions.</p> <p>Turn (red) LED. Parameter: <code>state</code> - [<code>0</code>] off, [<code>1</code>] on  </p>"},{"location":"modules/roboboard-x4/#setLED","title":"board.setLED(<code>state</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorA","title":"board.rgbColorA(<code>hex</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorB","title":"board.rgbColorB(<code>hex</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorC","title":"board.rgbColorC(<code>hex</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorD","title":"board.rgbColorD(<code>hex</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorA-rgb","title":"board.rgbColorA(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorB-rgb","title":"board.rgbColorB(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorC-rgb","title":"board.rgbColorC(<code>red</code>,<code>green</code>,<code>blue</code>)","text":"<p>Set color to individual RGB light. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p>"},{"location":"modules/roboboard-x4/#rgbColorD-rgb","title":"board.rgbColorD(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColor","title":"board.rgbColor(<code>hex</code>)","text":"<p>Set color to all RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Set all RGB lights to Totem color.  </p> <p>Set RGB lights to default board color (configured with setColor()).  </p>"},{"location":"modules/roboboard-x4/#rgbColor-rgb","title":"board.rgbColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x4/#rgbColorTotem","title":"board.rgbColorTotem()","text":""},{"location":"modules/roboboard-x4/#rgbColorReset","title":"board.rgbColorReset()","text":""},{"location":"modules/roboboard-x4/#user-commands","title":"User commands","text":"<p>Send user defined data between RoboBoard X4 and Totem Library.</p> <p>Send value to remote RoboBoard. Parameter: <code>id</code> - 32-bit identifier <code>value</code> - 32-bit value Returns: <code>status</code> - [<code>true</code>] success, [<code>false</code>] error  </p>"},{"location":"modules/roboboard-x4/#sendValue","title":"<code>status</code> board.sendValue(<code>id</code>,<code>value</code>)","text":""},{"location":"modules/roboboard-x4/#sendString","title":"<code>status</code> board.sendString(<code>id</code>,<code>string</code>)","text":"<p>Send string (text) or data array to remote RoboBoard. Parameter: <code>id</code> - 32-bit identifier <code>string</code> - String object <code>data</code> - pointer to array <code>length</code> - array length Returns: <code>status</code> - [<code>true</code>] success, [<code>false</code>] error  </p> <p>Read value from remote RoboBoard. Calls <code>TotemApp.addOnRead()</code> handler. Parameter: <code>id</code> - 32-bit identifier Returns: <code>status</code> - [<code>0</code>:<code>0xFFFFFFFF</code>] value  </p> <p>Read string (text) from remote RoboBoard. Calls <code>TotemApp.addOnRead()</code> handler. Parameter: <code>id</code> - 32-bit identifier Returns: <code>string</code> - String object  </p> <p>Register event to intercept data sent from remote RoboBoard with functions <code>TotemApp.sendValue()</code>, <code>TotemApp.sendString()</code>. It accepts value and string functions. Both can be added at the same time. Parameter: <code>function</code> - <code>void onReceiveValue(int id, int value)</code> <code>function</code> - <code>void onReceiveString(int id, String string)</code> <pre><code>#include &lt;TotemRoboBoardX4.h&gt;\nTotemRoboBoardX4 roboboard;\n// Intercept value sent by TotemApp.sendValue() (from RoboBoard)\nvoid onReceiveValue(int id, int value) {\n\n}\n// Intercept string sent by TotemApp.sendString() (from RoboBoard)\nvoid onReceiveString(int id, String string) {\n\n}\n// Initialize program\nvoid setup() {\n  // Register value and string receive functions\n  roboboard.addOnReceive(onReceiveValue);\n  roboboard.addOnReceive(onReceiveString);\n  // Connect to RoboBoard over Bluetooth\n  roboboard.connect();\n}\n</code></pre></p>"},{"location":"modules/roboboard-x4/#sendString","title":"<code>status</code> board.sendString(<code>id</code>,<code>data</code>,<code>length</code>)","text":""},{"location":"modules/roboboard-x4/#readValue","title":"<code>value</code> board.readValue(<code>id</code>)","text":""},{"location":"modules/roboboard-x4/#readString","title":"<code>string</code> board.readString(<code>id</code>)","text":""},{"location":"modules/roboboard-x4/#addOnReceive","title":"board.addOnReceive(<code>function</code>)","text":""},{"location":"modules/roboboard-x4/#functionA","title":"board.functionA(<code>value</code>)","text":""},{"location":"modules/roboboard-x4/#functionB","title":"board.functionB(<code>value</code>)","text":""},{"location":"modules/roboboard-x4/#functionC","title":"board.functionC(<code>value</code>)","text":"<p>Send value to RoboBoard function event. Parameter: <code>value</code> - any 32-bit value  </p>"},{"location":"modules/roboboard-x4/#functionD","title":"board.functionD(<code>value</code>)","text":""},{"location":"modules/roboboard-x4/#configuration","title":"Configuration","text":"<p>Configure board settings (retained after power off).</p> <p>Change board name. Parameter: <code>name</code> - board discovery name (30 bytes max)  </p>"},{"location":"modules/roboboard-x4/#setName","title":"board.setName(<code>name</code>)","text":""},{"location":"modules/roboboard-x4/#setColor","title":"board.setColor(<code>hex</code>)","text":"<p>Change board initial color. It may be displayed inside mobile application or on-board RGB lights. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0</code>:<code>0xFFFFFF</code>]  </p> <p>Assign type of robot board is installed in. Note: not used at the moment. Parameter: <code>model</code> - [0:0xFFFF] 16-bit identifier  </p> <p>Invert all DC motor ports. Parameter: <code>state</code> - [<code>true</code>] invert, [<code>false</code>] not inverted  </p> <p>Brake all DC motors when power is set to <code>0</code>. Parameter: <code>state</code> - [<code>true</code>] brake, [<code>false</code>] coast  </p> <p>Reset stored configuration (factory reset).  </p> <p>Restart connected board.  </p>"},{"location":"modules/roboboard-x4/#setColor-rgb","title":"board.setColor(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"modules/roboboard-x4/#setModel","title":"board.setModel(<code>model</code>)","text":""},{"location":"modules/roboboard-x4/#setInvertDC","title":"board.setInvertDC(<code>state</code>)","text":""},{"location":"modules/roboboard-x4/#setAutobrakeDC","title":"board.setAutobrakeDC(<code>state</code>)","text":""},{"location":"modules/roboboard-x4/#resetConfig","title":"board.resetConfig()","text":""},{"location":"modules/roboboard-x4/#restart","title":"board.restart()","text":""},{"location":"modules/ble/","title":"Totem BLE","text":"<ul> <li>Operate Totem BLE boards remotely over TotemApp service</li> <li>Supported on ESP32 (BLE capable) Arduino boards and TotemLibrary</li> <li>Available features:<ul> <li>Board discovery <code>scan()</code></li> <li>Control integrated features (Motor control)</li> <li>Send user defined data <code>sendValue()</code>, <code>sendString()</code></li> </ul> </li> </ul> Totem Library headers<pre><code>// Control over Bluetooth\n#include &lt;TotemBLE.h&gt;              // Discover Totem boards (scan)\n#include &lt;TotemMiniControlBoard.h&gt; // Connect Mini Control Board\n#include &lt;TotemRoboBoardX3.h&gt;      // Connect RoboBoard X3\n#include &lt;TotemRoboBoardX4.h&gt;      // Connect RoboBoard X4\n</code></pre>"},{"location":"modules/ble/#totemble","title":"TotemBLE","text":"<p><code>TotemBLE</code> is only used to discover available boards or validate them before connecting. For actual connection and control read specific board section MiniControlBoard, RoboBoard X3, RoboBoard X4.</p> <p>Boards are able to represent themselves with customizable: <code>name</code>, <code>color</code> and <code>model</code> (type of robot). This information is available before BLE connection is established. Same information and functionality is available using Totem App.</p> <pre><code>#include &lt;TotemBLE.h&gt;\nTotemBLE totemBLE;\n// Board found event\nvoid onScanResult(TotemScanResult result) {\n  // Print discovered board information\n  Serial.printf(\"Address: '%s', Type: %s, Name: %s, Color: %x\\n\",\n    result.getAddress().c_str(), result.getType().c_str(), result.getName().c_str(), result.getColor());\n}\nvoid setup() {\n  Serial.begin(115200);\n  // Register result function\n  totemBLE.addOnScanResult(onScanResult);\n  // Start scan for available Totem Boards\n  totemBLE.scan();\n}\nvoid loop() { }\n</code></pre>"},{"location":"modules/ble/#scan-function","title":"Scan function","text":"<p>Begin BLE <code>scan()</code> and receive discovered results from <code>addOnScanResult()</code>.</p> <p>Register function to receive discovered scan results <code>TotemScanResult</code>. Parameter: <code>function</code> - <code>void onResult(TotemScanResult result)</code> </p>"},{"location":"modules/ble/#addOnScanResult","title":"totemBLE.addOnScanResult(<code>function</code>)","text":""},{"location":"modules/ble/#scan","title":"<code>status</code> totemBLE.scan()","text":"<p>Start Bluetooth scan for Totem boards. Results will be received in function registered with <code>addOnScanResult()</code>. Parameter: <code>duration</code> - amount of seconds to scan. [<code>0</code>] infinite. Returns: <code>status</code> - [<code>true</code>] scan is started, [<code>false</code>] failed to start.  </p> <p>Stop ongoing Bluetooth scan.  </p> <p>Check if ongoing Bluetooth scan. Returns: <code>status</code> - [<code>true</code>] scanning, [<code>false</code>] not scanning.  </p> <p>Wait (block) until scan is stopped by <code>duration</code> or manually with <code>stop()</code>. <pre><code>TotemBLE totemBLE;\nvoid setup() {\n  totemBLE.scan();\n  totemBLE.wait();\n  // Code execution is held by \"wait\" function, until scan is stopped\n}\n</code></pre></p>"},{"location":"modules/ble/#scan-duration","title":"<code>status</code> totemBLE.scan(<code>duration</code>)","text":""},{"location":"modules/ble/#stop","title":"totemBLE.stop()","text":""},{"location":"modules/ble/#isScanning","title":"<code>status</code> totemBLE.isScanning()","text":""},{"location":"modules/ble/#wait","title":"totemBLE.wait()","text":""},{"location":"modules/ble/#find-function","title":"Find function","text":"<p>Begin BLE scan looking for specific board. Result will be returned once discovered.</p>"},{"location":"modules/ble/#findAny","title":"<code>TotemScanResult</code> totemBLE.findAny()","text":"<p>Discover any Totem board (block until found). Parameter: <code>name</code> - (optional) find board with matching name. Returns: <code>TotemScanResult</code> - scan result object.  </p>"},{"location":"modules/ble/#findAny-name","title":"<code>TotemScanResult</code> totemBLE.findAny(<code>name</code>)","text":""},{"location":"modules/ble/#findMiniControlBoard","title":"<code>TotemScanResult</code> totemBLE.findMiniControlBoard()","text":""},{"location":"modules/ble/#findRoboBoardX3","title":"<code>TotemScanResult</code> totemBLE.findRoboBoardX3()","text":""},{"location":"modules/ble/#findRoboBoardX4","title":"<code>TotemScanResult</code> totemBLE.findRoboBoardX4()","text":""},{"location":"modules/ble/#findMiniControlBoard-name","title":"<code>TotemScanResult</code> totemBLE.findMiniControlBoard(<code>name</code>)","text":""},{"location":"modules/ble/#findRoboBoardX3-name","title":"<code>TotemScanResult</code> totemBLE.findRoboBoardX3(<code>name</code>)","text":"<p>Discover specific type of Totem board (block until found). Parameter: <code>name</code> - (optional) find board with matching name. Returns: <code>TotemScanResult</code> - scan result object.  </p> <p>Discover Totem board matching Bluetooth address (block until found). Parameter: <code>address</code> - address Bluetooth address to find. Returns: <code>TotemScanResult</code> - scan result object.  </p>"},{"location":"modules/ble/#findRoboBoardX4-name","title":"<code>TotemScanResult</code> totemBLE.findRoboBoardX4(<code>name</code>)","text":""},{"location":"modules/ble/#findAddress","title":"<code>TotemScanResult</code> totemBLE.findAddress(<code>address</code>)","text":""},{"location":"modules/ble/#totemscanresult","title":"TotemScanResult","text":"<p>Get board Bluetooth address. Returns: <code>address</code> - String object containing address  </p> <p>Get board name. Returns: <code>name</code> - String object containing name  </p> <p>Get board appearance color. Returns: <code>color</code> - 24-bit HEX color  </p> <p>Get board appearance identifier. Note: Not used at the moment. Returns: <code>color</code> - 16-bit identifier  </p> <p>Get board identification number. Returns: <code>number</code> - 8-bit id  </p> <p>Get board type name. Returns: <code>type</code> - String of [<code>Mini Control Board</code>, <code>RoboBoard X3</code>, <code>RoboBoard X4</code>]  </p>"},{"location":"modules/ble/#getAddress","title":"<code>address</code> result.getAddress()","text":""},{"location":"modules/ble/#getName","title":"<code>name</code> result.getName()","text":""},{"location":"modules/ble/#getColor","title":"<code>color</code> result.getColor()","text":""},{"location":"modules/ble/#getModel","title":"<code>color</code> result.getModel()","text":""},{"location":"modules/ble/#getNumber","title":"<code>number</code> result.getNumber()","text":""},{"location":"modules/ble/#getType","title":"<code>type</code> result.getType()","text":""},{"location":"modules/ble/#isMiniControlBoard","title":"<code>status</code> result.isMiniControlBoard()","text":""},{"location":"modules/ble/#isRoboBoardX3","title":"<code>status</code> result.isRoboBoardX3()","text":"<p>Is board of specific type. Returns: <code>status</code> - [<code>true</code>:<code>false</code>]  </p>"},{"location":"modules/ble/#isRoboBoardX4","title":"<code>status</code> result.isRoboBoardX4()","text":""},{"location":"modules/legacy-x4/","title":"X4 Modules","text":"<p>Legacy TotemBUS modules for RoboBoard X4 v1.0 and v1.1 only. Note: \"TotemModule\" headers are included in Totem Boards core and don't require Totem Library.</p> RoboBoard X4 module headers<pre><code>// Control X4 Modules\n#include &lt;TotemModule11.h&gt;  // Control Distance module\n#include &lt;TotemModule14.h&gt;  // Control Line Follower module\n#include &lt;TotemModule15.h&gt;  // Control Potentiometer module\n#include &lt;TotemModule22.h&gt;  // Control Sensor module\n</code></pre>"},{"location":"modules/legacy-x4/#connecting-modules","title":"Connecting modules","text":"<ul> <li>Each module is identified by number [XX] in a white square.</li> <li>Unique serial identifier is available in case more than one module is used.</li> <li>Modules can be daisy-chained with a 6 pin connector. It provides power and communication.</li> <li>Module is operational the second it's physically connected to X4.</li> </ul>"},{"location":"modules/legacy-x4/#controlling-modules","title":"Controlling modules","text":"<p>Each module accepts a set of commands to control their specific capabilities (like reading sensor data, controlling lights or motors). Controller can also subscribe to data in order for module to start broadcasting it. The list of available functions can be found in documentation page for specific module.  </p> <ul> <li>[11] Distance module</li> <li>[14] Line follower module</li> <li>[15] Potentiometer module</li> <li>[22] Environment sensor</li> </ul>"},{"location":"modules/legacy-x4/#accessing-specific-module","title":"Accessing specific module","text":"<p>Module API can be accessed by declaring its class. It will work right away, without a need for initialization. Multiple instances can be created. If module is not physically connected, all functions calls will be ignored.  </p> <p><pre><code>#include &lt;TotemModule11.h&gt;\nTotemModule11 module; // Declare use of distance sensor [11]\nTotemModule11 module2(25151); // Declare use of distance sensor [11] with serial 25151\n</code></pre> <code>TotemModuleXX</code> - each module hash class implementation name of <code>TotemModule</code> + number. <code>module</code> - a variable name of <code>TotemModule11</code>. Can be any (sensor, controller, lineReader, ...). This instance is used to call module functions. <code>(25151)</code> - if there are multiple modules with same number - serial is used to specify exact one. Using instance <code>module2</code> will send commands to specific module only. Otherwise - all connected [11] modules will receive a command. Check Module scanner on how to get serial.  </p>"},{"location":"modules/legacy-x4/#general-functions","title":"General functions","text":"<p>Each module library contains an API to access its functionality.</p> Communicating with module<pre><code>// Read distance from sensor\nint distance = module.getMM();\n// Set RGB color to green\nmodule.rgb.color(0, 255, 0);\n</code></pre>"},{"location":"modules/legacy-x4/#events","title":"Events","text":"<pre><code>#include &lt;TotemModule15.h&gt;\n#include &lt;TotemModule22.h&gt;\nTotemModule15 mod15;\nTotemModule22 mod22;\n\nvoid moduleEvt(int evt) {\n  if (evt == TotemModule22::evtTemp) printf(\"Temp: %fC\\n\", mod22.getTempC());\n  if (evt == TotemModule15::evtButtonA) printf(\"ButtonA: %d\\n\", mod15.getButtonA());\n  if (evt == TotemModule15::evtButtonB) printf(\"ButtonB: %d\\n\", mod15.getButtonB());\n  if (evt == TotemModule15::evtButtonC) printf(\"ButtonC: %d\\n\", mod15.getButtonC());\n  if (evt == TotemModule15::evtKnobA) printf(\"KnobA: %d\\n\", mod15.getKnobA());\n  if (evt == TotemModule15::evtKnobB) printf(\"KnobB: %d\\n\", mod15.getKnobB());\n  if (evt == TotemModule15::evtKnobC) printf(\"KnobC: %d\\n\", mod15.getKnobC());\n}\n\nvoid setup() {\n  mod15.addEvent(moduleEvt);\n  mod22.addEvent(moduleEvt);\n  // Call required functions once to receive\n  // values and start broadcasting\n  mod22.getTempC();\n  mod15.getButtonA();\n  mod15.getButtonB();\n  mod15.getButtonC();\n  mod15.getKnobA();\n  mod15.getKnobB();\n  mod15.getKnobC();\n}\nvoid loop() {\n\n}\n</code></pre> <p>Reading module functions like <code>module.get()</code> will always return cached value without blocking the code. This value is constantly updated in background with broadcast messages from module. Code blocks shortly whem calling \"get\" function first time - to register an event and return value.</p> <p>Using <code>addEvent</code> function is only useful if you need a callback when latest value update from module is received. Events are called only if value has changed compared to last one.</p> <p>Register module event function. Will be called when new data is available. Event data can be received simply by accessing <code>module</code>. Data is cached and won't initiate read request, but must be called inside registered function. Parameter: <code>function</code> - void moduleEvt(int evt)  </p>"},{"location":"modules/legacy-x4/#addEvent","title":"module.addEvent(<code>function</code>)","text":""},{"location":"modules/legacy-x4/#multiple-modules-example","title":"Multiple modules example","text":"<p>Simple code example to show usage of Line Follower + Potentiometer modules and interaction between them. \u2022 Knob A - controls LED position on Line Follower \u2022 Knob B - controls RGB color \u2022 Knob C - controls RGB color <pre><code>#include &lt;TotemModule14.h&gt;\n#include &lt;TotemModule15.h&gt;\n// Declare modules\nTotemModule14 line; // Line follower module\nTotemModule15 pot;  // Potentiometer module\n// Start program\nvoid setup() {\n  // Empty\n}\n// Loop program\nvoid loop() {\n  // Read Potentiometer module knob positions\n  int knobA = pot.getKnobA();\n  int knobB = pot.getKnobB();\n  int knobC = pot.getKnobC();\n  // Display Knob A position on Line Follower module\n  line.led.off();\n  line.led[map(knobA, 0, 255, 0, 7)].on(); // map [0:255] -&gt; [0:7]\n  // Change RoboBoard X4 RGB color depending on Knob B, C positions\n  RGB.color(\n    255-knobB, knobC, 255-knobC // red, green, blue\n  );\n  // Delay 20 milliseconds\n  delay(20);\n}\n</code></pre></p>"},{"location":"modules/legacy-x4/#module-scanner","title":"Module scanner","text":"<p>API to scan for TotemBUS modules. Can be used to get list of connected TotemBUS modules and their information (number and serial).  </p> <pre><code>#include &lt;TotemModule11.h&gt;\nvoid setup() {\n  Serial.begin(115200);\n}\nvoid loop() {\n  // Try to find any module on the TotemBUS\n  if (TotemX4Module::find()) {\n    // Print found module\n    Serial.printf(\"Found. Number: %d, Serial: %d\\n\", TotemX4Module::foundNumber, TotemX4Module::foundSerial);\n  }\n  else {\n    Serial.println(\"Not found\");\n  }\n  delay(1000); // Wait 1s\n}\n</code></pre> <p>Try to find module on TotemBUS network. Available request types: \u2022 all modules \u2022 modules matching specified number \u2022 module matching specified number and serial Result can be acquired with <code>TotemX4Module::foundNumber</code> and <code>TotemX4Module::foundSerial</code>. Parameter: <code>number</code> - module number [<code>0</code>:<code>255</code>]. <code>0</code> - all modules <code>serial</code> - module serial [<code>0</code>:<code>32767</code>]. <code>0</code> - ignore serial Returns: <code>found</code> - <code>true</code> if module has been found  </p> <p>Found module number.  </p> <p>Found module serial.  </p>"},{"location":"modules/legacy-x4/#find","title":"<code>found</code> TotemX4Module::find(<code>number</code>, <code>serial</code>)","text":""},{"location":"modules/legacy-x4/#foundNumber","title":"TotemX4Module::foundNumber","text":""},{"location":"modules/legacy-x4/#foundSerial","title":"TotemX4Module::foundSerial","text":""},{"location":"products/","title":"Robotic kits","text":"Mini Trooper Mini Shooter Gripper Bot Black Spider RoboCar Chassis Truck Top Retro Top Robotics Kit 4WD Car Hockey Bot Larva mobile Lift mobile Lucas robot Mini Spider Dog Giraffe T-Rex"},{"location":"products/#mini-lab","title":"Mini Lab","text":"Mini Lab Micro Lab LabBoard TotemDuino IO panel Sensor panel Audio panel Side Panel Stand Grove Beginners rack Grove Module rack"},{"location":"products/#tools","title":"Tools","text":"Board PRO-cutter Beam PRO-cutter Beam cutter Board cutter Screwdriver Wrench"},{"location":"products/beam-cutters/","title":"Beam Cutters","text":"<p>Cut required length Totem plastic beams with specifically designed tools. Available 40cm beam packs are perfect for making customized projects.  </p> <p>Note: This is not a toy and is intended for use by or under the supervision of adults.</p> <p>Totem offers two cutting solutions:  </p> <ul> <li> <p>Beam Cutter TM-TT-03      \u2022 getting started \u2022 more versatile </p> </li> <li> <p>Beam PRO-Cutter TKM-EPC      \u2022 clean cuts \u2022 extensive use</p> </li> </ul>"},{"location":"products/beam-cutters/#beam-cutter","title":"Beam cutter","text":"<p>A simple Tools Kit based on saw cutter and beam holder:</p> <ul> <li>Attaches to the table and stable while cutting.</li> <li>Adaptable for left and right handed users.</li> <li>Contains a ruler for consistent sizes to be cut.</li> <li>Used for 1 cm step cutting, but you can also cut and 0.5 cm.</li> <li>Uses interchangeable  Dremel MS53 Moto-Saw blades.</li> </ul> <p> </p>"},{"location":"products/beam-cutters/#pro-cutter","title":"PRO-Cutter","text":"<p>Advanced cutting tool designed specifically for Totem beams. Makes clean and easy cuts with simply press of the handle.</p> <p> TKM-EPC |  STL files</p> <ul> <li>Contains ruler for 1 cm step cutting.</li> <li>Easy to cut - almost no force needed.</li> <li>Adaptable for left and right handed use.</li> <li>Precise and clean cut.</li> </ul> <p>Note: Make sure to fit pins of the cutter into the grid of the Beam.</p>"},{"location":"products/beam-cutters/#strip-bracket-cutting","title":"Strip Bracket Cutting","text":"<p>Totem tools can be also used to cut aluminium strip brackets.</p> <p>Note: Pliers or any hacksaw for cutting metal can be also used instead.</p> <p> </p>"},{"location":"products/beam-cutters/#rod-cutting","title":"Rod Cutting","text":""},{"location":"products/beams/","title":"Beams","text":"<p>Main structural part of Totem building system. Contains holes for bracket and nut mounting.</p> <ul> <li> <p>Black TM-BM1-20 </p> </li> <li> <p>Blue TM-BM5-20 </p> </li> <li> <p>Light Blue TM-BM3-20 </p> </li> <li> <p>Copper TM-BM2-20 </p> </li> <li> <p>Green TM-BM6-20 </p> </li> <li> <p>Red TM-BM4-20 </p> </li> <li> <p>Silver TM-BM7-20 </p> </li> </ul> <p>Material: ABS (plastic) |  STEP files Dimensions: L400 x H10 x H10 mm  </p> <p> </p> <ul> <li>Same size: All beams are (400x10x10) (except pre-cut ones sold in robotic kits).</li> <li>Cut beams: Use Totem Tools to shorten beams down to 1 cm (0.5cm possible).</li> <li>Pleasant to use: Lightweight plastic, easy to shape, but still makes sturdy structures.</li> <li>Reusable: Disassemble old projects and use to building new ones.</li> <li>Versatile: Special layout of slots and holes makes it great element to construct any shapes. Easy to expand structure, by adding other beam or board or any other element at any point on your project.</li> <li>Special nut: Totem Nut M3 6x10 stay in the structure of Beam before Bolts are tightened! Fits in both sides of the beam.</li> <li>Make it even stronger: Use aluminium Strip Bracket to make more resistant Beam. It perfectly fits into the track of the Beam.</li> </ul>"},{"location":"products/board-cutters/","title":"Board Cutters","text":"<p>Cut required size Totem plastic boards with specifically designed tools. Available 100x100cm BLACK and GREEN packs are perfect for making customized projects.  </p> <p>Note: This is not a toy and is intended for use by or under the supervision of adults.</p> <p>Totem offers two cutting solutions:  </p> <ul> <li> <p>Board Cutter TM-TT-01      \u2022 getting started \u2022 cost-effective</p> </li> <li> <p>Board PRO-Cutter TKM-OPC      \u2022 clean cuts \u2022 extensive use</p> </li> </ul>"},{"location":"products/board-cutters/#board-cutter","title":"Board Cutter","text":"<p>A simple Tool Kit based on retractable knife and specifically designed ruler:</p> <ul> <li>Ruler pins fits to Totem Board grid in 45\u00b0 or 90\u00b0 angles.</li> <li>Prevents moving around while cutting.</li> <li>Contains inlet for straight cuts.</li> </ul> <p>Tools are included in Totem Maker Kit and Totem XL Maker Kit. Other Totem kits provide pre-cut beams - check before purchasing.</p> <p>We recommend to use a cutting mattress or any kind of cutting board.</p>"},{"location":"products/board-cutters/#board-pro-cutter","title":"Board PRO-Cutter","text":"<p>Advanced Totem Board cutting tool for safe, clean and extensive use.</p> <ul> <li>Safe to use (no exposed blades)</li> <li>Cut in a single press of the handles</li> <li>Nice and clean 90\u00b0 angle cuts</li> <li>Has a ruler for 5mm steps</li> <li> STL files are available</li> </ul> <p>Note: Make sure to fit pins of the cutter into the grid of the Board! Can't insert at 45\u00b0 angle!</p>"},{"location":"products/boards/","title":"Boards","text":"<p>Totem Boards can be used as structural part or to cover empty spaces.</p> <ul> <li> <p>Black 30x100mm TM-PB3-10 </p> </li> <li> <p>Black 100x100mm TM-PB1-10 </p> </li> <li> <p>Green 100x100mm TM-PB2-10 </p> </li> </ul> <ul> <li>Usage: to cover something, decoration, making boxes, basis for mounting electronics.</li> <li>Cutting: use Board Cutter for 90\u00ba or 45\u00ba degrees angle.</li> <li>Size: 30x100mm and 100x100mm, (thickness) 2mm, (hole distance) 5mm.</li> <li>Material: PC/ABS (plastic).</li> <li>Colors: black and green.</li> <li>CAD:  STEP files.</li> </ul> <p> </p> <p></p>"},{"location":"products/brackets/","title":"Brackets","text":"<p>Totem Brackets connect Beams together and are used for mounting third-party components. Multiple shapes and angles are available along with 3D  STEP files.</p>"},{"location":"products/brackets/#strip-bracket","title":"Strip bracket","text":"<p>Strip bracket |  TM-BR15-4 |  STEP files Material: 6061 aluminium, anodized surface. Dimensions (mm): 200 x 6 x 2 mm. Can be cut to required length: Strip Bracket Cutting </p> <p></p>"},{"location":"products/brackets/#2-hole-brackets","title":"2-hole brackets","text":"<p>Use to connect beams together in 0\u00b0, 45\u00b0, 90\u00b0 angles.</p> <ul> <li>Round holes: Makes more sturdy connections.</li> <li>Oblong holes: Allows for precise adjustment.</li> </ul>"},{"location":"products/brackets/#2-hole","title":"2-hole","text":"<ul> <li> <p>2-hole simple  TM-BR1-20 </p> </li> <li> <p>2-hole  TM-BR11-20 </p> </li> </ul> <p> STEP 2-hole simple |  STEP 2-hole</p> <p></p>"},{"location":"products/brackets/#2-hole-45","title":"2-hole 45\u00b0","text":"<ul> <li> <p>2-hole 45\u00b0 simple  TM-BR2-20      \u2022 Use with Single side filler </p> </li> <li> <p>2-hole 45\u00b0  TM-BR10-20      \u2022 Use with Double side filler </p> </li> </ul> <p> STEP 2-hole 45 simple |  STEP 2-hole 45</p> <p> </p>"},{"location":"products/brackets/#2-hole-90","title":"2-hole 90\u00b0","text":"<ul> <li> <p>C-bracket  TM-BR13-20 </p> </li> <li> <p>2-hole 90\u00b0  TM-BR9-20 </p> </li> </ul> <p> STEP C-bracket |  STEP 2-hole 90</p> <p>Build 90\u00b0 connections:</p> <p></p> <p>Make sturdy corners - no brackets are sticking out of the frame:</p> <p></p> <p>Make more complex connections - no brackets are sticking out of the frame:</p> <p></p>"},{"location":"products/brackets/#l-brackets","title":"L brackets","text":"<p>Use for opposite side beam and external components mounting.</p>"},{"location":"products/brackets/#l-bracket","title":"L-bracket","text":"<p>L-bracket |  TM-BR3-20 |  STEP file</p> <p>Build 90\u00b0 connections with adjustable position.</p> <p></p>"},{"location":"products/brackets/#l-twisted","title":"L-twisted","text":"<ul> <li> <p>L-twisted  TM-BR4-20 </p> </li> <li> <p>L-twisted mirror  TM-BR4M-20 </p> </li> </ul> <p> STEP L-twisted |  STEP L-twisted mirror</p> <p>Build opposing side 90\u00b0 connections with adjustable position.</p> <p></p>"},{"location":"products/brackets/#l-twisted-adjustable","title":"L-twisted adjustable","text":"<ul> <li> <p>L-twisted adjustable  TM-BR14-20 </p> </li> <li> <p>L-twisted adj. mirror  TM-BR14M-20 </p> </li> </ul> <p> STEP L-twisted adjustable |  STEP L-twisted adjustable mirror</p> <p>Handy for mounting electronics that don't follow Totem construction system spacing.</p> <p></p>"},{"location":"products/brackets/#45x90-brackets","title":"45x90 brackets","text":"<p>Use for 45\u00b0 angle beam mounting. Oblong holes makes connection adjustable.</p>"},{"location":"products/brackets/#swan-90x45","title":"Swan 90x45","text":"<ul> <li> <p>Swan 90x45  TM-BR5-20 </p> </li> <li> <p>Swan 90x45 mirror  TM-BR5M-20 </p> </li> </ul> <p> STEP Swan 90x45 |  STEP Swan 90x45 mirror</p> <p></p>"},{"location":"products/brackets/#45x90","title":"45x90","text":"<ul> <li> <p>45x90  TM-BR8-20 </p> </li> <li> <p>45x90 mirror  TM-BR8M-20 </p> </li> </ul> <p> STEP 45x90 |  STEP 45x90 mirror</p> <p></p>"},{"location":"products/brackets/#3-hole-bracket","title":"3-hole bracket","text":"<p>Use for additional mounting options. Oblong holes makes connection adjustable.</p> <ul> <li> <p>3-hole  TM-BR6-20      \u2022 For mounting Standard Servo Motors </p> </li> <li> <p>3-hole 45  TM-BR7-20      \u2022 Use with Double side filler </p> </li> </ul> <p> STEP 3-hole |  STEP 3-hole 45</p> <p>Connect 3 Beams with one bracket:</p> <p> </p>"},{"location":"products/brackets/#plastic","title":"Plastic","text":"<p>Plastic bracket alternative. Use together with Screw M3x7.5.</p> <ul> <li>Faster building time. Nuts are not required.</li> <li>Many variations available for 3D printing  STL files.</li> <li>Structure weights less. Similar sturdiness compared to metal brackets.</li> </ul>"},{"location":"products/brackets/#plastic-bracket","title":"Plastic bracket","text":"<ul> <li> <p>Plastic bracket  TM456      \u2022 For building Totem racks </p> </li> <li> <p>Snap op bracket  TM457      \u2022 Mount Grove, Arduino, Raspberry boards  </p> </li> </ul> <ul> <li>Plastic bracket - use for general Totem structure building and as replacement for metal brackets. Used in Totem Rack for Grove Beginner Kit.</li> <li>Snap op bracket - use for attaching Groove modules to Totem structure. Modules easily snaps on. Used in Totem Rack for Grove Modules and Arduino/Raspberry.</li> </ul> <p>For more details see:  Totem Groove rack instructions.</p> <p></p> <p>Mount brackets to the rack with M3 bolts and then conveniently snap on the Grove modules, Arduino and/or Raspberry PCBs (use M2.5x8 screw).</p> <p> </p>"},{"location":"products/brackets/#single-side-filler","title":"Single side filler","text":"<p>Single side filler |  TM-PL2-20</p> <p>Material: ABS/PC plastic. Usage: For improved visual and structure integrity or 45\u00b0 degree connections. Brackets: 2-hole 45 simple, 45x90 bracket.  </p> <p>Note: connection type differs from Double side filler.</p> <p>Use with 2-hole 45 simple bracket:</p> <p></p> <p>Use with 45x90 bracket:</p> <p></p>"},{"location":"products/brackets/#double-side-filler","title":"Double side filler","text":"<p>Double side filler |  TM-PL1-20</p> <p>Material: ABS/PC plastic. Usage: For improved visual and structure integrity or 45\u00b0 degree connections. Brackets: Swan 90x45, 2-hole 45, 3-hole 45.  </p> <p>Note: connection type differs from Single side filler.</p> <p></p> <p>Use with 2-hole 45 bracket:</p> <p></p> <p>Use with 3-hole 45 bracket:</p> <p></p>"},{"location":"products/fasteners/","title":"Fasteners","text":""},{"location":"products/fasteners/#regular-bolts","title":"Regular bolts","text":"<ul> <li>Bolt M3x6  TM-BL6-100 </li> <li>Bolt M3x8  TM-BL8-100 </li> <li>Bolt M3x10  TM-BL10-50 </li> <li>Bolt M3x12  TM-BL12-50 </li> <li>Bolt M3x14  TM-BL14-50 </li> <li>Bolt M3x16  TM-BL16-50 </li> <li>Bolt M3x20  TM-BL20-50 </li> <li>Bolt M3x25  TM-BL-25-50 </li> <li>Bolt M3x35  TM-BL35-20 </li> <li>Bolt M3x45  TM-BL45-20 </li> </ul> <p>Material: 8,8 grade steel, Zn plating. | Size: 3 mm x 6-45 mm. |  STEP files</p> <p>Often used bolt with for tightening Totem construction system. Available in multiple lengths. Has machine screw thread and used together with threaded nuts.  </p>"},{"location":"products/fasteners/#screws","title":"Screws","text":"<ul> <li>Bolt M2.5x12 and M2.5x8  TM-BL128-4 \u2022 For Mini Servo Motor and Raspberry Pi </li> <li>Screw M3x7.5  TM998 \u2022 Self-tapping for plastic brackets </li> </ul> <p> STEP Bolt M2.5x12 (for servo arm)</p> <ul> <li>Bolt M2.5x12 and M2.5x8 - Screws for tightening arm to Mini Servo Motor and mounting Raspberry Pi to plastic bracket (it has smaller M2.5 holes).</li> <li>Screw M3x7.5 - Self-tapping screw for plastic brackets. Easier to use compared to bolts.</li> </ul> <p></p>"},{"location":"products/fasteners/#nuts","title":"Nuts","text":""},{"location":"products/fasteners/#regular-nuts","title":"Regular nuts","text":"<ul> <li>Nut M3 5.5x5.5  TM-NT55-50 \u2022 For Beam Plug or tight spaces </li> <li>Nut M3 6x10  TM-NT61-100 \u2022 For inserting into Totem Beam </li> <li>Lock nut M3  TM-NT02-30 \u2022 For tightening moving parts </li> </ul> <p>Material: 8,8 grade steel, Zn plating.  STEP Nut M3 5.5x5.5 |  STEP Nut M3 6x10 |  STEP Lock nut M3</p> <ul> <li>Nut 5.5x5.5 - for using with Beam Plug or tight spaces, where small footprint is required.</li> <li>Nut 6x10 - stays in the structure of Totem Beam before Bolts.</li> <li>Lock nut - prevents self-screwing. Used with free moving parts like axles and hinges.</li> </ul> <p> </p>"},{"location":"products/fasteners/#nylon-nut","title":"Nylon nut","text":"<p>Nylon nut M3 |  TM-NT1-50 |  STEP file</p> <p>Used together with Nylon standoff for tightening it to frame.</p> <p></p>"},{"location":"products/fasteners/#linear-nut","title":"Linear nut","text":"<p>Nylon Linear nut |  TM-RB-06-2 | Guide screw:  STEP file</p> <p>Comes with guide screws (2.2 x 4.5 mm) - 2 pcs.</p> <p></p>"},{"location":"products/fasteners/#spacers","title":"Spacers","text":""},{"location":"products/fasteners/#washers","title":"Washers","text":"<ul> <li>Nylon Washer M3 8x1 mm  TM-PL6-50 </li> <li>Metal Washer M3 9x0.8 mm  TM047-20 </li> </ul> <p> STEP Nylon Washer M3 8x1 mm |  STEP Metal Washer M3 9x0.8 mm </p> <p>Used for adding slight space between parts and reducing movement resistance.</p> <p></p>"},{"location":"products/fasteners/#nylon-spacers","title":"Nylon spacers","text":"<ul> <li>Nylon spacer 4mm  TM204-20 </li> <li>Nylon spacer 5mm  TM208-20 </li> <li>Nylon spacer 8mm  TM091-20 </li> </ul> <p> STEP Nylon spacer 4mm |  STEP Nylon spacer 5mm |  STEP Nylon spacer 8mm </p> <p>Used when added spacing is required.</p> <p></p>"},{"location":"products/fasteners/#nylon-standoff","title":"Nylon standoff","text":"<p>Nylon standoff M3 8mm |  TM-PL5-50 |  STEP file Dimensions: 6 x 14 mm. Thread: M3 x 6 mm.  </p> <p>Can be used with nylon nut or regular nuts. Handy for rising parts up or mounting electronics.</p> <p>Use Totem Wrench and Socket for tightening standoffs. </p> <p></p>"},{"location":"products/fasteners/#threaded-spacer","title":"Threaded spacer","text":"<p>Threaded nylon spacer M3 8mm |  TM-PL2-50 |  STEP file </p> <p>Used for adding spacing or mounting parts. Can be screwed from both sides with Regular bolts.</p> <p>Dimensions: A - 5.5 mm | C - M3 | L - 8 mm </p>"},{"location":"products/fasteners/#beam-plug","title":"Beam plug","text":"<p>Nylon Beam plug |  TM-RB-07-20 |  STEP file </p> <p></p>"},{"location":"products/motors/","title":"Motors","text":"<p>There are different types of motors which do not fit Totem grid, so we offer  STL and  STEP files of parts for transition from standard motors mounting holes to Totem grid.</p>"},{"location":"products/motors/#dc-motors","title":"DC motors","text":"DC 12V 400RPMDC 12V 245RPMDC 6V N20DC 6V TT (Yellow) <p>  Motor:  TM196 |  STEP file | Robotic Kit: RoboCar Chassis </p> <p>Power: 12V, 1.5A (stall) Speed: 400 RPM Shaft: 4mm (diameter), 10mm (length), D-Shape Wire: 150mm length, JST PH 2.0 Male connector  </p> Attachment Description RoboCar mounting bracket  STL file  Motor mounting for RoboCar kit Single beam mounting TM-3D1-1 |  STL file |  STEP file Shaft coupler 4-3 TM-RB-02-1  4mm - 3mm coupler to connect shafts 75mm wheel set TM-LWS |  STEP file (coupler)  4mm motor shaft wheel kit. <p> </p> <p></p> <p> Motor:  TM063 | Robotic Kit: Black Spider </p> <p>Power: 12V, 1.5A (stall) Speed: 245 RPM Shaft: 6mm (diameter), 15mm (length), D-Shape Wire: 150mm length, JST PH 2.0 Male connector  </p> Attachment Description Mounting bracket  STL file  For mounting motor to beams. 6mm shaft coupler TM046-K  Coupler to attach motor to gears. <p></p> <p></p> <p> TM207 |  STEP file | Robotic Kits: Mini Trooper, Gripper Bot, ...</p> <p>Power: 6V, 1.6A (stall) Speed: 400 RPM Gear: ratio 75:1 Shaft: 3mm (diameter), 15mm (length), D-Shape Wire: 150mm length, JST PH 2.0 Male connector Size: 10H x 12W x 24L mm</p> Attachment Description Bracket 2 V.3 TM-3D3-1 |  STL file |  STEP file  For mounting in front of the metal brackets with bolts sunken into surface. Bracket 2 V.1 TM-3D6-1 |  STL file |  STEP file  For mounting behind the metal brackets. Bracket 1 TM-3D2-1 |  STL file |  STEP file  Mounting bracket that moves around depending on shaft position. Shaft coupler 3-3 TM-RB-01-1  3mm - 3mm coupler to connect shafts Shaft coupler 4-3 TM-RB-02-1  4mm - 3mm coupler to connect shafts 43mm wheel TM187  |  STEP file  Rubber tread with plastic insert  Mounted directly on 3mm D-Shape motor shaft.  Size: 43 x 18 mm <p> </p> <p> </p> <p></p> <p> TM067 |  STEP file | Robotic Kit: 4WD car, Young engineering kits </p> <p>Power: 6V Gear: ratio 1:48 Shaft: 5mm (diameter), 10mm (length), Dual-Shape Wire: 150mm length, JST PH 2.0 Male connector  </p> Attachment Description Mounting bracket TM238-K |  STL file |  STEP file  For mounting motor perpendicular to beam. 67mm wheel TM186 |  STEP file  Rubber tread with plastic insert  Mounted directly on motor shaft. Other brackets (instruction)   STL bracket 1 |  STEP bracket 1  STL bracket 2 |  STEP bracket 2 <p> </p>"},{"location":"products/motors/#servo-motors","title":"Servo motors","text":"Standard ServoMini Servo <p> TM066 |  STEP file Arm:  STEP single |  STEP double</p> <p>Model: MG995, metal gear Voltage: 4.8 ~ 6.6v Rotation angle: 180\u00b0 Torque: 9.4kg/cm (4.8v); 11kg/cm (6v) Speed: 0.20sec/60\u00b0 (4.8v); 0.16sec/60\u00b0 (6v) Size: 39.5 x 20.5 x 40 mm, 55g (weight), 30cm (wire)  </p> <p> TM065 |  STEP file Arm:  STEP file</p> <p>Model: Mini, metal gear Voltage: 4.8 ~ 6.0v Rotation angle: 180\u00b0 Torque: 3.0kg/cm (4.8v); 3.5kg/cm (6v) Speed: 0.13sec/60\u00b0 (4.8v); 0.11sec/60\u00b0 (6v) Size: 29.5 x 11.6 x 30.2 mm, 17.5g (weight), 18cm (wire)  </p> <p> </p>"},{"location":"products/motors/#stepper-motors","title":"Stepper motors","text":"NEMA 8 stepper bracketNEMA 17 stepper bracket <p> TM-3D4-1 |  STL file |  STEP file</p> Attachment Description Shaft coupler 4-3 TM-RB-02-1  4mm - 3mm coupler to connect shafts 75mm wheel set TM-LWS |  STEP file (coupler)  4mm motor shaft wheel kit. <p> TM-3D5-1 |  STL file |  STEP file</p> <p> </p>"},{"location":"products/motors/#shaft-couplers","title":"Shaft couplers","text":"<p>Attachments, adapters for motor shafts and metal rods.</p> Motor coupler set 3-3Motor coupler set 4-3Motor shaft coupler 6mmE-Clip <p> TM-RB-01-1</p> <ul> <li>Used to extend metal rods. Material: copper.</li> <li>For connecting two 3 mm diameter shafts or axles.</li> <li>Comes with Tapper set bolts (4pcs.) and Hex Key.</li> </ul> <p> TM-RB-02-1</p> <ul> <li>Used to extend metal rods. Material: copper.</li> <li>For connecting 3 mm and 4 mm diameter shafts or axles.</li> <li>Comes with Tapper set bolts (4pcs.) and Hex Key.</li> </ul> <p> TM046-K</p> <ul> <li>Used to connect 6mm motor shaft to plastic gears.</li> <li>Comes with Tapper bolts M3X6 (2pcs.).</li> </ul> <p></p> <p> TM-RB-03-30 |  STEP file</p> <ul> <li>Groove diameter: 2.3 mm. Material: carbon steel.</li> <li>Designed to fit onto shafts and do not require special pliers or tools to fit.</li> <li>Used for locating or retaining components from sideways movement on the shaft.</li> </ul> <p></p>"},{"location":"products/motors/#attachment-kits","title":"Attachment kits","text":"Lead wheel setIdler wheel setCaster wheel kitMicro Gripper Kit <p> TM-LWS 12mm HEX coupler:  STEP file</p> <p>Wheel kit for mounting straight to 4mm motor shaft by locking position with the tapper bolt. Includes all required parts and a hex key.  </p> <p>Dimensions: 75 mm (diameter), 30 mm (width). Used in RoboCar Chassis kit.  </p> <p></p> <p> TM-IWS</p> <p>Free spin wheel kit with bearing barrel construction. Note: The construction is different from the one used in the RoboCar Kit! </p> <p>Dimensions: 75 mm (diameter), 30 mm (width). Includes required bearings, barrel and bolts.  </p> <p> </p> <p> TM342 |  STL files |  STEP files</p> <p>Wheel: 43 mm (diameter), 18 mm (width). Construction: ~7.5 cm (height). Mounts on Totem beam. Rotates around its axis. Used in Lucas Robot kit.  </p> <p></p> <p> TM331 |  STL files |  STEP files </p> <p>A simple solution for projects requiring small grippers (includes Mini Servo motor).</p> <p>Mounting: directly on Totem beam. Material: plastic. Wire Length: ~18.5 cm (including connector). Opening: 180 degrees. Used in Gripper Bot and Lucas Robot kits.</p> <p></p>"},{"location":"products/motors/#wheels","title":"Wheels","text":"43mm O-Shaft wheel43mm D-Shaft wheel67mm yellow wheel75mm wheel <p> TM233 |  STEP file</p> <ul> <li>Dimensions: 43 mm (diameter), 18 mm (width).</li> <li>Hole type: O-Shape (for free spin).</li> <li>Rubber tire with plastic rim.</li> </ul> <p> TM187 |  STEP file</p> <ul> <li>Dimensions: 43 mm (diameter), 18 mm (width).</li> <li>Hole type: D-Shape (mount on motor shaft).</li> <li>Rubber tire with plastic rim.</li> </ul> <p> TM186 |  STEP file</p> <ul> <li>Dimensions: 67 mm (diameter), 26.6 mm (width).</li> <li>Mounts directly on DC 6V TT (Yellow).</li> <li>Rubber tire with plastic rim.</li> </ul> <p> TM191 </p> <ul> <li>Dimensions: 75 mm (diameter), 30 mm (width).</li> <li>Mounting: 12mm HEX coupler:  STEP file</li> <li>Rubber tire with plastic rim.</li> <li>Lead and Idler wheel sets available.</li> </ul>"},{"location":"products/robotics-kits/","title":"Robotics Kits","text":"<p>Totem Robotics Kits contains all required parts to assemble model. Each one includes required tools, pre-cut parts and building instructions. Robots are based on programmable Totem RoboBoard, enabling remote  Smartphone control and  Arduino programming.  </p> <p></p> <p> Download Android APK</p>"},{"location":"products/robotics-kits/#roboboard-x3","title":"RoboBoard X3","text":"<p>Models based on RoboBoard X3. Designed for light and compact robots.</p>"},{"location":"products/robotics-kits/#mini-trooper","title":"Mini Trooper","text":"<p>Battle bot robot with active flipper. Also able to self-right when tipped over. Available in  Pack of 2 kit to play together and try to challenge each other.</p> <p> Assembly instructions TRK-MT1Y |  STL files |  STEP files |  Arduino examples</p>"},{"location":"products/robotics-kits/#mini-shooter","title":"Mini Shooter","text":"<p>Rubber bands shooter with adjustable height. Ingenious mechanism allows to store up to 5 rubber bands and shoot on demand.</p> <p> Assembly instructions TMK-MRSR |  STL files |  STEP files</p>"},{"location":"products/robotics-kits/#lady-bug","title":"Lady Bug","text":"<p>6-legged walking robot kit. Cute and playful looking.</p> <p> Assembly instructions TKR-LDB |  STL files |  STEP files</p>"},{"location":"products/robotics-kits/#roboboard-x4","title":"RoboBoard X4","text":"<p>Models based on RoboBoard X4. Designed for larger robots with more power.</p>"},{"location":"products/robotics-kits/#black-spider","title":"Black Spider","text":"<p>Walking robot based on principle invented by Joe Klann in 1994. Kit includes 1150+ parts and you will learn many cool mechanical principles that may be used in many other projects.</p> <p> Assembly instructions TKR-LSP |  STL files</p>"},{"location":"products/robotics-kits/#robocar-chassis","title":"RoboCar Chassis","text":"<p>Car platform with Ackermann steering for building your projects on top of it. Can be used with additional Truck Top, Retro Top for improved looks and building experience. RoboCar wheel base length: 197 mm, wheel tracking length: 175 mm.</p> <p> Assembly instructions TMK-RCC |  STL files |  Arduino examples</p>"},{"location":"products/robotics-kits/#truck-top","title":"Truck Top","text":"<p>Truck top complements the RoboCar chassis and makes it a proper constructor as the top is made out of 36 different parts, in total of more than 450 parts. The top is designed to not only give a more playful look to the RoboCar platform, but it also gives option to attach the extra parts.</p> <p> Assembly instructions TMK-RCTT |  STL files</p>"},{"location":"products/robotics-kits/#retro-top","title":"Retro Top","text":"<p>Retro top complements the RoboCar chassis and gives an old-school, safari truck look. Inspired by the iconic Willys Jeep from the 1950's and contains 496 parts of assembly.</p> <p> Assembly instructions TMK-RCWJ</p>"},{"location":"products/robotics-kits/#robotics-kit","title":"Robotics Kit","text":"<p>Engineering robotics kit to build 7 different models. Contains 1000+ building pieces, including motors and electronics. 7 mini models of real life robotic machines. Built models can be controlled using  Smartphone app or programmed with  Arduino IDE. Based on RoboBoard X3.</p> <p> TKR-RK1 |  Handbook </p>"},{"location":"products/robotics-kits/#gripper-bot","title":"Gripper Bot","text":"<p>Car with a controllable gripper arm. Can pick up small object and drive them around.</p> <p> Assembly instructions TMK-DMNNG |  STL files |  STEP files |  Arduino examples</p>"},{"location":"products/robotics-kits/#4wd-car","title":"4WD Car","text":"<p>Car with 4 independent wheel motors. Basic platform, that can be used to build upon.</p> <p> Assembly instructions TMK-4WDU</p>"},{"location":"products/robotics-kits/#hockey-bot","title":"Hockey Bot","text":"<p>Car with a retractable swinging arm that accumulates and later releases the energy by swinging the arm to kick the ball.</p> <p> Assembly instructions TKR-RK1 (Robotics Kit)</p>"},{"location":"products/robotics-kits/#lucas-robot","title":"Lucas Robot","text":"<p>Caster Wheel based robot, inspired by sci-fi movies. A true little robot, turns 360, grips and lifts.</p> <p> Assembly instructions TKR-RK1 (Robotics Kit)</p>"},{"location":"products/robotics-kits/#lift-mobile","title":"Lift Mobile","text":"<p>Uses scissor mechanism in a robotic lifting platform. Has 4 independent motors to move around.</p> <p> Assembly instructions TKR-RK1 (Robotics Kit)</p>"},{"location":"products/robotics-kits/#larva-mobile","title":"Larva Mobile","text":"<p>Inspired by the nature, inch-worm. This robot uses scissors principle shape shifting for movement.</p> <p> Assembly instructions TKR-RK1 (Robotics Kit)</p>"},{"location":"products/robotics-kits/#mini-spider","title":"Mini Spider","text":"<p>Small 6-legged walking robot. Can go forward, backwards and change directions.</p> <p> Assembly instructions TKR-RK1 (Robotics Kit) |  STL motor hub</p>"},{"location":"products/robotics-kits/#young-engineer-kits","title":"Young engineer kits","text":"<p>Walking robots based on single motor and battery. Entry level robotic kits (does not include RoboBoard!).</p>"},{"location":"products/robotics-kits/#t-rex","title":"T-Rex","text":"<p>Walking robot resembling a T-Rex dinosaur.</p> <p> Assembly instructions TKR-TRX |  STL motor hub  STL motor hub (T-Rex)  STEP motor hub (T-Rex) </p>"},{"location":"products/robotics-kits/#giraffe","title":"Giraffe","text":"<p>Walking robot resembling a giraffe.</p> <p> Assembly instructions TKR-GRF |  STL motor hub  STL motor hub (Dog, Girrafe)  STEP motor hub (Dog, Giraffe) </p>"},{"location":"products/robotics-kits/#dog","title":"Dog","text":"<p>Walking robot resembling a dog.</p> <p> Assembly instructions TKR-DG |  STL motor hub  STL motor hub (Dog, Girrafe)  STEP motor hub (Dog, Giraffe) </p>"},{"location":"products/screwdrivers/","title":"Screwdrivers","text":"<ul> <li> <p>Magnetic TM-TT-02      Magnetic screwdriver for Totem bolts</p> </li> <li> <p>Phillips 2mm TM154      For screwing in N20 motors to bracket.</p> </li> <li> <p>Wrench TM360      For tightening nuts and lock nuts.</p> </li> </ul>"},{"location":"products/screwdrivers/#totem-wrench","title":"Totem Wrench","text":"<p>Small Totem Wrench for tightening nuts and standoffs or holding them in place. Additional plastic Socket Wrench is handy in certain situations.</p> <p></p>"},{"location":"products/screwdrivers/#phillips-screwdriver","title":"Phillips screwdriver","text":"<p>Use Phillips screwdriver for attaching Bracket 2 V.3 to N20 motor.</p> <p></p>"},{"location":"products/screwdrivers/#totem-screwdriver","title":"Totem Screwdriver","text":"<p>Totem designed hex screwdriver with ergonomic design and strong magnetic grip. Makes handling easy by firmly holding bolt in place.</p> Totem Screwdriver magnet <p>Push nuts into beam with help of the screwdriver. Use your fingers to enter the first rectangular slot. Then push the nut in, using the back of the screwdriver. The nut almost always tilts, so use your finger to straighten it. Then push it all the way in.</p> How to push in the nuts <p>When you get the hang of it, try pushing the nut holding the screwdriver in an angular position, like it is shown in the picture. That way you avoid tilting problem.</p> Single push <p>What about getting them out? Use the tip (hex bit) of the screwdriver to push the nut out 2/3 of the slot. Then pull the nut by the thread.</p> How to push the nuts out"},{"location":"products/mechanics/","title":"Mechanics","text":"<p>In Totem Mechanics we use metal fasteners (Bolts and Nuts), because they make the structure more robust. It is slightly more complicated, but with more possibilities. We chose to have PC/ABS plastic parts as a main structure (Beams and Boards) because of their customization possibilities.</p> <p>Makers have all kinds of motors, PCB\u2019s, batteries, half made projects, lying around. It is frustrating, because mounting holes of components almost never match. Plastic parts are much more suitable to overcome this issue, because they are easier to modify and adjust.</p>"},{"location":"products/mechanics/#light-weight","title":"Light weight","text":"<p>Having light weigh parts can be a direct indicator of how well the model will work. Let\u2019s say one is building robotic arm. The lighter the construction, the less stress for the motors, the heavier object it will be able to lift. Same thing for walking robots, or drones!</p>"},{"location":"products/mechanics/#fasteners","title":"Fasteners","text":"<p>In the first image, you can see the sandwich of fasteners. The bolt and the nut presses the Bracket and the Beam, as a result, friction holds them together. The wall of the Beam, Bracket and Nut is 2mm thickness each. The bolt has to reach the end of the nut, so 2mm + 2mm + 2mm = 6mm and that is why, in this example, we use 6mm length bolt. We have more different bolt lengths, if the \"sandwich\" is thicker.</p> Sandwich of fasteners"},{"location":"products/mechanics/#beam","title":"Beam","text":"<p>Our main structural part is Totem Beam. The Beam has a patented design which makes Totem building system unique. Rectangular holes are for nuts and brackets. All rectangular holes are the same size, so nuts and brackets can be mounted on any side.</p> Mirrored bracket mounting <p>Brackets (not all of them) can also be mounted on the side of the Beam (using the channel of the Beam, instead of rectangular holes). More about brackets is explained further down below.</p> Bracket mounted in the channel of the Beam <p>Sometimes brackets occupy both opposite holes. In that case, the nut goes horizontally, and 8mm bolt fastens them together. The step of rectangular holes is 10mm.</p> Occupied rectangular holes <p>Bolts always go through circular holes of the Beam. They are at every 5mm or \"half step\" of rectangular holes. If the circular hole is in line with the rectangular hole, the nut goes to rectangular slot. If the circular hole is in \"half step\", the nut goes horizontally, on the side of the beam.</p> Nut positioning"},{"location":"products/mechanics/#board","title":"Board","text":"<p>Totem Boards are also structural parts. They have a grid of holes of 5mm. And it is 2mm thickness (same as Beam walls, Brackets and Nuts). Totem Boards can be cut using Board Cutter at 90\u00ba or 45\u00ba degrees angle.</p> Totem Board"},{"location":"products/mechanics/#brackets","title":"Brackets","text":"<p>Totem Brackets connect Beams together. We wanted Totem to be versatile for many projects, that\u2019s why we have so many different types of Brackets. Brackets can also hold PCB\u2019s, motors, 3D printed parts, Boards, sensors etc. Brackets with circular holes keep Beams in 5mm or 10mm order. When the structure needs to go \"off the Grid\", use brackets with oblong holes. For example, when mounting third party components, like Arduino electronic boards. They may not have their mounting holes in 5mm or 10mm grid, so oblong holes let the structure adapt to the PCB.</p> Oblong holes vs circular"},{"location":"products/mechanics/#screwdriver","title":"Screwdriver","text":"<p>This is not a \"slightly\" magnetic screwdriver (like many others). Totem Magnetic screwdriver is powered by neodymium 52 grade magnet.</p> Totem Screwdriver magnet <p>Not only the screwdriver is a tool for bolts, but for the nuts as well. Use your fingers to enter the first rectangular slot. Then push the nut in, using the back of the screwdriver. The nut almost always tilts, so use your finger to straighten it. Then push it all the way in.</p> How to push in the nuts <p>When you get the hang of it, try pushing the nut holding the screwdriver in an angular position, like it is shown in the picture. That way you avoid tilting problem.</p> Single push <p>What about getting them out? Use the tip (hex bit) of the screwdriver to push the nut out 2/3 of the slot. Then pull the nut by the thread.</p> How to push the nuts out"},{"location":"products/mechanics/#straight-structure","title":"Straight structure","text":"<p>\"The structure I built is not straight\"</p> <p>There are a few causes for bent structures:</p> <p>1) Ends of beams are not straight</p> <p></p> <p>This is an obvious one, but it is worth mentioning. PLEASE DO NOT USE THIRD PARTY CUTTING TOOLS. Some of our customers tried using hacksaw for metal they had at home. It is not good for beam cutting. The blade is 0,55-0,8mm thickness and they usually do not have support both for the beam and the blade. We strongly recommend using Totem cutting tools.</p> Beam Cutter <p>The blade is only 0,2mm thick, so it is three times more accurate. The Beam Cutter has a blade support and there is a Beam holder with pins, holding the Beam tight. However, the blade does wear out, and it needs to be replaced from time to time. The cut is always straighter with a sharp blade.</p> <p>2) Fasteners are over-tightened</p> Over-tightened structure <p>Over-tightened fasteners deform plastic parts like Beam and Board. You also don\u2019t want to have a flimsy structure, so how to know, how much torque is enough? The best way to find out is to perform an experiment. Tighten the bolt as much, as you can. It will  start to deform the bracket or the beam, or the head of the bolt. Now you know what is too much. Tighten the bolt at approximately 70 percent of full torque. It will be good for most of the times.</p> <p>3) Closed geometry design To ensure straightness of the structure, it is a good idea to make closed geometry design (when possible). As an example, our Side Panel Stand and Mini Lab. There are no loose ends, and structures are made of either rectangles or triangles.</p>"},{"location":"products/mechanics/#tailor-to-your-project","title":"Tailor to your project","text":"<p>We made Totem structural parts to be customized. The Beam is 40 cm length and the builder can cut to shorter parts at every 1 cm. Made a mistake? No worries, just cut another one! Totem Board is 10 cm x 10 cm and it can be cut at every 5 mm (even at 45 degrees). We designed specialized tools for beam and board cutting. Fast and easy cut!</p> <p>Other cutting tools are handy as well. Drill a hole for larger diameter bolts, shaft or an axle. Use cutting pliers if there is a corner sticking out. Combine this with Totem adjustable brackets and you get lots of mounting options.</p> Drilled 4mm holes"},{"location":"products/mechanics/#press-fit-connections","title":"Press fit connections","text":"<p>Next big advantage of Totem plastic beam is the ability to have a press fit connection for nuts and brackets. When they enter the slots, beam walls hold inserted parts. Combine this feature with the Totem magnetic screwdriver and forget about the hassle of constant dropping parts on the floor.</p> Press fit Nuts and Brackets"},{"location":"products/mechanics/#more-freedom-to-design","title":"More freedom to design","text":"<p>Most hobby construction systems have a grid. As long as one needs 90 degree connection, they all work. But what happens when the model needs 45 degrees angle or 60? It is very likely, parts will no longer match.</p> <p>Totem beams and boards give the ability for mounting holes to be shifted. Most of the times, there is only 1-2 mm miss-match. That is a lot for metal, but plastic parts can be bent or twisted. Take a look at the picture below. The drawing shows assuming parts are totally straight. It is very clear, the bottom connection is off the grid. The picture on the right, shows real assembly of Totem parts. All connections look perfect. If parts could not be deformed, the design would be very limited due to grid restrictions.</p> Model vs. real assembly"},{"location":"products/mechanics/#make-stronger-structures","title":"Make stronger structures","text":"<p>1st method - using triangle support structures. One of the methods would be to use triangle support constructions. Triangles are the fundamental building blocks of many contemporary structures. Their strong, inflexible structure makes them perfect for contemporary designs. They are used in architecture and construction to create structures that will bear a certain amount of weight but still have material strength limits. Just by adding diagonal beam through the middle of a square you are effectively turning the structure into two triangles and eventually making it stronger.</p> Triangle structure in Totem Mini Lab rack <p>2nd method - using strip brackets. Another method is to use aluminium strip brackets fixed inside of the beams or to the board. Find a weak spot in your structure and depending on the situation use one-sided or double-sided mount (double-sided fixture compared to one-sided is stronger but heavier). To keep them in place you will need few bolts and nuts. Just keep in mind that this method will block beam\u2019s slots, so use it wisely.</p> Strip bracket added to totem beam <p>3rd method - using 3D printed parts. To achieve even stronger structures you can consider using 3D printed parts. One of the options is the \"Magic Cross\" ( STL file). It is meant to be used in between 4 beams with an easy fix of few bolts and nuts. The part will significantly reduce twisting and bending forces while still leaving possibilities to join parts in 5 different directions.</p> <p></p> <p>We set up a stress test to show how each method acts in the same conditions. Beams are fixed to the table with 20 cm shoulder hanging in the air. On the end we attached bag of nuts that weights 0.5 kg (~630 pieces). For this test we used beam without any extra parts (1), beam with strip brackets fixed on one side (2), beam with strip brackets fixed on two sides (3) and assembly made with \"Magic Cross\" connections (4). You can see how each of the participants resists the bending force in the pictures below.</p> <p></p>"},{"location":"products/mechanics/#mounting-electronics","title":"Mounting electronics","text":"<p>Totem mechanics is all about user-friendliness. Unique Beam design makes it easy to mount all brands of electronics  at any point of the project. The provided example gives the clear understanding of how the Totem system works. Arduino in this case is used, however it can be any other electronics brand, including Totem.</p> <p>Parts needed:</p> <ul> <li>Bolts M3x6</li> <li>Nuts M3 6x10</li> <li>Nuts M3 5.5x5.5</li> <li>Nylon Standoffs</li> <li>Adjustable Brackets (like 3-hole bracket, L-bracket)</li> </ul> <p>Note: Totem fasteners are M3 standard. Raspberry Pi has \u22052.5mm holes so M2.5x8 screw and snap on bracket is required.</p>"},{"location":"products/mechanics/#aesthetics","title":"Aesthetics","text":"<p>Some people may say, plastic parts look cheaper than aluminium. We think that is not necessarily true. We believe it is more important how they are made and what benefits do they give. Color anodized aluminium can be scratched, and pretty soon they look old and used. Totem plastic material isn\u2019t painted, the color fills all of the plastic, and a scratch isn\u2019t particularly visible.</p> Scratched anodized aluminium"},{"location":"remote-control/","title":"Remote control","text":"<p>Totem products can be controlled remotely (wired and wireless) from other devices or development platforms. We are adding interfaces for more flexible ways to integrate Totem products into your custom projects.  </p>"},{"location":"remote-control/#interfaces","title":"Interfaces","text":"<p>Different ways to connect to X3 and X4 boards. Click on selected interface for more information.  </p> <ul> <li>Arduino - Control with any ESP32 (BLE capable) product using Arduino.  </li> <li>Totem App - Control robots using mobile Totem App.  </li> <li>BBC Micro:bit - Control robots remotely using BBC Micro:bit.  </li> <li>PS3/PS4 controller - Control using PS3 or PS4 remote controller.  </li> </ul>"},{"location":"remote-control/microbit/","title":"BBC micro:bit","text":"<p>Guide for Totem RoboBoard remote control using BBC micro:bit and MakeCode.</p> <p>How it works?</p> <ul> <li>micro:bit <code>bluetooth uart service</code> starts BLE server.</li> <li>RoboBoard connects <code>bluetooth uart service</code> (advertised by micro:bit).</li> <li>Block <code>bluetooth uart write number</code> is used to constantly send A and B button state.</li> <li>RoboBoard intercepts pressed buttons in <code>void microbitOnWrite(String data)</code>.</li> <li>Function <code>void microbitWriteString(String data)</code> can be used to send data back to micro:bit (intercepted by <code>bluetooth on data received</code> block).</li> </ul>"},{"location":"remote-control/microbit/#setup-microbit","title":"Setup micro:bit","text":"<p>Download provided MakeCode project to micro:bit.</p> <p>Note: make sure \"No Pairing Required\" is selected inside  <code>Settings</code> -&gt;  <code>Project Settings</code>.</p> <p></p>"},{"location":"remote-control/microbit/#setup-roboboard","title":"Setup RoboBoard","text":"<p>Upload example code to RoboBoard: Microbit_Controller.ino Note: Example is made for Totem MiniTrooper but can be adapted to other robots.</p> Functions<pre><code>// Should be called inside setup()\n// Establishes connection to micro:bit\nvoid microbitBegin();\n\n// Send number or string to micro:bit\n// Will be received inside [bluetooh on data received] block\nvoid microbitWriteString(String data);\n\n// Receive data sent from micro:bit [bluetooth uart write] block\n// [number] [string] [line] blocks are available, but they all send\n// string (text) of certain length.\nvoid microbitOnWrite(String data) {\n  int length = data.length(); // Get number of characters transmitted\n  int number = data.toInt();  // Convert received message to number\n  Serial.println(string);     // Print received message to Serial Monitor\n}\n</code></pre> <p>Check Arduino String reference for more functionality.</p>"},{"location":"remote-control/microbit/#connection","title":"Connection","text":"<ol> <li>Power on BBC micro:bit</li> <li>Power on RoboBoard (MiniTrooper)</li> <li>Press A + B buttons to control robot.</li> <li>Press RoboBoard X3 BOOT button to send it's state to micro:bit display.</li> </ol> <p>Note: micro:bit tends to restart when plugged to PC. Power on MiniTrooper after micro:bit.</p>"},{"location":"remote-control/ps-controller/","title":"Using PS3/PS4 controller","text":"<p>Totem robots can be controller using PS3 or PS4 wireless controllers. This tutorial contains set-up instructions required to use with RoboBoard.</p>"},{"location":"remote-control/ps-controller/#how-it-works","title":"How it works","text":"<p>Controller communicates directly with ESP32 MCU using Arduino libraries PS3 Controller Host, PS4Controller. They provide API to read controller buttons, control leds, vibration, etc.</p> <p>When PS button is pressed, controller tries to connect device with MAC address stored in its memory. ESP32 presents itself with this address and accepts connection. For this reason, a setup of same MAC address for controller and ESP32 is required.</p>"},{"location":"remote-control/ps-controller/#install-library","title":"Install library","text":"<p>A third party Arduino library is required to compile the code to use with controller. Select install instructions depending on controller. Both of them can be installed also.  </p> PS3 Controller Host (click to expand) Arduino IDEPlatformIO <ol> <li>Select <code>Sketch</code> \u2192 <code>Include Library</code> \u2192 <code>Manage Libraries..</code>.  </li> <li>In search field type <code>PS3 Controller Host</code>.  </li> <li>Select library <code>PS3 Controller Host</code> from the list and click Install.  </li> <li>Close the window when installation is finished.  </li> </ol> <ol> <li>Click PlatformIO icon in sidebar.  </li> <li>Select <code>Miscellaneous</code> \u2192 <code>New Terminal</code>.  </li> <li>Run command inside terminal: <code>pio lib --global install https://github.com/jvpernis/esp32-ps3</code> </li> </ol> PS4Controller (click to expand) Arduino IDEPlatformIO <ol> <li>Download file PS4-esp32-master.zip.</li> <li>Select <code>Sketch</code> \u2192 <code>Include Library</code> \u2192 <code>Add .ZIP Library..</code>.  </li> <li>Select downloaded PS4-esp32-master.zip file.  </li> <li>Message \"Library added to your libraries\" should appear.  </li> </ol> <ol> <li>Click PlatformIO icon in sidebar.  </li> <li>Select <code>Miscellaneous</code> \u2192 <code>New Terminal</code>.  </li> <li>Run command inside terminal: <code>pio lib --global install https://github.com/aed3/PS4-esp32</code> </li> </ol>"},{"location":"remote-control/ps-controller/#change-mac","title":"Change MAC","text":"<p>Stored MAC address can be changed with Sixaxis Pairer Tool using PC. This is required only once. If controller was connected to other device, this step should be repeated. Follow instructions to change controller address:</p> WindowsMac OSXLinux <p>Download link: SixaxisPairToolSetup-0.3.1.exe \u2013 [Size: 25.6 MB] Run downloaded file and install.  </p> <p>Download link: sixpair - [Size: 9.4 KB] This utility requires libusb, which can be downloaded from http://www.ellert.se/twain-sane/. Choose the binary for your version of OSX.</p> <p>Download link: SixaxisPairTool \u2013 [Size: 55.7 KB]  </p> <p>Required dependencies: qt5, libusb-1.0  </p> <p>You will also need to install the following udev rule file under /etc/udev/rules.d/ to give the app access to the controller: 51-sixaxispairtool.rules </p> <p> </p> <ol> <li>Run SixaxisPairTool.  </li> <li>Connect controller to PC using USB cable.  </li> <li>SixaxisPairTool should detect connected controller and display current stored MAC address at \"Current Master\".</li> <li>In \"Change Master\" enter <code>00:02:03:04:05:06</code></li> <li>Click Update</li> <li>\"Current Master\" will change to \"00:02:03:04:05:06\"</li> <li>Address is set. Unplug controller and close the tool.  </li> </ol>"},{"location":"remote-control/ps-controller/#run-example-code","title":"Run example code","text":"<p>Interaction with controller features can be found inside library examples.</p> <p>To use controllers with RoboBoard and Totem robotic kits, check Totem Arduino examples.</p> <p>Ensure that adddress entered in \"Change Master\" matches with one provided in <code>PS4.begin(\"00:02:03:04:05:06\")</code>. Press PS button on the controller and after few seconds it should start working. </p> <p>Bug</p> <p>Sometimes remote does not connect even if MAC address is correct. Erase ESP32 flash and upload it again to resolve issue: Select Arduino IDE \u2192 <code>Tools</code> \u2192 <code>Erase All Flash Before Sketch Upload</code>. Select PlatformIO \u2192 Project Tasks \u2192 Platform \u2192 <code>Erase Flash</code>. Command line: <code>esptool.py erase_flash</code>.</p>"},{"location":"remote-control/app/","title":"Totem App","text":""},{"location":"remote-control/app/#download","title":"Download","text":"<p>Mobile application created by TotemMaker to control Totem robots and boards. Available for Android and iOS:  </p> <p></p> <p> Download Android APK</p>"},{"location":"remote-control/app/#features","title":"Features","text":"<ul> <li>Wirelessly connect to robots</li> <li>Change robot color and name</li> <li>Control specific robots with available layouts (models)</li> <li>Create custom model and controls for a robot</li> <li>Share model to other devices</li> <li>Add multiple widgets (buttons), modify functionality and settings</li> <li>Map widgets (buttons) to X3 and X4 board functions</li> <li>Rotate and change widgets (buttons) size</li> </ul>"},{"location":"remote-control/app/#tutorials","title":"Tutorials","text":"<ul> <li>Connecting to robot using Totem App </li> <li>Program custom RoboBoard actions for Totem App </li> </ul>"},{"location":"remote-control/app/control-robot/","title":"Control robot","text":"<p>Our robots can be controlled using iOS and Android applications. This guide will instruct how to get it and manually control the robot. Application looks a bit different between iOS and Android platforms, so images are displayed for both of them.  </p> <p></p>"},{"location":"remote-control/app/control-robot/#installing-app","title":"Installing app","text":"<p>Click on the image to download application for your device:  </p> <p></p> <p> Download Android APK</p> <p>When starting application first time, a introduction tutorial may be shown. Read it to discover all the features available.  </p>"},{"location":"remote-control/app/control-robot/#connecting-robot","title":"Connecting robot","text":"<p>Now power up your robot (connect battery). When robot LED lights up, click \u201cConnect\u201d button inside the app main screen.  </p> <p></p> <p>A request for Bluetooth and location permissions may appear. These are required for application to communicate with the robot. Accept them and you will see a list of located Totem robots.  </p> <p></p> <p>Click on discovered robot, you want to connect with and application will switch to \u201cConnected\u201d screen. There you can disconnect the robot, update firmware or change settings.  </p> <p></p>"},{"location":"remote-control/app/control-robot/#moving-around","title":"Moving around","text":"<p>Now when robot is connected, you can start controlling it. From available models list, select your connected robot to open specific controls.  </p> <p></p> <p>There you will find buttons with different functionality. Try clicking each one and see how robot reacts. In case of Mini Trooper, you can drive around and move flipper.  </p> <p></p>"},{"location":"remote-control/app/custom-function/","title":"Custom functions","text":"<p>Info</p> <p>At the moment available in Android only. For iOS use Override commands as alternative.</p> <p>Normally the buttons inside Totem app are mapped to motor outputs directly. If we press a button - motor starts to spin, and stops on release. This is quite limited functionality. RoboBoard allows to have custom actions programmed and we will make an example of waving a servo motor arm. For full feature list read Totem App section.</p>"},{"location":"remote-control/app/custom-function/#adding-control-button","title":"Adding control button","text":"Your browser does not support the video tag.  <p>Note: This is example from older app version and interface looks slightly different. For more about buttons editing read Setting up Totem robot controls.</p> <ol> <li>Power on RoboBoard.</li> <li>Connect with Totem App.</li> <li>Create a new model.</li> <li>Add button.</li> <li>Go to button edit.</li> <li>Select RoboBoard and add <code>functionA</code>.</li> <li>Click Next \u2192 Done \u2192 Save.</li> <li>Select Play mode.</li> </ol> <p>Now, when we click this button, a value <code>100</code> will be sent to command <code>functionA</code>. On release - <code>-100</code>. These values can be changed by adjusting the slider. RoboBoard can intercept this command and read its value. By doing so, we can program a certain tasks to execute. There are 4 auxiliary commands in total: <code>functionA</code>, <code>functionB</code>, <code>functionC</code>, <code>functionD</code> and each one can be used.</p>"},{"location":"remote-control/app/custom-function/#moving-servo-motor","title":"Moving servo motor","text":"<p>We will write a code to wave servo arm. The motor itself is connected to servo channel A. Arm can move 180 degrees, and parameter values corresponds in range from <code>-100</code> to <code>100</code>. Look at the image below to see how it's related:</p> <p></p> <p>So, we will try to move arm in this sequence: -45\u00b0, 0\u00b0, 45\u00b0, 0\u00b0. The code required to do so:</p> <pre><code>// Define a function, containing instructions to wave a servo arm\nvoid moveServo() {\n  Servo.A.spinPos(-50); // Set servo port A position to -50% (45\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(0); // Set servo port A position to 0% (90\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(50); // Set servo port A position to 50% (135\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(0);\n  delay(300); // Delay code execution for 300 milliseconds\n}\n// Arduino function first called on program start\nvoid setup() {\n\n}\n// Arduino function repeating constantly\nvoid loop() {\n  moveServo(); // Execute servo instructions\n  delay(2000); // Wait 2 seconds\n}\n</code></pre> <p>Inside function <code>loop()</code> we are calling <code>moveServo()</code> to execute sequence and it is repeated every 2 seconds. The result should look like this:</p> <p></p>"},{"location":"remote-control/app/custom-function/#detecting-app-button-press","title":"Detecting App button press","text":"<p>Now let's move this servo arm only when in-App button is pressed. As bonus, we will indicate button press with on-board LED. To detect command events we need to add a little bit more code:</p> <pre><code>// Define a function, containing instructions to wave a servo arm\nvoid moveServo() {\n  Servo.A.spinPos(-50); // Set servo port A position to -50% (45\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(0); // Set servo port A position to 0% (90\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(50); // Set servo port A position to 50% (135\u00b0 angle)\n  delay(300);\n  Servo.A.spinPos(0);\n  delay(300); // Delay code execution for 300 milliseconds\n}\n// Create variable to hold the state of button press\nbool appButtonPressed = false;\n// Receive events sent from Totem App\nvoid appEvent(int evt, int value) {\n  // Check if received event is \"functionA\"\n  if (evt == TotemApp.evtFunctionA) {\n    // Check if sent value is \"100\" (button is pressed in)\n    if (value == 100) {\n      LED.on(); // Turn RoboBoard LED on\n      appButtonPressed = true; // Set variable `appButtonPressed` state to `true`\n    }\n    // Value was not \"100\". Execute this block of code\n    else {\n      // Turn LED off and reset \"appButtonPressed\" variable\n      LED.off();\n      appButtonPressed = false;\n    }\n  }\n}\n// Arduino function first called on program start\nvoid setup() {\n  TotemApp.addEvent(appEvent); // Register TotemApp event function\n}\n// Arduino function repeating constantly\nvoid loop() {\n  // Wait till \"appButtonPressed\" is \"true\" and then execute \"moveServo()\"\n  if (appButtonPressed) {\n    moveServo();\n  }\n}\n</code></pre> <p>After uploading this code to RoboBoard - connect with Totem App and try pressing created button. Servo arm should move and LED light up. For more information about Totem App events read <code>TotemApp</code> section.</p>"},{"location":"roboboard/","title":"RoboBoard","text":"<p>Totem RoboBoard is a family of ESP32 based Arduino development boards that combines most important robot building components (battery, motor drivers, wireless control) into single package. All complicated circuitry is embedded into board itself and controlled using extended Totem software package. This solution eases robot building with a few key advantages:</p> <ul> <li>Compact package.</li> <li>Extension ports and pins.</li> <li>Integrated battery charging.</li> <li>Built-in motor drivers, RGB, IMU sensor.</li> <li>ESP32 with Wi-Fi and Bluetooth connectivity.</li> <li>Arduino programming with extended RoboBoard API.</li> <li>Remote control using Totem App.</li> </ul> <ul> <li>RoboBoard X3 </li> <li>RoboBoard X4 </li> </ul>"},{"location":"roboboard/#connect-with-smartphone","title":"Connect with smartphone","text":"<p> Download Android APK</p> <p>RoboBoard is designed to run in dual mode - Arduino sketch and/or remote control with smartphone app. This functionality is embedded inside Totem software and does not require any additional code or libraries. Can be useful if your robot or application requires some sort of remote control. In Totem App you can create custom buttons and actions.</p> <p>This allows to control your robot right away. If you bought one of the kits, you will find it in the list of \"Models\". In case of making your own robot - select \"custom\" &gt; \"+ add new model\" to create custom layout. For more information read Totem App section.</p>"},{"location":"roboboard/#enable-connectivity","title":"Enable connectivity","text":"<p>This functionality is enabled automatically when <code>TotemApp</code> is used inside Arduino sketch. If not enabled - RoboBoard won't be visible inside Totem App connection screen. Check Board settings for available configuration values.</p> Minimal code to enable Totem App<pre><code>void setup() {\n  TotemApp.begin(); // Start Totem App service\n}\nvoid loop() {\n\n}\n</code></pre> <p>Enabling app connectivity also increases binary size by 800KB (slower compile &amp; upload).</p>"},{"location":"roboboard/#custom-functions","title":"Custom functions","text":"<p>Typically, buttons inside Totem App control RoboBoard motors directly (without any logic in between) and are mapped to particular robotic kit. Buttons can be created or modified to send particular values to RoboBoard on press or interaction. This enables making custom actions or override existing ones. Read TotemApp and Custom functions sections for more information.</p> <pre><code>// Function that receives values sent from Totem App\nvoid appEvent(int evt, int value) {\n  if (evt == TotemApp.evtFunctionA) {\n    // Got integer 'value' on topic '/0/functionA' (from Totem App)\n  }\n  if (evt == TotemApp.evtConnect) {\n    // App connected to RoboBoard\n  }\n  if (evt == TotemApp.evtDisconnect) {\n    // App disconnected from RoboBoard\n  }\n}\nvoid setup() {\n  TotemApp.addEvent(appEvent); // Register TotemApp event function\n}\nvoid loop() {\n\n}\n</code></pre> <p>View <code>TotemApp.addEvent()</code> for full list of app events.</p>"},{"location":"roboboard/#arduino-programming","title":"Arduino programming","text":"<p>Using Arduino environment you can command RoboBoard to perform specific tasks. It will run each time board is powered on. This provides access to whole Arduino ecosystem, libraries and Internet connectivity. To start programming, you need to install Arduino environment on your PC. It will help to write a code, compile and upload it to the RoboBoard. Follow Arduino setup tutorial to do so.</p> RoboBoard RBG blink<pre><code>// Arduino setup function.\nvoid setup() {  \n  // Empty\n}\n// Arduino loop function\nvoid loop() {\n  RGB.color(Color::Red); // Set all RGB to red color\n  delay(700); // Wait 700 milliseconds\n  RGB.color(Color::Green); // Set all RGB to green color\n  delay(700); // Wait 700 milliseconds\n  RGB.color(Color::Blue); // Set all RGB to blue color\n  delay(700); // Wait 700 milliseconds\n}\n</code></pre> <p></p>"},{"location":"roboboard/#board-settings","title":"Board settings","text":"<p>RoboBoard has a few extra features, available in configuration functions. By default it's disabled to not intervene for using RoboBoard as development board (programming with Arduino). Recommended to enable when using robotic kits (like MiniTrooper, RoboCar).</p> <ul> <li>On/Off RoboBoard X3 3V3 power</li> <li>Force RoboBoard X3 into charging mode when USB-C cable is plugged in</li> <li>Display if board restarted due low battery (blink red LED)</li> <li>Display battery state of charge during startup (RGB animation)</li> <li>Play sound on board power on (motor tone)</li> <li>Play sound on Totem App connect / disconnect (motor tone)</li> <li>Animate RGB if Totem App is disconnected</li> </ul> <pre><code>// Initialize program\nvoid setup() {\n  // Enable RoboBoard X3 3V3 LDO regulator\n  // Note: always enabled \"true\" by default.\n  Board.setEnable3V3(true);// (1)!\n  // Enable RoboBoard X3 charging mode\n  // Powers off the board and displays RGB animation while charging\n  // Note: not recommended if using RoboBoard X3 as development board\n  Board.setChargingMode(false);// (2)!\n  // Enable board status indication with RGB lights\n  // - displays battery state on power on\n  // - blink red if restarted due low battery\n  // - displays Totem App connection state\n  Board.setStatusRGB(true);// (3)!\n  // Enable board status indication with motor beep sounds\n  // - beep when board is powered up\n  // - beep on Totem App connect / disconnect\n  Board.setStatusSound(true);// (4)!\n  // Save configuration to memory\n  // This code may be removed and all configuration\n  // will be loaded automatically during board startup\n  Board.settingsSave();// (5)!\n}\n// Loop program\nvoid loop() {\n\n}\n</code></pre> <ol> <li>Docs: Board.setEnable3V3()</li> <li>Docs: Board.setChargingMode()</li> <li>Docs: Board.setStatusRGB()</li> <li>Docs: Board.setStatusSound()</li> <li>Docs: Board.settingsSave()</li> </ol> Default firmware shipped with RoboBoard <p>Arduino code flashed during manufacturing (enables all features):</p> <pre><code>#include &lt;Arduino.h&gt;\n/*\n  Default firmware for Totem robotic kits. Includes features turned on:\n  - Totem App connectivity\n  - Motor beep during power on and app connect\n  - RGB blink during power on and app connect\n  - RoboBoard X3 charging mode\n*/\n// Function called after loading configuration from memory\n// and before system is initialized (with loaded configuration)\n// Note: if \"initRoboBoard()\" is used - overrides board parameters\n// set in Arduino IDE Tools menu.\nvoid initRoboBoard() {\n#if ROBOBOARD_X3\n  // Set RoboBoard X3 charging mode\n  // Powers off the board and displays RGB charging animation\n  // when USB cable is plugged in\n  Board.setChargingMode(true);\n#endif\n  // Enable board status indication with RGB LED\n  // - displays battery state on power on\n  // - blink red if restarted due low battery\n  // - displays Totem App connection state\n  Board.setStatusRGB(true);\n  // Enable board status indication with motor beep sounds\n  // - beep when board is powered up\n  // - beep on Totem App connect / disconnect\n  Board.setStatusSound(true);\n}\n// Initialize program\nvoid setup() {\n  // Enable TotemApp connectivity\n  TotemApp.begin();\n}\n// Loop program\nvoid loop() {\n\n}\n</code></pre> <p>For more information read <code>Board</code> &gt; Board settings section.</p>"},{"location":"roboboard/#boards-comparison","title":"Boards comparison","text":"RoboBoard X3 (v3.1) RoboBoard X4 (v1.1) Battery 3.7V (250mAh) (2Amps) 11.1V (2200mAh) (6Amps) Battery size (mm) 32 x 16 x 7 70 \u00d7 55 x 18 (0.12kg) Battery wire 50mm, JST-PH 210mm, JST-VH Battery info voltage, current, charging voltage IMU Accelerometer, Gyroscope Accelerometer, Gyroscope RGB 4 LED 4 LED GPIO 3 pins + (4 servo SIG) (rev v3.0-2 SIG)<code>IO26</code> <code>IO32</code> <code>IO33</code><code>SIGA</code> <code>SIGB</code> <code>SIGC</code> <code>SIGD</code> 4 pins<code>GPIOA</code> <code>GPIOB</code> <code>GPIOC</code> <code>GPIOD</code> Status charging RGB status LED (Prog.), charging LED Buttons Reset, Boot (Prog.) Reset, Button (Prog.) Drivers 4 x DC brushless motors4 x Servo motors (rev v3.0-2 motors) 4 x DC brushless motors3 x Servo motors DC port 3.7V (1 Amp) 11.1V (1 Amp) Servo port 3.7V (2 Amps) 5V (6 Amps) GPIO/Qwiic port 3.3V (0.8 Amp) (rev v3.0-0.5A) 3.3V (2 Amps) MCU ESP32 (240Mhz, dual-core) ESP32 (240Mhz, dual-core) Storage 320KB SRAM, 8MB Flash 320KB SRAM, 8MB Flash Radio WiFi, Bluetooth Classic / LE WiFi, Bluetooth Classic / LE Charging USB-C (5V) DC input (15V) Connectors USB-C, Qwiic miniUSB, Qwiic, TBUS Size (mm) 65 x 25 x 8 70 x 50 x 14 <p>* Peak amperage provided. May be lower if other peripherals are draining current.</p>"},{"location":"roboboard/api/","title":"API Reference","text":"<p>Application Programming Interface. A set of functions to control various board features. It consists of standard ESP32 Arduino implementation with addition of Totem software for RoboBoard. This whole package allows to use it as standard Arduino development board with additional capabilities.</p> <p>Note: Some features may be available with specific RoboBoard only. Such differences are marked with <code>X3 only</code>, <code>X4 only</code> tags.</p>"},{"location":"roboboard/api/#software-structure","title":"Software structure","text":"RoboBoard X3RoboBoard X4 <p>Software package is divided into parts:  </p> <ul> <li>Arduino API - official Arduino programming functions Arduino Reference. Universal across all Arduino boards. Used by third-party Arduino libraries.  </li> <li>ESP32 API - processor specific functions and additional esp32-hal drivers. Ties ESP32 with Arduino framework and provides extended peripheral functionality.  </li> <li>ESP-IDF - official Espressif development framework contains all ESP32 drivers. Layer between hardware and software. Provides all required tools and drivers for ESP32.  </li> <li>RoboBoard API - additional RoboBoard functionality provided by Totemmaker. Includes board control functions totem-bsp and other services.</li> </ul> <p>All software parts can be accessed from Arduino sketch, but mainly Arduino API and RoboBoard API is used.</p>"},{"location":"roboboard/api/#compile-definitions","title":"Compile definitions","text":"<p>Most of the code works the same on RoboBoard X3 and RoboBoard X4. In case it's required to run different code per each board - use definitions to detect board type at compile time:</p> <pre><code>#if ROBOBOARD_X3 // Compiles only on RoboBoard X3\n  pinMode(IO32, OUTPUT); // Initialize IO32 pin as output\n#endif\n#if ROBOBOARD_X4 // Compiles only on RoboBoard X4\n  pinMode(GPIOA, OUTPUT); // Initialize GPIOA pin as output\n#endif\n</code></pre> <p>Note: correct board must be selected in Arduino IDE Board menu.</p>"},{"location":"roboboard/api/#totem-prefix","title":"Totem Prefix","text":"<p>If there is a conflict between Totem API function names and some library, this option requires to use prefix (C++ namespace) with every totem function:</p> <ul> <li>PlatformIO: In platformio.ini add: <code>build_flags = -DREQUIRE_TOTEM_PREFIX</code></li> <li>Arduino IDE: Select <code>Tools</code> \u2192 <code>Totem Prefix</code> \u2192 <code>totem::Board</code></li> </ul> <pre><code>void setup() {\n    totem::Board.getRevision();\n    totem::Battery.getVoltage();\n    totem::RGB.color(totem::Color::Red);\n}\n</code></pre>"},{"location":"roboboard/api/#multithreading","title":"Multithreading","text":"<p>RoboBoard Arduino implementation has function <code>addLoop()</code> to create additional parallel <code>loop()</code> tasks. An easy way to control separate actions with <code>delay()</code> function. All tasks runs on the same Core 1, as main <code>loop()</code> and only single one is executed at the time. Note: this is not a standard Arduino function and will not compile with other boards!</p> <p>Register new parallel <code>loop()</code> function. Parameter: <code>function</code> - parallel function name (<code>loop2()</code>)  </p> <pre><code>int counter0 = 0;\nint counter1 = 0;\nint counter2 = 0;\nint counter3 = 0;\n\nvoid loop1() {\n    if (counter1 &lt;= 3) printf(\"loop1(): %d\\n\", counter1++);\n}\nvoid loop2() {\n    if (counter2 &lt;= 3) printf(\"loop2(): %d\\n\", counter2++);\n}\nvoid loop3() {\n    if (counter3 &lt;= 3) printf(\"loop3(): %d\\n\", counter3++);\n\n}\nvoid setup() {\n    printf(\"setup()\\n\");\n    addLoop(loop1);\n    addLoop(loop2);\n    addLoop(loop3);\n}\n\nvoid loop() {\n    if (counter0 &lt;= 3) printf(\"loop0(): %d\\n\", counter0++);\n    // delay(0); // &lt;- switch to other loop earlier\n}\n</code></pre> <p>Loop functions will switch between by reaching end of function or call to <code>delay()</code>. Note that <code>loop()</code> has priority over added ones, so call to <code>delay(0)</code> is required to execute all loops equally. See print output bellow to view the difference:</p> <p>Print output</p> Without delay(0)With delay(0) <pre><code>setup()\nloop0(): 0\nloop0(): 1\nloop0(): 2\nloop0(): 3\nloop1(): 0\nloop2(): 0\nloop3(): 0\nloop1(): 1\nloop2(): 1\nloop3(): 1\nloop1(): 2\nloop2(): 2\nloop3(): 2\nloop1(): 3\nloop2(): 3\nloop3(): 3\n</code></pre> <pre><code>setup()\nloop0(): 0\nloop1(): 0\nloop2(): 0\nloop3(): 0\nloop0(): 1\nloop1(): 1\nloop2(): 1\nloop3(): 1\nloop0(): 2\nloop1(): 2\nloop0(): 3\nloop2(): 2\nloop3(): 2\nloop1(): 3\nloop2(): 3\nloop3(): 3\n</code></pre>"},{"location":"roboboard/api/#addLoop","title":"addLoop(<code>function</code>)","text":""},{"location":"roboboard/api/#totem-api-list","title":"Totem API list","text":"<p>Full list of functionalities and libraries available in Arduino environment for RoboBoard.</p> <ul> <li>TotemApp - Totem Android/iOS application for RoboBoard control</li> <li>Drivetrain - robot wheel control logic</li> <li>Joystick - raw joystick input converter</li> <li>Battery - acquire battery status</li> <li>Board - acquire RoboBoard information and change settings</li> <li>IMU - accelerometer &amp; gyroscope readings</li> <li>RGB - RGB light controller</li> <li>LED - status LED controller</li> <li>Color - list of color names</li> <li>Button - physical button input controller</li> <li>IOLED - external LED controller connected to IO pin</li> <li>IOButton - external button controller connected to IO pin</li> <li>Servo - servo motor controller interface</li> <li>DC - DC motor controller interface</li> <li>TotemModule11 - TotemBUS Distance module <code>X4 only</code></li> <li>TotemModule14 - TotemBUS Line Follower module <code>X4 only</code></li> <li>TotemModule15 - TotemBUS Potentiometer module <code>X4 only</code></li> <li> <p>TotemModule22 - TotemBUS Environment sensor module <code>X4 only</code></p> </li> <li> <p><code>addLoop(func)</code> - function to create parallel <code>loop()</code> handler</p> </li> <li><code>initRoboBoard()</code> - RoboBoard system pre-initialization handler</li> <li><code>TOTEMMAKER_PLATFORM</code> - Totem Arduino core for RoboBoard</li> <li><code>ROBOBOARD_X3</code> - board RoboBoard X3 is selected during compilation</li> <li><code>ROBOBOARD_X4</code> - board RoboBOard X4 is selected during compilation</li> </ul>"},{"location":"roboboard/api/#libraries","title":"Libraries","text":"<ul> <li><code>#include &lt;Totem.h&gt;</code> - remote RoboBoard control. Labboard control</li> </ul>"},{"location":"roboboard/api/#espressif-api-list","title":"Espressif API list","text":"<ul> <li>ESP</li> <li>Arduino API reference</li> <li>APIs documentation</li> <li>FreeRTOS API Reference</li> </ul>"},{"location":"roboboard/api/#hal-drivers","title":"HAL drivers","text":"<p>Additional ESP32 drivers, providing extended functionality compared to standard Arduino API.</p> <ul> <li>esp32-hal-adc.h</li> <li>esp32-hal-cpu.h</li> <li>esp32-hal-dac.h</li> <li>esp32-hal-i2c-slave.h</li> <li>esp32-hal-i2c.h</li> <li>esp32-hal-ledc.h</li> <li>esp32-hal-log.h</li> <li>esp32-hal-rgb-led.h</li> <li>esp32-hal-rmt.h</li> <li>esp32-hal-sigmadelta.h</li> <li>esp32-hal-spi.h</li> <li>esp32-hal-timer.h</li> <li>esp32-hal-touch.h</li> <li>esp32-hal-uart.h</li> <li>Low level drivers (esp-idf)</li> <li>All components (esp-idf)</li> </ul>"},{"location":"roboboard/api/#encoding-encryption","title":"Encoding / encryption","text":"<ul> <li><code>base64</code> (#include ) <li><code>MD5Builder</code> (#include ) <p>For AES, RSA, SHA and others check: esp-idf</p>"},{"location":"roboboard/api/#libraries_1","title":"Libraries","text":"<ul> <li>ArduinoOTA - upload ESP32 firmware binary over Wi-Fi  </li> <li>BluetoothSerial - Bluetooth Classic Serial communication  </li> <li>DNSServer - (CaptivePortal) display website when connected to ESP32  </li> <li>EEPROM - legacy user data storage to flash  </li> <li>ESP Insights - Espressif diagnostic cloud service  </li> <li>ESP RainMaker - Espressif IOT cloud service  </li> <li>ESP32 Async UDP - broadcast using UDP protocol  </li> <li>ESP32 BLE Arduino - Bluetooth Low Energy communication  </li> <li>ESPmDNS - host local website with address <code>http://esp32.local</code> </li> <li>FFat - FAT file system  </li> <li>HTTPClient - access other websites (web browser)  </li> <li>HTTPUpdate - firmware update from HTTP server  </li> <li>HTTPUpdateServer - host local website to update firmware  </li> <li>I2S - I2C peripheral control library  </li> <li>LittleFS - LittleFS file system  </li> <li>NetBIOS - make ESP32 discoverable on local network  </li> <li>Preferences - library for long term user data storage  </li> <li>SD - SD card control library  </li> <li>SD_MMC - SD MMC card control library  </li> <li>SimpleBLE - advertise basic BLE server  </li> <li>SPI - SPI peripheral control library  </li> <li>SPIFFS - SPIFFS file system  </li> <li>Ticker - function call at specific rate  </li> <li>Update - ESP32 firmware update library  </li> <li>WebServer - host local website  </li> <li>WiFi - WiFi control library  </li> <li>WiFiClientSecure - connect to web server using TLS  </li> <li>WiFiProv - WiFi provision over BLE or SOFTAP  </li> <li>Wire - I2C peripheral control library  </li> </ul>"},{"location":"roboboard/api/battery/","title":"Battery","text":"<p>RoboBoard can be powered from standalone battery to run whole circuit and motors. Also features charging and state monitoring.</p> <ul> <li>RoboBoard X3 - 3.7V 250mAh Li-Po (2 Amps peak)</li> <li>RoboBoard X4 - 11.1V 2200mAh Li-Ion (6 Amps peak)</li> </ul>"},{"location":"roboboard/api/battery/#code-snippets","title":"Code snippets","text":"<pre><code>// Initialize program\nvoid setup() {\n  Serial.begin(115200);\n}\n// Loop program\nvoid loop() {\n  // Print battery info\n  Serial.printf(\"SOC: %d%%\\n\", Battery.getSOC());\n  Serial.printf(\"Voltage: %.2fV\\n\", Battery.getVoltage());\n  if (Board.getNumber() == 3) {\n    Serial.printf(\"Current: %.2fA\\n\", Battery.getCurrent());\n    Serial.printf(\"Charging: %s\\n\", Battery.isCharging() ? \"Yes\" : \"No\");\n  }\n  // Wait 1 second\n  delay(1000);\n}\n</code></pre>"},{"location":"roboboard/api/battery/#functions","title":"Functions","text":""},{"location":"roboboard/api/battery/#status","title":"Status","text":"<p>Functions to read battery status.</p> <p>Get battery State Of Charge (voltage based). Returns: <code>SOC</code> - battery charge level [<code>0</code>:<code>100</code>]%.  </p> <p>Get battery voltage. \u2022 X3: range [<code>2.6</code>:<code>4.2</code>]V. Shows ~<code>4.8</code> if USB connected. \u2022 X4: range [<code>8.40</code>:<code>12.60</code>]V Returns: <code>voltage</code> - battery voltage (float).  </p> <p>Get battery current flow (Amps). <code>-</code>(discharging), <code>+</code>(charging). Returns: <code>amps</code> - battery current (float) [<code>-2.0</code>:<code>0.5</code>]A.  </p> <p>Check if battery is currently charging. Returns: <code>state</code> - is charging yes/no [<code>true</code>:<code>false</code>].  </p>"},{"location":"roboboard/api/battery/#getSOC","title":"<code>SOC</code> Battery.getSOC()","text":""},{"location":"roboboard/api/battery/#getVoltage","title":"<code>voltage</code> Battery.getVoltage()","text":""},{"location":"roboboard/api/battery/#getCurrent","title":"<code>amps</code> Battery.getCurrent() <code>X3 v3.1 only</code>","text":""},{"location":"roboboard/api/battery/#isCharging","title":"<code>state</code> Battery.isCharging() <code>X3 only</code>","text":""},{"location":"roboboard/api/board/","title":"Board","text":"<p>Access RoboBoard specific features: settings storage, power, appearance, versions.</p>"},{"location":"roboboard/api/board/#code-snippets","title":"Code snippets","text":"View board information<pre><code>void setup() {\n  // Print Board information\n  Serial.printf(\"RoboBoard X%d\\n\", Board.getNumber());\n  Serial.printf(\"Revision: %s\\n\", Board.getRevisionStr());\n  if (Board.getNumber() == 4)\n    Serial.printf(\"Driver version: %s\\n\", Board.getDriverVersionStr());\n  Serial.printf(\"Software version: %s\\n\", Board.getSoftwareVersionStr());\n  Serial.printf(\"Board name: %s\\n\", Board.getName());\n  Serial.printf(\"Boot color: 0x%x\\n\", Board.getColor());\n  Serial.printf(\"USB inserted: %s\\n\", Board.isUSB()  ? \"Yes\" : \"No\");\n}\nvoid loop() { }\n</code></pre> Change appearance in Totem App<pre><code>void setup() {\n  // Change board display inside Totem App connect menu\n  Board.setName(\"My Robot\"); // Display name \"My Robot\"\n  Board.setColor(Color::Red); // Display with red color\n}\nvoid loop() { }\n</code></pre>"},{"location":"roboboard/api/board/#functions","title":"Functions","text":"<p>Some functions contain <code>async</code> parameter to execute action in \"background\" with delay of 500ms. This is used to avoid blocking currently running code. By default it is set to <code>false</code>. Calling <code>settingsErase()</code> may block code until flash operations are executed. Calling <code>settingsErase(true)</code> does not block the code and erase operation is performed in background.</p>"},{"location":"roboboard/api/board/#control","title":"Control","text":"<p>Control specific board features.</p>"},{"location":"roboboard/api/board/#restart","title":"Board.restart()","text":"<p>Restart ESP32 to reload running program. Same functionality as Reset button. Parameter: <code>async</code> - asynchronous restart. Default: <code>false</code>.</p> <p>Check if USB cable is connected to the board. Returns: <code>state</code> - is USB plugged in yes / no [<code>true</code>:<code>false</code>].  </p>"},{"location":"roboboard/api/board/#restart-async","title":"Board.restart(<code>async</code>)","text":""},{"location":"roboboard/api/board/#isUSB","title":"<code>state</code> Board.isUSB()","text":""},{"location":"roboboard/api/board/#appearance","title":"Appearance","text":"<p>Functions for customizing certain robot appearance settings. Most important ones - name and color are intended to identify robot when connecting with Totem App. Changing color also sets default one for RGB lights during board power up.</p> <p>Set board (or robot) name. Visible during Totem App connection. Default: <code>RoboBoard X3/X4</code>. Parameter: <code>name</code> - string (text) up to 30 characters.  </p> <p>Set 16-bit appearance identifier (robot model, MiniTrooper, RoboCar, ..). Note: not used in Totem App. Parameter: <code>model</code> - 16-bit appearance identifier [<code>0x0000</code>:<code>0xFFFF</code>]  </p>"},{"location":"roboboard/api/board/#setName","title":"Board.setName(<code>name</code>)","text":""},{"location":"roboboard/api/board/#setModel","title":"Board.setModel(<code>model</code>)","text":""},{"location":"roboboard/api/board/#setColor-rgb","title":"Board.setColor(<code>red</code>, <code>green</code>, <code>blue</code>)","text":"<p>Set board color. Displayed upon board start (RGB lights) and Totem App connection. Default: <code>0</code>. If 0, <code>RGB.colorTotem()</code> is set instead. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - 24-bit HEX color code [<code>0x000000</code>:<code>0xFFFFFF</code>].  </p> <p>Get board name. Visible during Totem App connection. Returns: <code>string</code> - configured board name.  </p> <p>Get 16-bit appearance identifier (robot model, MiniTrooper, RoboCar, ..). Returns: <code>number</code> - 16-bit appearance identifier [<code>0x0000</code>:<code>0xFFFF</code>]  </p> <p>Get board color. Displayed upon board start (RGB light) and Totem App connection. Returns: <code>hex</code> - 24-bit HEX color code [<code>0x000000</code>:<code>0xFFFFFF</code>].  </p>"},{"location":"roboboard/api/board/#setColor-hex","title":"Board.setColor(<code>hex</code>)","text":""},{"location":"roboboard/api/board/#getName","title":"<code>string</code> Board.getName()","text":""},{"location":"roboboard/api/board/#getModel","title":"<code>number</code> Board.getModel()","text":""},{"location":"roboboard/api/board/#getColor","title":"<code>hex</code> Board.getColor()","text":""},{"location":"roboboard/api/board/#versions","title":"Versions","text":"<p>Functions to read hardware and software versions.</p> <p>Get RoboBoard number (board type X3 or X4). Returns: <code>number</code> - board number [<code>3</code>:<code>4</code>].  </p>"},{"location":"roboboard/api/board/#getNumber","title":"<code>number</code> Board.getNumber()","text":""},{"location":"roboboard/api/board/#getRevision","title":"<code>number</code> Board.getRevision()","text":"<p>Get RoboBoard hardware revision (version). Printed on the board in format: vX.X. Returns: <code>number</code> - revision [<code>10</code>,<code>11</code>,<code>30</code>]. Format: <code>11</code> -&gt; <code>v1.1</code>. <code>string</code> - revision (text) [<code>1.0</code>,<code>1.1</code>,<code>3.0</code>].  </p>"},{"location":"roboboard/api/board/#getRevisionStr","title":"<code>string</code> Board.getRevisionStr()","text":""},{"location":"roboboard/api/board/#getSoftwareVersion","title":"<code>number</code> Board.getSoftwareVersion()","text":"<p>Get RoboBoard software version (Totem Boards core). Format: <code>&lt;arduino&gt;-totem.&lt;build&gt;</code> \u2022 arduino - ESP32 Arduino core version. \u2022 build - Totem API build number. Returns: <code>number</code> - 32-bit version value (major | minor | patch | build). Example: <code>0x02000E01</code>. <code>string</code> - version (text). Example: <code>2.0.14-totem.1</code>.  </p>"},{"location":"roboboard/api/board/#getSoftwareVersionStr","title":"<code>string</code> Board.getSoftwareVersionStr()","text":""},{"location":"roboboard/api/board/#getDriverVersion","title":"<code>number</code> Board.getDriverVersion() <code>X4 only</code>","text":"<p>Get RoboBoard X4 co-processor (driver) firmware version. Returns: <code>number</code> - version. Format: <code>150</code> -&gt; <code>1.50</code>. <code>string</code> - version (text) <code>1.50</code>.  </p>"},{"location":"roboboard/api/board/#getDriverVersionStr","title":"<code>string</code> Board.getDriverVersionStr() <code>X4 only</code>","text":""},{"location":"roboboard/api/board/#board-settings","title":"Board settings","text":"<p>RoboBoard has some extra features that can be enabled in a few different ways. By default it's disabled to not intervene if using as development board (programming with Arduino). Recommended to enable when using robotic kits (like MiniTrooper, RoboCar). Some of the settings can be changed in Arduino IDE &gt; Tools menu.  </p> <p>Features:</p> <ul> <li>On/Off RoboBoard X3 3V3 power</li> <li>Force RoboBoard X3 into charging mode when USB-C cable is plugged in</li> <li>Display if board restarted due low battery (blink red LED)</li> <li>Display battery state of charge during startup (RGB animation)</li> <li>Play sound on board power on (motor tone)</li> <li>Play sound on Totem App connect / disconnect (motor tone)</li> <li>Animate RGB if Totem App is disconnected</li> </ul> <p>System startup order:</p> <ol> <li>System power on</li> <li>Initial (default) setting values loaded</li> <li>Arduino framework initialized</li> <li>Saved settings (<code>settingsSave()</code>) loaded from flash memory</li> <li>Function <code>initRoboBoard()</code> is called. Loads Arduino IDE menu settings</li> <li>(X3 only) If <code>setChargingMode(true)</code>, start charging mode and halt</li> <li>RoboBoard system started</li> <li><code>TotemApp.begin()</code> gets called (if selected in Arduino IDE menu)</li> <li>Function <code>setup()</code> is called</li> <li>Start repeat function <code>loop()</code></li> </ol>"},{"location":"roboboard/api/board/#arduino-ide-menu","title":"Arduino IDE menu","text":"<p>After settings are loaded from flash in step , system overwrites them with ones configured in Arduino IDE &gt; Tools menu (step ). Only settings selected as \"Enabled\" gets turned on. If selection is \"Default\" - Arduino menu item is ignored and value loaded in step  is used. Enabled settings will be loaded each time board is powered on and won't be disabled if <code>settingsSave()</code> is called. To turn setting off - select \"Default\" and upload the code again.</p>"},{"location":"roboboard/api/board/#force-override","title":"Force override","text":"<p>Step  allows to specify setting values that should be used during board initialization in step . To override settings before system initialization - add function <code>void initRoboBoard()</code>. Note: if function <code>void initRoboBoard()</code> is added - Arduino IDE menu settings are ignored.</p> <pre><code>// Function called after loading configuration from memory\n// and before system is initialized\nvoid initRoboBoard() {\n  // Configuration is loaded from memory\n  Board.setChargingMode(false); // Disable X3 charging mode\n  // System initialization is started and setup() is called\n}\nvoid setup() {\n  // Board.getChargingMode() -&gt; always returns false\n}\nvoid loop() {\n\n}\n</code></pre>"},{"location":"roboboard/api/board/#save-to-memory","title":"Save to memory","text":"<p>Calling <code>settingsSave()</code> will remember configured values as default ones and gets loaded each time in step . Used when changing \"Board settings\" inside Totem App.  </p>"},{"location":"roboboard/api/board/#settingsSave","title":"Board.settingsSave()","text":"<p>Store current configuration to flash. Also called by Totem App board settings dialog. Parameter: <code>async</code> - asynchronous save. Default: <code>false</code>.</p>"},{"location":"roboboard/api/board/#settingsSave-async","title":"Board.settingsSave(<code>async</code>)","text":""},{"location":"roboboard/api/board/#settingsErase","title":"Board.settingsErase()","text":"<p>Erase whole configuration stored in flash. Does not reset runtime settings. Only removes ones stored in flash memory. After restart - factory default settings will be loaded. Parameter: <code>async</code> - asynchronous erase. Default: <code>false</code>.</p>"},{"location":"roboboard/api/board/#settingsErase-async","title":"Board.settingsErase(<code>async</code>)","text":""},{"location":"roboboard/api/board/#function-list","title":"Function list","text":"<p>Set state of RoboBoard X3 peripheral LDO regulator. \u2022 Allows to disable external components for low power applications. Provides power for: <code>RGB lights</code>, <code>GPIO 3V3 pin</code>, <code>Qwiic port</code>. Parameter: <code>state</code> - LDO regulator on / off [<code>true</code>:<code>false</code>]. Default: <code>true</code>.  </p> <p>Enable RoboBoard X3 charging mode. \u2022 Powers off board when USB-C cable is plugged in. \u2022 Indicates charging process with RGB lights. Not recommended to use when programming with Arduino. It prevents code from executing because USB-C cable will be plugged in. Parameter: <code>state</code> - turn on / off [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p> <p>Enable board status RGB display. \u2022 Show battery SOC with RGB animation during power on. \u2022 Blink red LED if board shut down due low battery. \u2022 Running RGB animation - Totem App not connected. \u2022 Steady RGB color - Totem App connected. Parameter: <code>state</code> - turn on / off [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p> <p>Enable board status sounds (motor tone). \u2022 Play pitch up sound when board is powered on. \u2022 Play pitch up sound - Totem App connected. \u2022 Play pitch down sound - Totem App disconnected. Note: DC motors has to be connected to emit any sound. Parameter: <code>state</code> - Sound is on / off [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p> <p>Check if RoboBoard X3 3V3 LDO regulator is enabled. Returns: <code>state</code> - is enabled [<code>true</code>:<code>false</code>]. Default: <code>true</code>.  </p> <p>Check if RoboBoard X3 charging mode is enabled. Returns: <code>state</code> - is enabled [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p> <p>Check if board status RGB display is enabled. Returns: <code>state</code> - is enabled [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p> <p>Check if board status sounds are enabled. Returns: <code>state</code> - is enabled [<code>true</code>:<code>false</code>]. Default: <code>false</code>.  </p>"},{"location":"roboboard/api/board/#setEnable3V3","title":"Board.setEnable3V3(<code>state</code>) <code>X3 only</code>","text":""},{"location":"roboboard/api/board/#setChargingMode","title":"Board.setChargingMode(<code>state</code>) <code>X3 only</code>","text":""},{"location":"roboboard/api/board/#setStatusRGB","title":"Board.setStatusRGB(<code>state</code>)","text":""},{"location":"roboboard/api/board/#setStatusSound","title":"Board.setStatusSound(<code>state</code>)","text":""},{"location":"roboboard/api/board/#getEnable3V3","title":"<code>state</code> Board.getEnable3V3() <code>X3 only</code>","text":""},{"location":"roboboard/api/board/#getChargingMode","title":"<code>state</code> Board.getChargingMode() <code>X3 only</code>","text":""},{"location":"roboboard/api/board/#getStatusRGB","title":"<code>state</code> Board.getStatusRGB()","text":""},{"location":"roboboard/api/board/#getStatusSound","title":"<code>state</code> Board.getStatusSound()","text":""},{"location":"roboboard/api/button/","title":"Button","text":"<p>RTS (Reset) - physical processor restart. Button state can't be read. BOOT - user button. Also may be used to manually enter ESP32 bootloader. </p> <p>Button control interface to read its state and events. Can be used with internal RoboBoard button or external one connected to GPIO.</p>"},{"location":"roboboard/api/button/#code-snippets","title":"Code snippets","text":"State read<pre><code>// Is button currently pressed\nbool isIn = Button.isPressed();\n// Is button currently released\nbool isOut = Button.isReleased();\n// Is button pressed and holding for 1000 milliseconds\nbool isInFor = Button.isPressedFor(1000);\n// Is button released for 1000 milliseconds\nbool isOutFor = Button.isReleasedFor(1000);\n// Was button pressed before\nbool wasIn = Button.wasPressed();\n// Was button released before\nbool wasOut = Button.wasReleased();\n// Was button pressed and released\nbool wasClick = Button.wasClick();\n// Was button double clicked\nbool wasDouble = Button.wasDoubleClick();\n// Was button long pressed\nbool wasLongPress = Button.wasLongPress();\n</code></pre> Event usage<pre><code>// Function called on button event\nvoid buttonEvent(int evt) {\n  if (evt == Button.evtPress) {\n    // Button was pressed\n  }\n  else if (evt == Button.evtRelease) {\n    // Button was released\n  }\n  else if (evt == Button.evtLongPress) {\n    // Button was long pressed\n  }\n  else if (evt == Button.evtDoubleClick) {\n    // Button was double clicked\n  }\n}\nvoid setup() {\n  // Register button state change event \n  Button.addEvent(buttonEvent);\n}\nvoid loop() { }\n</code></pre> Map button to processor restart (click to expand) <p>Example to make user button work same as physical reset (RST) button. <pre><code>void setup() {\n  // Map button as Reset\n  Button.addEvent([]() { Board.restart(); });\n}\nvoid loop() {\n\n}\n</code></pre></p> Delay code start until button press (click to expand) <p>Example to delay any code execution until button is pressed. <pre><code>void setup() {\n  // Run code and jump to loop()\n  Serial.begin(115200);\n  // Wait until button is pressed &amp; print message\n  while (!Button.waitClick(1000)) {\n    Serial.println(\"Waiting for a button press...\");\n  }\n}\nvoid loop() {\n  Serial.println(\"Code is running...\");\n  delay(500);\n}\n</code></pre></p>"},{"location":"roboboard/api/button/#functions","title":"Functions","text":""},{"location":"roboboard/api/button/#current-state","title":"Current state","text":"<p>Read current button states (at the moment).</p> <p>Check if button is pressed. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is released. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is pressed in for a certain amount of <code>time</code>. Parameter: <code>time</code> - amount of milliseconds button is pressed [<code>0</code>:<code>65535</code>]ms Returns: <code>status</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is released in for a certain amount of <code>time</code>. Parameter: <code>time</code> - amount of milliseconds button is released [<code>0</code>:<code>65535</code>]ms Returns: <code>status</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is pressed for 500ms. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Get button state (pressed of not). Same as <code>isPressed()</code>. Returns: <code>state</code> - <code>true</code> is pressed, <code>false</code> not pressed.  </p>"},{"location":"roboboard/api/button/#isPressed","title":"<code>state</code> Button.isPressed()","text":""},{"location":"roboboard/api/button/#isReleased","title":"<code>state</code> Button.isReleased()","text":""},{"location":"roboboard/api/button/#isPressedFor","title":"<code>state</code> Button.isPressedFor(<code>time</code>)","text":""},{"location":"roboboard/api/button/#isReleasedFor","title":"<code>state</code> Button.isReleasedFor(<code>time</code>)","text":""},{"location":"roboboard/api/button/#isLongPress","title":"<code>state</code> Button.isLongPress()","text":""},{"location":"roboboard/api/button/#getState","title":"<code>state</code> Button.getState()","text":""},{"location":"roboboard/api/button/#previous-state","title":"Previous state","text":"<p>Read past button states (current or already happened). Button actions are recorded and accessed with these functions (after event is already happened). Functions returns <code>true</code> only once. After that, recorded state is reset and waits for new event.</p> <p>Check if button was pressed earlier. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button was released earlier. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is was clicked shortly. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button is was pressed for 500ms. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Check if button was was double clicked. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>]  </p> <p>Get amount of time button is in current state. Returns: <code>time</code> - state time (milliseconds).  </p>"},{"location":"roboboard/api/button/#wasPressed","title":"<code>state</code> Button.wasPressed()","text":""},{"location":"roboboard/api/button/#wasReleased","title":"<code>state</code> Button.wasReleased()","text":""},{"location":"roboboard/api/button/#wasClick","title":"<code>state</code> Button.wasClick()","text":""},{"location":"roboboard/api/button/#wasLongPress","title":"<code>state</code> Button.wasLongPress()","text":""},{"location":"roboboard/api/button/#wasDoubleClick","title":"<code>state</code> Button.wasDoubleClick()","text":""},{"location":"roboboard/api/button/#getStateTime","title":"<code>time</code> Button.getStateTime()","text":""},{"location":"roboboard/api/button/#events","title":"Events","text":"<p>Button events used to trigger some code execution when button is pressed. <code>waitClick()</code> is used to halt code execution until button is pressed. <code>addEvent()</code> is used to report button state change.</p>"},{"location":"roboboard/api/button/#waitClick","title":"<code>state</code> Button.waitClick()","text":""},{"location":"roboboard/api/button/#waitClick-time","title":"<code>state</code> Button.waitClick(<code>time</code>)","text":""},{"location":"roboboard/api/button/#waitDobuleClick","title":"<code>state</code> Button.waitDobuleClick()","text":""},{"location":"roboboard/api/button/#waitDobuleClick-time","title":"<code>state</code> Button.waitDobuleClick(<code>time</code>)","text":""},{"location":"roboboard/api/button/#waitLongPress","title":"<code>state</code> Button.waitLongPress()","text":"<p>Halts code execution until button event is detected. Contains timeout feature for maximum amount of <code>time</code> to wait. Parameter: <code>time</code> - maximum time to wait (ms). <code>0</code> - disabled. Returns: <code>state</code> - <code>true</code> if event detected, <code>false</code> if timeout.  </p> <p>Register function, called on button event. Available event types: \u2022 <code>Button.evtRelease</code> \u2022 <code>Button.evtPress</code> \u2022 <code>Button.evtClick</code> \u2022 <code>Button.evtLongPress</code> \u2022 <code>Button.evtDoubleClick</code> Parameter: <code>function</code> - function name [<code>buttonEvent</code>]. Accepts two types of functions - with <code>evt</code> parameter and without. Event parameter is a convenient way to get event type without checking inside <code>loop()</code>. <code>void buttonEvent() { }</code> or  <code>void buttonEvent(int evt) { }</code>. <pre><code>void buttonEvent(int evt) {\n  if (evt == Button.evtPress) Serial.println(\"Button: evtPress\");\n  if (evt == Button.evtRelease) Serial.println(\"Button: evtRelease\");\n}\nvoid setup() {\n  button.addEvent(buttonEvent);\n}\nvoid loop() { }\n</code></pre></p>"},{"location":"roboboard/api/button/#waitLongPress-time","title":"<code>state</code> Button.waitLongPress(<code>time</code>)","text":""},{"location":"roboboard/api/button/#addEvent","title":"Button.addEvent(<code>function</code>)","text":""},{"location":"roboboard/api/button/#configuration","title":"Configuration","text":"<p>Set debounce time to prevent false reading during button latching. Parameters: <code>time</code> - debounce time (ms). Default: 20ms.  </p> <p>Set custom long press time for <code>isLongPress()</code> <code>wasLongPress()</code> functions. Parameters: <code>time</code> - press in time (ms). Default: 500ms.  </p>"},{"location":"roboboard/api/button/#setDebounceTime","title":"Button.setDebounceTime(<code>time</code> )","text":""},{"location":"roboboard/api/button/#setLongPressTime","title":"Button.setLongPressTime(<code>time</code> )","text":""},{"location":"roboboard/api/button/#external-gpio-button","title":"External GPIO button","text":"RoboBoard X3RoboBoard X4 <pre><code>IOButton gpioButton(IO33); // Button connected to pin IO33\ngpioButton.isPressed(); // Read button state\n</code></pre> <pre><code>IOButton gpioButton(GPIOA); // Button connected to pin GPIOA\ngpioButton.isPressed(); // Read button state\n</code></pre> <p><code>IOButton</code> can be used to control external button connected to any GPIO pin. It requires pin number and pin state on button press (for algorithm to know correct button position). All same functions are available as for <code>Button</code> object.</p> <p>Note: for \"longPress\" detection to work - only single button can be pressed at a time.</p> <p>Constructor:</p>"},{"location":"roboboard/api/button/#IOButton","title":"IOButton(<code>pin</code>)","text":"<p>Create button control object. Parameter: <code>pin</code> - GPIO pin number <code>pressLevel</code> - pin state when button is pressed [LOW:HIGH]. Default - LOW.  </p> <pre><code>IOButton button1(IO33); // Button on pin IO33. LOW when pressed\nIOButton button2(IO33, LOW); // Button on pin IO33. LOW when pressed\nIOButton button3(IO33, HIGH); // Button on pin IO33. HIGH when pressed\n</code></pre>"},{"location":"roboboard/api/button/#IOButton","title":"IOButton(<code>pin</code>,<code>pressLevel</code>)","text":""},{"location":"roboboard/api/can/","title":"CAN","text":"<p>CANH: CAN-High, CANL: CAN-Low, NC: Not Connected V-: Ground, 5V: 5V output, V+: BATT rail output (~12V)  </p> <p>Ports are interconnected and used for daisy-chaining. Rated for 1Amp. Cable is available in our store:  Totemmaker.net store \u2192 TOTEMBUS CABLE </p> <p>Interact with CAN bus network connected over TBUS (TotemBUS) connector. Has dual purpose: Plug into CAN bus networks or attach X4 extension modules.</p> <pre><code>void setup() {\n  // Start CAN peripheral at 500kbps\n  CAN.begin(500);\n}\nvoid loop() {\n  // Wait for CAN packet receive. 300ms timeout\n  if (CAN.readPacketWait(300)) {\n    // Get received packet\n    auto packet = CAN.getPacket();\n    // packet.id, packet.data, packet.len, packet.ext, packet.rtr\n  }\n  // Send CAN packets\n  uint8_t data[8] = {1,2,3,4,5,6,7,8};\n  CAN.writePacketExt(0x112233, data, 8); // Extended\n  CAN.writePacketStd(0x1AB, data, 8);    // Standard\n}\n</code></pre> <p>For more example code check: Examples \u2192 RoboBoard \u2192 CAN</p>"},{"location":"roboboard/api/can/#wiring","title":"Wiring","text":"X4 wiring with 3 MCP2515 modules <p>CAN bus network requires specific wiring with terminal resistors at each side of yellow and green wires. 120\u03a9 resistor is already present inside X4. Additional one should be added to the last node in the network. May use resistors inside module (if available) or external one.</p>"},{"location":"roboboard/api/can/#gui-monitor","title":"GUI Monitor","text":"<p>RoboBoard X4 is compatible with open source SavvyCAN application to monitor CAN bus traffic. For setup instructions check  totemmaker/ESP32RET repository.</p>"},{"location":"roboboard/api/can/#operating-modes","title":"Operating modes","text":"<p>CAN peripheral operates in 3 modes:  </p> <ul> <li>Normal - Send and received messages on CAN bus.</li> <li>Listen - Receive messages without influencing the bus (monitoring).</li> <li>Loopback - Sent messages will be received right away. Used for demo and testing purposes.</li> </ul> <p>Supported baud (kBits): 25, 50, 100, 125, 250, 500, 800, 1000</p> <p>Start CAN bus peripheral in Normal mode. Parameter: <code>baud</code>: CAN bus baud rate (kBits).  </p> <p>Start CAN bus peripheral in Listen mode. Note: There must be at least 2 devices on CAN bus for messaging to work, as RoboBoard won't send any packet acknowledgments. Can't use <code>writePacket</code> in this mode. Parameter: <code>baud</code>: CAN bus baud rate (kBits).  </p> <p>Start CAN bus peripheral in Loopback mode. Works without attached to CAN bus network. Each sent packet will loop back to receiver. Parameter: <code>baud</code>: CAN bus baud rate (kBits).  </p> <p>Stop CAN peripheral. Required to change working mode or hardware filter.  </p> <p>Check if CAN peripheral state is \"running\". Returns: <code>true</code>: CAN is running. <code>false</code>: CAN is non-functional.  </p> <p>Switch CAN peripheral between \"running\" and \"stopped\" states. Can be used to temporary stop packet transmit and reception. Parameter: <code>state</code> - <code>true</code>: put CAN to \"running\" state. <code>false</code>: put CAN to \"stopped\" state.  </p>"},{"location":"roboboard/api/can/#begin","title":"CAN.begin(<code>baud</code>)","text":""},{"location":"roboboard/api/can/#beginListen","title":"CAN.beginListen(<code>baud</code>)","text":""},{"location":"roboboard/api/can/#beginLoopback","title":"CAN.beginLoopback(<code>baud</code>)","text":""},{"location":"roboboard/api/can/#end","title":"CAN.end()","text":""},{"location":"roboboard/api/can/#isRunning","title":"<code>state</code> CAN.isRunning()","text":""},{"location":"roboboard/api/can/#setEnable","title":"CAN.setEnable(<code>state</code>)","text":""},{"location":"roboboard/api/can/#writing","title":"Writing","text":""},{"location":"roboboard/api/can/#writePacketStd","title":"CAN.writePacketStd(<code>id</code>,<code>data</code>,<code>len</code>)","text":"<p>Send CAN data packet. \"Std\" and \"Ext\" differs in identifier size: \u2022 Standard: 11-bit identifier [<code>0</code>:<code>0x7FF</code>]. \u2022 Extended: 29-bit identifier [<code>0</code>:<code>0x1FFFFFFF</code>]. Parameter: <code>id</code> - identifier. <code>data</code> - pointer to 8-bit array (or NULL if len = 0). <code>len</code> - length of \"data\" array. [<code>0</code>:<code>8</code>].  </p>"},{"location":"roboboard/api/can/#writePacketExt","title":"CAN.writePacketExt(<code>id</code>,<code>data</code>,<code>len</code>)","text":""},{"location":"roboboard/api/can/#writePacketStdRtr","title":"CAN.writePacketStdRtr(<code>id</code>,<code>len</code>)","text":"<p>Send Remote Transmission Request packet. \"Std\" and \"Ext\" differs in identifier size: \u2022 Standard: 11-bit identifier [<code>0</code>:<code>0x7FF</code>]. \u2022 Extended: 29-bit identifier [<code>0</code>:<code>0x1FFFFFFF</code>]. Parameter: <code>id</code> - identifier. <code>len</code> - data length field. [<code>0</code>:<code>8</code>].  </p> <p>Send CAN packet. Allows to select packet configuration trough parameters. If <code>rtr</code> is set - parameter <code>data</code> is ignored. Parameter: <code>ext</code> - <code>true</code>: extended packet. <code>false</code>: standard packet. <code>id</code> - identifier extended:[<code>0</code>:<code>0x1FFFFFFF</code>], standard: [<code>0</code>:<code>0x7FF</code>]. <code>data</code> - pointer to 8-bit array (or NULL if len = 0). <code>len</code> - length of \"data\" array. [<code>0</code>:<code>8</code>]. <code>rtr</code> - <code>true</code>: send RTR packet. <code>false</code>: send data packet. Default: <code>false</code>.  </p>"},{"location":"roboboard/api/can/#writePacketExtRtr","title":"CAN.writePacketExtRtr(<code>id</code>,<code>len</code>)","text":""},{"location":"roboboard/api/can/#writePacket","title":"CAN.writePacket(<code>ext</code>,<code>id</code>,<code>data</code>,<code>len</code>,<code>rtr</code>)","text":""},{"location":"roboboard/api/can/#reading","title":"Reading","text":"<p>Different message reception methods available. Only single one can be used at the time:  </p> <ul> <li>Event mode - messages will be received inside registered event handlers<ul> <li>Event is fired right after message is received</li> <li>Multiple application modules can register event for CAN reception</li> <li>Main loop is free to use for other application requirements</li> </ul> </li> <li>Polling mode - messages will be acquired using <code>readPacket</code> function inside a loop<ul> <li>Faster reception (bypassing event handling and context switching)</li> <li>Better handles high amount of data</li> </ul> </li> </ul>"},{"location":"roboboard/api/can/#event-mode","title":"Event mode","text":"<p>Register CAN packet receive event. Can be read using <code>getPacket()</code>. Parameter: <code>function</code> - function name.  </p> <p>Unregister CAN packet receive event. Passed function won't be called anymore. Parameter: <code>function</code> - registered function name.  </p> <pre><code>void eventCAN() {\n  auto packet = CAN.getPacket();\n  // packet.id, packet.data, packet.len, packet.ext, packet.rtr\n}\nvoid setup() {\n  CAN.begin(500);\n  CAN.addEvent(eventCAN);\n}\nvoid loop() {\n  // Free to use\n}\n</code></pre>"},{"location":"roboboard/api/can/#addEvent","title":"CAN.addEvent(<code>function</code>)","text":""},{"location":"roboboard/api/can/#removeEvent","title":"CAN.removeEvent(<code>function</code>)","text":""},{"location":"roboboard/api/can/#polling-mode","title":"Polling mode","text":"<p>Read received packet. Acquired packet is returned by function <code>getPacket()</code>. Each call will pull new packet from internal receive queue. Returns: <code>true</code>: packet is received. <code>false</code>: no packets available.  </p>"},{"location":"roboboard/api/can/#readPacket","title":"<code>state</code> CAN.readPacket()","text":""},{"location":"roboboard/api/can/#readPacketWait","title":"<code>state</code> CAN.readPacketWait()","text":"<p>Read received packet. Acquired packet is returned by function <code>getPacket()</code>. Each call will pull new packet from internal receive queue. Function will halt code execution until new packet is received or timeout is passed. Parameter: <code>timeout</code> - (ms) time to wait for packet. Default: 0 - indefinitely. Returns: <code>true</code>: packet is received. <code>false</code>: no packets available, timeout.  </p> <pre><code>void setup() {\n  CAN.begin(500);\n}\nvoid loop() {\n  if (CAN.readPacketWait(300)) {\n    auto packet = CAN.getPacket();\n    // packet.id, packet.data, packet.len, packet.ext, packet.rtr\n  }\n}\n</code></pre> <p>Return received CAN packet inside event function or after <code>readPacket()</code> returned <code>true</code>. Returns: <code>CANPacket</code> structure, containing packet information. <pre><code>struct CANPacket {\n    uint16_t ext : 1; // Is extended packet (or standard)\n    uint16_t rtr : 1; // Is Remote Transmit Request\n    int16_t filter; // Software filter that accepted packet (otherwise -1)\n    uint32_t id; // Packet identifier\n    uint8_t len; // Packet data length\n    uint8_t data[8]; // Packet data array\n};\n</code></pre></p>"},{"location":"roboboard/api/can/#readPacketWait-timeout","title":"<code>state</code> CAN.readPacketWait(<code>timeout</code>)","text":""},{"location":"roboboard/api/can/#getPacket","title":"<code>CANPacket</code> CAN.getPacket()","text":""},{"location":"roboboard/api/can/#filters","title":"Filters","text":"<p>Filters will be applied to all received messages and intercepted only if <code>id</code> and <code>mask</code> parameters matches. Used to receive only specific packets, ignoring anything else.</p>"},{"location":"roboboard/api/can/#software","title":"Software","text":"<p>Software filters are running inside application, but has a few more advantages: \u2022 Associate received packet with filter it matched <code>packet.filter</code>. \u2022 Add and remove filters when CAN peripheral is running. \u2022 Add up to 16 filters.  </p> <p>Set standard software filter. Parameter: <code>num</code> - filter slot number [<code>0</code>:<code>15</code>]. <code>id</code> - identifier [<code>0</code>:<code>0x7FF</code>]. <code>mask</code> - validated identifier bits [<code>0</code>:<code>0x7FF</code>].  </p> <p>Set extended software filter. Parameter: <code>num</code> - filter slot number [<code>0</code>:<code>15</code>]. <code>id</code> - identifier [<code>0</code>:<code>0x1FFFFFFF</code>]. <code>mask</code> - validated identifier bits [<code>0</code>:<code>0x1FFFFFFF</code>].  </p> <p>Disable filter on selected slot (num). Parameter: <code>num</code> - filter slot number [<code>0</code>:<code>15</code>]. <code>-1</code> - disable all filters.  </p> Software filter example<pre><code>void setup() {\n    CAN.begin(500);\n    // Allow to receive only standard packets:\n    // 0x0A1 0x1A1 0x2A1 0x3A1 0x4A1 0x5A1 0x6A1 0x7A1\n    // 0x0A2 0x1A2 0x2A2 0x3A2 0x4A2 0x5A2 0x6A2 0x7A2\n    CAN.setFilterStd(0, 0xA1, 0xFF);\n    CAN.setFilterStd(1, 0xA2, 0xFF);\n}\n</code></pre>"},{"location":"roboboard/api/can/#setFilterStd","title":"CAN.setFilterStd(<code>num</code>,<code>id</code>,<code>mask</code>)","text":""},{"location":"roboboard/api/can/#setFilterExt","title":"CAN.setFilterExt(<code>num</code>,<code>id</code>,<code>mask</code>)","text":""},{"location":"roboboard/api/can/#resetFilter","title":"CAN.resetFilter(<code>num</code>)","text":""},{"location":"roboboard/api/can/#hardware","title":"Hardware","text":"<p>Hardware filters are limited, but efficient with high amount of data. Notice: \u2022 Must be configured before calling <code>CAN.begin()</code>. \u2022 Only single one of \"setHardware\" function can be used.  </p> <p>Set single standard hardware filter. Parameter: <code>id</code> - identifier [<code>0</code>:<code>0x7FF</code>]. <code>mask</code> - validated identifier bits [<code>0</code>:<code>0x7FF</code>].  </p> <p>Set single extended hardware filter. Parameter: <code>id</code> - identifier [<code>0</code>:<code>0x1FFFFFFF</code>]. <code>mask</code> - validated identifier bits [<code>0</code>:<code>0x1FFFFFFF</code>].  </p> <p>Set dual hardware filter. Can filter out 2 different standard packets. Parameter: <code>id1</code>, <code>id2</code> - identifier [<code>0</code>:<code>0x7FF</code>]. <code>mask1</code>, <code>mask2</code> - validated identifier bits [<code>0</code>:<code>0x7FF</code>].  </p> <p>Set hardware filter manually. Allows for some additional configuration. For meaning of <code>code</code> and <code>mask</code> read: ESP32 \u2192 TWAI \u2192 Acceptance Filter. Parameter: <code>code</code> - 32-bit code. <code>mask</code> - 32-bit mask. <code>single</code> - <code>true</code>: single filter, <code>false</code>: dual filter.  </p> Hardware filter example<pre><code>void setup() {\n    // Allow to receive only standard packets:\n    // 0x0A1 0x1A1 0x2A1 0x3A1 0x4A1 0x5A1 0x6A1 0x7A1\n    CAN.setHardwareFilterStd(0xA1, 0xFF);\n    CAN.begin(500);\n}\n</code></pre>"},{"location":"roboboard/api/can/#setHardwareFilterStd","title":"CAN.setHardwareFilterStd(<code>id</code>,<code>mask</code>)","text":""},{"location":"roboboard/api/can/#setHardwareFilterExt","title":"CAN.setHardwareFilterExt(<code>id</code>,<code>mask</code>)","text":""},{"location":"roboboard/api/can/#setHardwareFilterDual","title":"CAN.setHardwareFilterDual(<code>id1</code>,<code>mask1</code>,<code>id2</code>,<code>mask2</code>)","text":""},{"location":"roboboard/api/can/#setHardwareFilter","title":"CAN.setHardwareFilter(<code>code</code>,<code>mask</code>,<code>single</code>)","text":""},{"location":"roboboard/api/can/#bus-info","title":"Bus info","text":"<p>Read CAN peripheral alerts (if any). Returned value is reset each function call. Returns: <code>alerts</code> - 32-bit value of active alerts. See TWAI - Alerts for description. Definitions are available in <code>#include \"driver/twai.h\"</code> </p> <p>Read amount of queued RX messages. Returns: <code>count</code> - number of messages awaiting for read with <code>readPacket</code>.</p>"},{"location":"roboboard/api/can/#readAlerts","title":"<code>alerts</code> CAN.readAlerts()","text":""},{"location":"roboboard/api/can/#readRxCount","title":"<code>count</code> CAN.readRxCount()","text":""},{"location":"roboboard/api/dc/","title":"DC","text":"<p>Note: motor wire colors (red, black) does not indicate polarity (+, -). Swapping wires only changes spin direction.</p> <p>Control interface for RoboBoard DC H-bridge motor drivers. May access specific port or all at once:  </p> <ul> <li><code>DC.A</code>, <code>DC.B</code>, <code>DC.C</code>, <code>DC.D</code> - control single port  </li> <li><code>DC[0]</code> - control port A [<code>1</code>-B, <code>2</code>-C, <code>3</code>-D] (invalid indexes will be ignored) </li> <li><code>DC</code> - control all ports (some \"get\" functions are not available in this case) </li> </ul>"},{"location":"roboboard/api/dc/#code-snippets","title":"Code snippets","text":"Function usage example<pre><code>// Control all DC ports\nDC.spin(-50); // Spin backward at 50% power\nDC.spin(0); // Stop spin\nDC.brake(); // Brake motor\nDC.coast(); // Free spin (no breaking and power)\n// Play tone on all motors\nDC.tone(5000); // Play 5kHz tone trough motor coils\n// Change ports PWM frequency\nDC.setFrequency(50); // Set PWM frequency to 50Hz\n// Brake DC port B\nDC[1].brake();\n// Configure DC A port\nDC.A.setRange(10, 90); // Set power range to [10% : 90%]\nDC.A.setAccelerationTime(300); // Set acceleration to 300ms\nDC.A.setDecelerationTime(150); // Set acceleration to 150ms\nDC.A.setInvert(true); // Invert spin direction\n</code></pre> <p>Output ports are directly connected to battery trough motor driver and controlled using PWM modulation. Peak voltage is dependent on SOC of battery. This can vary between 8.4V - 12.6V (X4) and 2.8V - 4.2V (X3). The higher the voltage, the faster motor will spin.  </p>"},{"location":"roboboard/api/dc/#functions","title":"Functions","text":"<p>DC motor can be in 1 of 3 different states:</p> <ul> <li>Spin - spinning forward / backward at 0-100% of power</li> <li>Brake - braking (stopping) at 0-100% of power</li> <li>Tone - vibrating coils to generate audible tone</li> </ul>"},{"location":"roboboard/api/dc/#spin-motors","title":"Spin motors","text":"<p>Spin motor at specified amount of power (%) and direction. <code>-</code>(backward),<code>+</code>(forward), <code>0</code>(no power). Parameter: <code>power</code> - output power [<code>-100</code>:<code>100</code>]%.</p>"},{"location":"roboboard/api/dc/#spin","title":"DC.A.spin(<code>power</code>)","text":""},{"location":"roboboard/api/dc/#brake","title":"DC.A.brake()","text":"<p>Brake motor at specified amount of power (%). Electric brake only. Does not hold wheel in place. Parameter: <code>power</code> - set brake power [<code>0</code>:<code>100</code>]%. Default: 100.</p> <p>Free spin motor (no power, no brake). Same as <code>brake(0)</code>.  </p> <p>Get motor current spin power (%) and direction. <code>-</code>(backward),<code>+</code>(forward), <code>0</code>(no power). Returns: <code>power</code> - output power [<code>-100</code>:<code>100</code>]%.</p> <p>Get motor current braking power (%). Returns: <code>power</code> - brake power [<code>0</code>:<code>100</code>]%.</p>"},{"location":"roboboard/api/dc/#brake","title":"DC.A.brake(<code>power</code>)","text":""},{"location":"roboboard/api/dc/#coast","title":"DC.A.coast()","text":""},{"location":"roboboard/api/dc/#getSpin","title":"<code>power</code> DC.A.getSpin()","text":""},{"location":"roboboard/api/dc/#getBrake","title":"<code>power</code> DC.A.getBrake()","text":""},{"location":"roboboard/api/dc/#tone-output","title":"Tone output","text":"<p>Danger</p> <p>Do not use tone function for a long period of time. This may overheat the motors.</p> <p>Play tone (sound) by vibrating DC motor coil. Similar as Arduino <code>tone()</code> function, but with motors. Outputs audible range up to 20kHz. At low frequencies motor may shake a little.</p>"},{"location":"roboboard/api/dc/#tone","title":"DC.tone(<code>frequency</code>)","text":"<p>Start vibrating all DC motors at specified frequency. Parameter: <code>frequency</code> - tone frequency [<code>0</code>:<code>20000</code>]Hz. <code>0</code> - stop. <code>duration</code> - output duration [<code>0</code>:<code>65535</code>]ms. <code>0</code> - indefinitely (default).  </p> <p>Get currently applied tone. Returns: <code>frequency</code> - tone frequency [<code>0</code>:<code>20000</code>]Hz.  </p>"},{"location":"roboboard/api/dc/#tone-duration","title":"DC.tone(<code>frequency</code>,<code>duration</code>)","text":""},{"location":"roboboard/api/dc/#getTone","title":"<code>number</code> DC.getTone()","text":""},{"location":"roboboard/api/dc/#acceleration","title":"Acceleration","text":"<p>Configure motor acceleration and deceleration time. These gradual increase or decrease in speed is applied when changing motor output power with <code>spin()</code>. Any difference between old value and target one will transit gradually. Typically used for tall robots to prevent tip over or gradually spin up some high mass object. Configuration takes parameter of maximum amount of time required to change speed between 0% and 100%. Example: Setting <code>setAccelerationTime(1000)</code>, motor will require 1 second to reach maximum speed from stand still to 100%.</p> <p>Check if motor is currently in acceleration or deceleration state. Returns: <code>state</code> - yes / no [<code>true</code>,<code>false</code>].  </p>"},{"location":"roboboard/api/dc/#isAccelerating","title":"<code>state</code> DC.A.isAccelerating()","text":""},{"location":"roboboard/api/dc/#wait","title":"<code>state</code> DC.A.wait()","text":"<p>Wait until motor finishes accelerating or decelerating (block code until). Parameter: <code>time</code> - maximum time to wait (ms) for motor to finish. <code>0</code> - disabled. Returns: <code>state</code> - <code>true</code> if motor finished, <code>false</code> if timeout.  </p> <p>Configure amount of time required to accelerate motor from 0% to 100%. Parameter: <code>time</code> - acceleration time in milliseconds. <code>0</code> - disabled.  </p> <p>Configure amount of time required to decelerate motor from 100% to 0%. If disabled - motor will stop by free spinning (from inertia) or braking (if autobrake enabled). Parameter: <code>time</code> - deceleration time in milliseconds. <code>0</code> - disabled.  </p> <p>Get configured amount of time for motor acceleration from 0% to 100%. Returns: <code>number</code> - acceleration time in milliseconds. <code>0</code> - disabled.  </p> <p>Get configured amount of time for motor deceleration from 100% to 0%. Returns: <code>number</code> - deceleration time in milliseconds. <code>0</code> - disabled.  </p>"},{"location":"roboboard/api/dc/#wait","title":"<code>state</code> DC.A.wait(<code>time</code>)","text":""},{"location":"roboboard/api/dc/#setAccelerationTime","title":"DC.A.setAccelerationTime(<code>time</code>)","text":""},{"location":"roboboard/api/dc/#setDecelerationTime","title":"DC.A.setDecelerationTime(<code>time</code>)","text":""},{"location":"roboboard/api/dc/#getAccelerationTime","title":"<code>number</code> DC.A.getAccelerationTime()","text":""},{"location":"roboboard/api/dc/#getDecelerationTime","title":"<code>number</code> DC.A.getDecelerationTime()","text":""},{"location":"roboboard/api/dc/#configure","title":"Configure","text":"<p>Turn motor port on / off to disable any output.  </p> <p>Invert DC motor spin direction (swaps polarity + -). Parameter: <code>state</code> - is inverted spin direction [<code>true</code>:<code>false</code>]  </p> <p>Set automatic brake. Will apply brake when <code>spin()</code> is set to <code>0</code>. Used to prevent motor from free spinning. Parameter: <code>power</code> - automatic brake power [<code>0</code>:<code>100</code>]% or [<code>false</code>:<code>true</code>].</p> <p>Set motor power range limits. Doing so - motor will start spin at <code>min</code> power and does not overstep <code>max</code>. Used to boost motor at low speed and limit max voltage. Applied spin power 0-100% <code>spin()</code> will be mapped to configured range. RoboBoard X4 default: [<code>10</code>:<code>100</code>]. Parameter: <code>min</code> - minimum percentage required to start spinning a motor. Default: <code>0</code> <code>max</code> - maximum allowed percentage of power for the motor. Default: <code>100</code> </p>"},{"location":"roboboard/api/dc/#setEnable","title":"DC.A.setEnable(<code>state</code>)","text":""},{"location":"roboboard/api/dc/#setInvert","title":"DC.A.setInvert(<code>state</code>)","text":""},{"location":"roboboard/api/dc/#setAutobrake","title":"DC.A.setAutobrake(<code>power</code>)","text":""},{"location":"roboboard/api/dc/#setRange","title":"DC.A.setRange(<code>min</code>,<code>max</code>)","text":""},{"location":"roboboard/api/dc/#setFastDecay","title":"DC.A.setFastDecay()","text":"<p>Set coil current dissipation speed (fast or slow). Changes motor behavior. Fast decay mode: Motor free spins during speed change. Slow decay mode: More linear speed control. Better torque at low speed. Note: RoboBoard X4 requires driver version <code>1.60</code> or later. </p> <p>Get settings:</p> <p>Check if motor port is enabled. Returns: <code>state</code> - enabled / disabled [<code>true</code>:<code>false</code>].  </p> <p>Check if motor spin direction is inverted. Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>].  </p> <p>Get configured automatic brake power (if enabled). Returns: <code>state</code> - braking power [<code>0</code>:<code>100</code>]%.  </p> <p>Get configured motor port power range. Returns: <code>Range</code> - Range structure. <pre><code>void setup() {\n    auto range = DC.A.getRange();\n    range.min;\n    range.max;\n    // Alternative use\n    DC.A.getRange().min;\n    DC.A.getRange().max;\n}\n</code></pre></p>"},{"location":"roboboard/api/dc/#setSlowDecay","title":"DC.A.setSlowDecay()","text":""},{"location":"roboboard/api/dc/#getEnable","title":"<code>state</code> DC.A.getEnable()","text":""},{"location":"roboboard/api/dc/#getInvert","title":"<code>state</code> DC.A.getInvert()","text":""},{"location":"roboboard/api/dc/#getAutobrake","title":"<code>state</code> DC.A.getAutobrake()","text":""},{"location":"roboboard/api/dc/#getRange","title":"<code>Range</code> DC.A.getRange()","text":""},{"location":"roboboard/api/dc/#getFastDecay","title":"<code>state</code> DC.A.getFastDecay()","text":"<p>Get selected decay mode (fast or slow). Returns: <code>state</code> - <code>true</code> if mode is selected.  </p> <p>Configure PWM frequency:</p> <p>Set DC ports PWM frequency. Default: 20kHz. Can be changed if certain application or motor requires so. Parameter: <code>frequency</code> - PWM frequency [<code>1</code>:<code>65535</code>]Hz.  </p> <p>Get configured DC ports PWM frequency. Returns: <code>number</code> - PWM frequency [<code>1</code>:<code>65535</code>]Hz.  </p>"},{"location":"roboboard/api/dc/#getSlowDecay","title":"<code>state</code> DC.A.getSlowDecay()","text":""},{"location":"roboboard/api/dc/#setFrequency","title":"DC.setFrequency(<code>frequency</code>)","text":""},{"location":"roboboard/api/dc/#getFrequency","title":"<code>number</code> DC.getFrequency()","text":""},{"location":"roboboard/api/drivetrain/","title":"Drivetrain","text":"<p>Most common robot configuration is direct motor driven wheels strapped to its chassis. Even it looks simple enough, there are different configurations and algorithms for improved agility and control response. <code>Drivetrain.</code> object allows to define robot wheel base and control its movement with a few simple lines of code. This includes drive forward / backward, turn left / right and drive to side (mecanum).</p>"},{"location":"roboboard/api/drivetrain/#drivetrain-types","title":"Drivetrain types","text":"Steer drive Tank drive Mecanum drive Standard car wheel base with Ackermann steering. Vehicle with track drive (or simple wheels). Steers by changing speed of left and right side.Also called Arcade drive. Drivetrain with 4 Mecanum wheels (with 45\u00b0 rollers). Allows omnidirectional movement. Move directions:\u2022 Drive forward / backward\u2022 Steer left / right Move directions:\u2022 Drive forward / backward\u2022 Turn left / right\u2022 Spin (in place) left / right Move directions:\u2022 Drive forward / backward\u2022 Turn left / right\u2022 Spin (in place) left / right\u2022 Drive to side left / right"},{"location":"roboboard/api/drivetrain/#code-snippets","title":"Code snippets","text":"Steer driveTank driveMecanum drive <pre><code>void setup() {\n  // Setup Steer drive\n  Drivetrain.setWheelLeft(DC.A); // Left wheel\n  Drivetrain.setWheelRight(DC.B); // Right wheel\n  Drivetrain.setDriveSteer(); // Select \"Steer\" drivetrain\n  // Steering wheels connected to Servo port A\n  Servo.A.setInvert(true); // Invert servo spin direction\n  Servo.A.setTrim(-38, -7, 18); // Trim servo to correct steer angles\n}\nvoid loop() {\n  // Drive forward at 50% power and turn left 40%\n  Drivetrain.driveTurn(50, -40);\n  // Drivetrain.brake(); // Brake wheels\n}\n</code></pre> <pre><code>void setup() {\n  // Setup Tank drive\n  Drivetrain.setWheelLeft(DC.A); // Left wheel\n  Drivetrain.setWheelRight(DC.B); // Right wheel\n  Drivetrain.setDriveTank(); // Select \"Tank\" drivetrain\n}\nvoid loop() {\n  // Drive backward at 40% power with 30% turn right\n  Drivetrain.driveTurn(-40);\n  // Drivetrain.brake(); // Brake wheels\n}\n</code></pre> <pre><code>void setup() {\n  // Setup Mecanum drive\n  Drivetrain.setWheelLeftFront(DC.A); // Left front wheel\n  Drivetrain.setWheelRightFront(DC.B); // Right front wheel\n  Drivetrain.setWheelLeftRear(DC.C); // Left rear wheel\n  Drivetrain.setWheelRightRear(DC.D); // Right rear wheel\n  Drivetrain.setDriveMecanum(); // Select \"Mecanum\" drivetrain\n  DC.setAutobrake(true); // Brake all motors if power set to 0\n}\nvoid loop() {\n  // Move diagonally to 45 degrees with 80% power and 30% turning left\n  Drivetrain.driveTurnDirection(80, -30, 45);\n}\n</code></pre>"},{"location":"roboboard/api/drivetrain/#initial-setup","title":"Initial setup","text":"<p>Drivetrain algorithm requires knowledge of robot chassis configuration. This is depended on where motors are placed, which port is connected and spin direction when power is applied. Recommended to use <code>Initial_setup.ino</code> example to correctly assign each wheel.</p> <pre><code>//      ___\n// A |-|   |-| B\n//     |   |\n// C |-|___|-| D\n//\nvoid setup() {\n  // Set left front wheel to port DC A\n  Drivetrain.setWheelLeftFront(DC.A);\n  // Set right front wheel to port DC B\n  // Also invert motor spin direction\n  Drivetrain.setWheelRightFront(DC.B, true);\n  // Set rear wheels\n  Drivetrain.setWheelLeftRear(DC.C); // Left rear wheel\n  Drivetrain.setWheelRightRear(DC.D); // Right rear wheel\n  // Select algorithm logic to drive configured wheels\n  Drivetrain.setDriveTank();\n}\nvoid loop() {\n  // Spin motors using selected drive algorithm\n  Drivetrain.drive(100);\n}\n</code></pre>"},{"location":"roboboard/api/drivetrain/#additional-features","title":"Additional features","text":"<p>Drivetrain module only implements wheel configuration and movement algorithms. For an additional control features check <code>DC</code> and <code>Servo</code> sections.</p> <ul> <li><code>DC.setAccelerationTime(time)</code> - control robot acceleration speed.  </li> <li><code>DC.setDecelerationTime(time)</code> - control robot deceleration speed.  </li> <li><code>DC.setAutobrake(true)</code> - brake motors to prevent wheel free spin.  </li> <li><code>DC.setRange(min, max)</code> - limit motor power.  </li> <li><code>Servo.setTrim(min, min, max)</code> - set servo motor motion limits.  </li> <li><code>Servo.setSpeedRPM(rpm)</code> - set servo motor motion limits.  </li> <li><code>Servo.run(sequence)</code> - move servo in predefined pattern.  </li> </ul>"},{"location":"roboboard/api/drivetrain/#functions","title":"Functions","text":""},{"location":"roboboard/api/drivetrain/#configure-wheels","title":"Configure wheels","text":"<p>Each \"setWheel\" function contains additional <code>invert</code> parameter to flip motor spin direction. Example: <code>Drivetrain.setWheelLeftFront(DC.A, true)</code>. (a shortcut for using <code>motor.setInvert(true)</code>).</p>"},{"location":"roboboard/api/drivetrain/#setWheelLeft","title":"Drivetrain.setWheelLeft(<code>motor</code>)","text":""},{"location":"roboboard/api/drivetrain/#setWheelLeftFront","title":"Drivetrain.setWheelLeftFront(<code>motor</code>)","text":"<p>Select robot left side wheel. Available configurations: 1. Single wheel on left side <code>setWheelLeft()</code>. 2. Front and Rear wheels on left side <code>setWheelLeftFront()</code>, <code>setWheelLeftRear()</code>. Parameter: <code>motor</code> - RoboBoard port [<code>DC.A</code>,<code>DC.B</code>,<code>DC.C</code>,<code>DC.D</code>]. <code>invert</code> - (optional) flip motor spin direction yes / no [<code>true</code>:<code>false</code>].  </p>"},{"location":"roboboard/api/drivetrain/#setWheelLeftRear","title":"Drivetrain.setWheelLeftRear(<code>motor</code>)","text":""},{"location":"roboboard/api/drivetrain/#setWheelRight","title":"Drivetrain.setWheelRight(<code>motor</code>)","text":""},{"location":"roboboard/api/drivetrain/#setWheelRightFront","title":"Drivetrain.setWheelRightFront(<code>motor</code>)","text":"<p>Select robot right side wheel. Available configurations: 1. Single wheel on right side <code>setWheelRight()</code>. 2. Front and Rear wheels on right side <code>setWheelRightFront()</code>, <code>setWheelRightRear()</code>. Parameter: <code>motor</code> - RoboBoard port [<code>DC.A</code>,<code>DC.B</code>,<code>DC.C</code>,<code>DC.D</code>]. <code>invert</code> - (optional) flip motor spin direction yes / no [<code>true</code>:<code>false</code>].  </p>"},{"location":"roboboard/api/drivetrain/#setWheelRightRear","title":"Drivetrain.setWheelRightRear(<code>motor</code>)","text":""},{"location":"roboboard/api/drivetrain/#getWheelLeftFront","title":"<code>motor</code> Drivetrain.getWheelLeftFront()","text":""},{"location":"roboboard/api/drivetrain/#getWheelLeftRear","title":"<code>motor</code> Drivetrain.getWheelLeftRear()","text":""},{"location":"roboboard/api/drivetrain/#getWheelRightFront","title":"<code>motor</code> Drivetrain.getWheelRightFront()","text":"<p>Get motor interface of configured wheel. If not configured - returns dummy object (doing nothing). Returns: <code>motor</code> - <code>MotorInterface</code> object.  </p>"},{"location":"roboboard/api/drivetrain/#getWheelRightRear","title":"<code>motor</code> Drivetrain.getWheelRightRear()","text":""},{"location":"roboboard/api/drivetrain/#configure-drivetrain","title":"Configure drivetrain","text":"<p>Select drive algorithm. Specifies how robot wheels should behave.  </p>"},{"location":"roboboard/api/drivetrain/#setDriveTank","title":"Drivetrain.setDriveTank()","text":""},{"location":"roboboard/api/drivetrain/#setDriveMecanum","title":"Drivetrain.setDriveMecanum()","text":"<p>Select drive algorithm. Parameter: <code>servo</code> - (optional) <code>Servo</code> object. By default <code>Servo.A</code> is used.</p> <p>Set limit for maximum robot speed. Will divide value passed to <code>drive()</code> function. Parameter: <code>power</code> - max percentage of speed [<code>0</code>:<code>100</code>]%. Default: 100  </p> <p>Get configured limit for maximum robot speed. Parameter: <code>number</code> - max percentage of speed [<code>0</code>:<code>100</code>]%.  </p>"},{"location":"roboboard/api/drivetrain/#setDriveSteer","title":"Drivetrain.setDriveSteer(<code>servo</code>)","text":""},{"location":"roboboard/api/drivetrain/#setMaxSpeed","title":"Drivetrain.setMaxSpeed(<code>power</code>)","text":""},{"location":"roboboard/api/drivetrain/#getMaxSpeed","title":"<code>number</code> Drivetrain.getMaxSpeed()","text":""},{"location":"roboboard/api/drivetrain/#move-robot","title":"Move robot","text":"<p>Instruct robot to move in specified direction. It calculates trajectory depending on selected drivetrain algorithm and parameter percentage. Available parameters:</p> <ul> <li>\"drive\" - drive forward or backward</li> <li>\"turn\" - turn robot to left or right</li> <li>\"direction\" - drive to angle in 360 degrees (mecanum drive only)</li> <li>\"brake\" - stop with braking</li> <li>\"handbrake\" - slow down robot. Same effect as pressing gas and brake pedals at the same time</li> </ul>"},{"location":"roboboard/api/drivetrain/#brake","title":"Drivetrain.brake()","text":"<p>Stop driving with wheel braking. Electric brake only. Does not hold wheel in place. Parameter: <code>power</code> - amount of brake power [<code>0</code>:<code>100</code>]%.  </p>"},{"location":"roboboard/api/drivetrain/#brake","title":"Drivetrain.brake(<code>power</code>)","text":""},{"location":"roboboard/api/drivetrain/#handbrake","title":"Drivetrain.handbrake()","text":"<p>Reduce driving speed by adding resistance. If brake power is greater than speed - electric brake is engaged. Need to call <code>handbrake(0)</code> to release the brake. Electric brake only. Does not hold wheel in place. Parameter: <code>power</code> - amount of brake power [<code>0</code>:<code>100</code>]%.  </p> <p>Stop driving with free wheel spin (no power, no brake).  </p> <p>Start driving forward or backward at percentage of speed. Parameter: <code>driveSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward)  </p> <p>Start turning left or right at percentage of speed. In Steer drive this will turn servo motor A and controls rear wheels differential speed. Parameter: <code>turnSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(left), <code>+</code>(right).  </p> <p>Start driving forward or backward with turning left or right at the same time. Move trajectory is combined by drive and turn speeds. Parameter: <code>driveSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward) <code>turnSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(left), <code>+</code>(right)  </p> <p>Start driving to specified degree of angle with percentage of speed. May be used with combination of joystick magnitude and angle. Mecanum drivetrain only. Parameter: <code>driveSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward) <code>driveAngle</code> - [<code>0</code>:<code>359</code>]\u00b0. <code>0</code>(forward), <code>90</code>(right), <code>180</code>(backward), <code>270</code>(left)  </p> <p>Start driving to specified degree of angle with percentage of speed and turning. Mecanum drivetrain only. Parameter: <code>driveSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward) <code>turnSpeed</code> - [<code>-100</code>:<code>100</code>]%. <code>-</code>(left), <code>+</code>(right) <code>driveAngle</code> - [<code>0</code>:<code>359</code>]\u00b0. <code>0</code>(forward), <code>90</code>(right), <code>180</code>(backward), <code>270</code>(left)  </p> <p>Start spinning left and right wheels at different speed and directions. Mainly used with Tank drivetrain for individual track control. Parameter: <code>left</code> - left wheels speed [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward) <code>right</code> - right wheels speed [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward)  </p> <p>Start spinning each configured wheel individually. Parameter: <code>LF</code> <code>RF</code> <code>LR</code> <code>RR</code> - wheel speed [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward)  </p> <p>Returns: <code>power</code> - amount of brake applied [<code>0</code>:<code>100</code>]%.  </p> <p>Returns: <code>speed</code> - drive speed [<code>-100</code>:<code>100</code>]%. <code>-</code>(backward), <code>+</code>(forward)  </p> <p>Returns: <code>speed</code> - turn speed [<code>-100</code>:<code>100</code>]%. <code>-</code>(left), <code>+</code>(right)  </p> <p>Mecanum drivetrain only. Returns: <code>angle</code> - drive direction [<code>0</code>:<code>359</code>]\u00b0. <code>0</code>(forward), <code>90</code>(right), <code>180</code>(backward), <code>270</code>(left) </p> <p>Check if robot is currently moving (power is applied). Returns: <code>state</code> - <code>true</code> if robot is moving. <code>false</code> not moving.  </p>"},{"location":"roboboard/api/drivetrain/#handbrake","title":"Drivetrain.handbrake(<code>power</code>)","text":""},{"location":"roboboard/api/drivetrain/#coast","title":"Drivetrain.coast()","text":""},{"location":"roboboard/api/drivetrain/#drive","title":"Drivetrain.drive(<code>driveSpeed</code>)","text":""},{"location":"roboboard/api/drivetrain/#turn","title":"Drivetrain.turn(<code>turnSpeed</code>)","text":""},{"location":"roboboard/api/drivetrain/#driveTurn","title":"Drivetrain.driveTurn(<code>driveSpeed</code>, <code>turnSpeed</code>)","text":""},{"location":"roboboard/api/drivetrain/#driveDirection","title":"Drivetrain.driveDirection(<code>driveSpeed</code>, <code>driveAngle</code>)","text":""},{"location":"roboboard/api/drivetrain/#driveTurnDirection","title":"Drivetrain.driveTurnDirection(<code>driveSpeed</code>, <code>turnSpeed</code>, <code>driveAngle</code>)","text":""},{"location":"roboboard/api/drivetrain/#spinLeftRight","title":"Drivetrain.spinLeftRight(<code>left</code>, <code>right</code>)","text":""},{"location":"roboboard/api/drivetrain/#spinWheels","title":"Drivetrain.spinWheels(<code>LF</code>, <code>RF</code>, <code>LR</code>, <code>RR</code>)","text":""},{"location":"roboboard/api/drivetrain/#getBrake","title":"<code>power</code> Drivetrain.getBrake()","text":""},{"location":"roboboard/api/drivetrain/#getDrive","title":"<code>speed</code> Drivetrain.getDrive()","text":""},{"location":"roboboard/api/drivetrain/#getTurn","title":"<code>speed</code> Drivetrain.getTurn()","text":""},{"location":"roboboard/api/drivetrain/#getDirection","title":"<code>angle</code> Drivetrain.getDirection()","text":""},{"location":"roboboard/api/drivetrain/#isMoving","title":"<code>state</code> Drivetrain.isMoving()","text":""},{"location":"roboboard/api/drivetrain/#joystick-input","title":"Joystick input","text":"<p>Helper functions to convert joystick / gamepad input to values suitable for motor control. Takes care of value range and smooth control input.</p> <pre><code>int button = Joystick::getTrigger(gamepad.button.r1);\nint turn = Joystick::getAxis(3, gamepad.stick.rx);\nint angle = Joystick::getAngle(gamepad.stick.lx, gamepad.stick.ly);\nint magnitude = Joystick::getMagnitude(gamepad.stick.lx, gamepad.stick.ly);\n\nDrivetrain.driveTurnDirection(magnitude, turn, angle);\n</code></pre>"},{"location":"roboboard/api/drivetrain/#getTrigger","title":"<code>power</code> Joystick::getTrigger(<code>input</code>)","text":"<p>Get amount of trigger button is pressed. Parameter: <code>input</code> - raw joystick button input [<code>0</code>:<code>255</code>]. <code>exp</code> - exponent value to increase precision at low speed [<code>1</code>:<code>4</code>]. Default: 2. Returns: <code>power</code> - amount of button pressed [<code>0</code>:<code>100</code>]%.  </p>"},{"location":"roboboard/api/drivetrain/#getTrigger","title":"<code>power</code> Joystick::getTrigger(<code>exp</code>, <code>input</code>)","text":""},{"location":"roboboard/api/drivetrain/#getAxis","title":"<code>position</code> Joystick::getAxis(<code>input</code>)","text":"<p>Get joystick axis position. Parameter: <code>input</code> - raw joystick axis input [<code>-127</code>:<code>128</code>]. <code>exp</code> - exponent value to increase precision at low speed [<code>1</code>:<code>4</code>]. Default: 2. Returns: <code>position</code> - axis position [<code>-100</code>:<code>100</code>]%. 0 - center.  </p>"},{"location":"roboboard/api/drivetrain/#getAxis","title":"<code>position</code> Joystick::getAxis(<code>exp</code>, <code>input</code>)","text":""},{"location":"roboboard/api/drivetrain/#getAngle","title":"<code>angle</code> Joystick::getAngle(<code>x</code>, <code>y</code>)","text":"<p>Get joystick angle (degree) from center. Parameter: <code>x</code> - raw joystick X axis input [<code>-127</code>:<code>128</code>]. <code>y</code> - raw joystick Y axis input [<code>-127</code>:<code>128</code>]. <code>exp</code> - exponent value to increase precision at low speed [<code>1</code>:<code>4</code>]. Default: 2. Returns: <code>angle</code> - joystick lean angle [<code>0</code>:<code>359</code>]\u00b0. <code>0</code> - pointing up.  </p>"},{"location":"roboboard/api/drivetrain/#getAngle","title":"<code>angle</code> Joystick::getAngle(<code>exp</code>, <code>x</code>, <code>y</code>)","text":""},{"location":"roboboard/api/drivetrain/#getMagnitude","title":"<code>power</code> Joystick::getMagnitude(<code>x</code>, <code>y</code>)","text":"<p>Get joystick amount pushed from center to side. Parameter: <code>x</code> - raw joystick X axis input [<code>-127</code>:<code>128</code>]. <code>y</code> - raw joystick Y axis input [<code>-127</code>:<code>128</code>]. <code>exp</code> - exponent value to increase precision at low speed [<code>1</code>:<code>4</code>]. Default: 2. Returns: <code>power</code> - joystick lean amount [<code>0</code>:<code>100</code>]%.  </p> <p>Default configuration values</p> <p>Raw joystick input range. Default: <code>127</code>.  </p> <p>Standard input exponent value [<code>1</code>:<code>4</code>]. Default: <code>2</code>. input<sup>exponent</sup> </p> <p>Joystick deadzone [<code>0</code>:<code>100</code>]%. Default: <code>0</code>. Note: disabled by default as <code>exponent</code> feature discards small values when stick is stationary.</p>"},{"location":"roboboard/api/drivetrain/#getMagnitude","title":"<code>power</code> Joystick::getMagnitude(<code>exp</code>, <code>x</code>, <code>y</code>)","text":""},{"location":"roboboard/api/drivetrain/#joystick_range","title":"Joystick::range","text":""},{"location":"roboboard/api/drivetrain/#joystick_exponent","title":"Joystick::exponent","text":""},{"location":"roboboard/api/drivetrain/#joystick_deadzone","title":"Joystick::deadzone","text":""},{"location":"roboboard/api/esp32/","title":"ESP32","text":"<p>ESP32 processor comes with large set of features already integrated in Arduino framework. Many useful things like wireless connectivity, advanced GPIO control and file systems can be used right away without additional libraries. All of it can be found in official ESP32 Arduino documentation and examples.</p> <ul> <li>Arduino ESP32 documentation</li> <li>Arduino ESP32 examples</li> <li>ESP32 datasheet</li> </ul>"},{"location":"roboboard/api/esp32/#software","title":"Software","text":"<p>RoboBoard Arduino software is based on official ESP32 support to maintain compatibility with third-party libraries and tutorials. All standard functionality is available in addition with Totem RoboBoard functions. For more details read API section.</p>"},{"location":"roboboard/api/esp32/#freertos","title":"FreeRTOS","text":"<p>ESP32 software is integrated with FreeRTOS (Real-time operating system for microcontrollers) allowing to utilize both cores and use multithreading features. Processes can be split into asynchronous tasks and controlled with mutex, timers, queues and other operating system utilities. Default task allocation: \u2022 Core 0 - WiFi, Bluetooth, TotemApp, motor driving, other background tasks. \u2022 Core 1 - Arduino sketch (<code>setup()</code>, <code>loop()</code>), events.  </p> <p>ESP32 FreeRTOS documentation | examples</p>"},{"location":"roboboard/api/esp32/#storage","title":"Storage","text":"<p>ESP32 contains a total of 8MB flash memory. It is split into separate partitions for whole system to function. Exact partition table can be found in file default_8MB.csv.</p> <ul> <li><code>nvs</code> (20KB) - storage for <code>Board.settingsSave()</code> and Preferences library.</li> <li><code>otadata</code> (8KB) - holds current state of <code>app</code> partitions.</li> <li><code>app0</code> - (3.3MB) - holds Arduino sketch code.</li> <li><code>app1</code> - (3.3MB) - second Arduino sketch bank. Loaded during OTA update.</li> <li><code>spiffs</code> - (1.5MB) - file system (storage) for holding large data and files. Files can be created and handled using <code>FS.h</code> and <code>SPIFFS.h</code>.</li> <li><code>coredump</code> - (65KB) - stores core dumps during system crash.</li> </ul> <p>Note: while total amount of flash is 8MB - only 3.3MB can be used for single Arduino sketch. To overcome this limit - different partition table should be selected.</p> <p>Examples:</p> <ul> <li>SPIFFS file system - handle files inside <code>spiffs</code> partition.</li> <li>Wi-Fi File Browser - website to view files in <code>spiffs</code> partition.</li> </ul>"},{"location":"roboboard/api/esp32/#preferences","title":"Preferences","text":"<p>Library used for storing user settings in flash memory. Will be preserved during power off.</p> <p>Preferences documentation | examples</p>"},{"location":"roboboard/api/esp32/#radio","title":"Radio","text":""},{"location":"roboboard/api/esp32/#wi-fi","title":"Wi-Fi","text":"<p>ESP32 has integrated Wi-Fi capability. May be used to connect home network and access the Internet. From there possibilities are endless.  </p> <p>Wi-Fi documentation | examples:  </p> <ul> <li>Wi-Fi - connect to Wi-Fi networks.</li> <li>Web Server - host website on ESP32 itself.</li> <li>mDNS - host local website with address <code>http://esp32.local</code>.</li> <li>Network time - get correct time and date from the Internet.</li> <li>Captive Portal - display website when connected to ESP32.</li> <li>NetBIOS - allow to find ESP32 on local network.</li> <li>AsyncUDP - broadcast using UDP protocol.</li> <li>HTTP Client - access other websites (web browser).</li> <li>Arduino OTA - upload ESP32 firmware binary over Wi-Fi.</li> <li>Web Firmware update - ESP32 firmware update web server.</li> <li>HTTP Firmware update - update ESP32 firmware from URL.</li> </ul>"},{"location":"roboboard/api/esp32/#esp-now","title":"ESP-NOW","text":"<p>A communication protocol developed by Espressif. Alternative to Wi-Fi and Bluetooth solutions. Based on 2.4 Ghz frequency, allows for long distance communication and compatible with legacy ESP8266 chips.</p> <p>ESP-NOW documentation | examples</p>"},{"location":"roboboard/api/esp32/#bluetooth-classic","title":"Bluetooth (classic)","text":"<p>Older Bluetooth (classic) standard used for multiple purposes like audio headset (A2DP), Serial Port Profile (SPP) and other. In Arduino environment mostly used with <code>BluetoothSerial.h</code> functionality to connect with PC over Bluetooth virtual serial port. Allows printing to Serial Monitor without USB connected.</p> <p>BluetoothSerial documentation | examples</p>"},{"location":"roboboard/api/esp32/#bluetooth-low-energy","title":"Bluetooth Low Energy","text":"<p>Bluetooth standard introduced in Bluetooth 4.0 specification. Consumes less power, but works differently compared to old standard. Mainly used to connect with smartphones (Totem App.</p> <p>Custom Bluetooth services and implementations can be also created. See information below.</p> <p>BLE documentation | examples |  Simple BLE library</p>"},{"location":"roboboard/api/esp32/#hardware","title":"Hardware","text":""},{"location":"roboboard/api/esp32/#reset-reason","title":"Reset Reason","text":"<p>Read processor restart reason upon power on. There are multiple situation how this could happen. Mainly used for detecting unexpected faults.</p> <p>Reset Reason documentation | example</p>"},{"location":"roboboard/api/esp32/#deep-sleep","title":"Deep Sleep","text":"<p>Put processor into deep sleep state to turn it off and use only a fraction of power. It will boot up (wake) after specified <code>time</code> (other conditions are also possible). Mainly used with power saving applications.  </p> <p>Parameter: <code>time</code> - wake up time in microseconds (\u03bcs).  </p> <p>Deep Sleep documentation | examples</p>"},{"location":"roboboard/api/esp32/#deepSleep","title":"ESP.deepSleep(<code>time</code>)","text":""},{"location":"roboboard/api/esp32/#timer","title":"Timer","text":"<p>ESP32 contains 4, 64-bit hardware timers to perform precise timing operations. Used as configurable counter or alarm interrupts at specified time.  </p> <p>Timer documentation | examples | Ticker library</p>"},{"location":"roboboard/api/gpio-qwiic/","title":"GPIO / Qwiic","text":"<p>RoboBoard contains GPIO pins for hooking up external electronics. Can be used for simple input, output operations or with communication protocols (UART, I2C, SPI, ...). Works same as any other Arduino development board (like TotemDuino). Additional Qwiic port is available to connect external I2C modules.  </p> <ul> <li>General Input/Output documentation</li> <li>ADC (analog) API documentation</li> <li>Arduino API reference</li> </ul> Picture above example code<pre><code>void setup() {\n  Serial.begin(115200); // Start serial at 115200 baud rate\n  pinMode(GPIOC, OUTPUT); // Set GPIOC to OUTPUT (HIGH or LOW)\n  pinMode(GPIOD, INPUT_PULLUP); // Set GPIOD to INPUT (pull HIGH)\n}\nvoid loop() {\n  // If RoboBoard button is pressed - pulsate LED on GPIOC pin \n  if (Button.isPressed()) {\n    for(int i=0; i&lt;255; i+=15) { analogWrite(GPIOC, i); delay(10); }\n    for(int i=255; i&gt;0; i-=15) { analogWrite(GPIOC, i); delay(10); }\n    return;\n  }\n  // Check if button is pressed (connects to GND)\n  if (digitalRead(GPIOD) == LOW) Serial.print(\"Button press, \");\n  // Read potentiometer position 0-4095\n  Serial.println(analogRead(GPIOA)); // Read pin GPIOA analog\n  delay(100); // Wait 100ms\n  digitalWrite(GPIOC, LOW); // Turn LED on\n  delay(100); // Wait 100ms\n  digitalWrite(GPIOC, HIGH); // Turn LED off\n}\n</code></pre>"},{"location":"roboboard/api/gpio-qwiic/#arduino-pin-names","title":"Arduino pin names","text":"RoboBoard X4RoboBoard X3 v3.1RoboBoard X3 v3.0 <p> Arduino pins: GPIOA, GPIOB, GPIOC, GPIOD. VCC: 3.3V output (2A max), GND: Ground pin.  </p> Name Pin Exclusive function GPIOA 14 <code>MOSI</code>, Analog, Touch GPIOB 23 <code>MISO</code> GPIOC 25 <code>SCK</code>, Analog, DAC GPIOD 26 <code>SS</code>, Analog, DAC - 21 <code>SDA</code> - 22 <code>SCL</code> <ul> <li>GPIOB does not support <code>analogRead()</code>!  </li> <li>SPI can be mapped to any pin (<code>MOSI</code>, <code>MISO</code>, <code>SCK</code>, <code>SS</code> only shows default mapping).</li> <li>All pin definitions can be found in pins_arduino.h file.</li> </ul> <p> Arduino pins: IO26, IO32, IO33. Servo pins: SIGA, SIGB, SIGC, SIGD. 3V3: 3.3V output (0.8A max), GND: Ground pin. Qwiic port right: Control Qwiic I2C modules over <code>Wire</code> object. I2C pins <code>SDA</code>, <code>SCL</code>. Yellow port left: Control Qwiic I2C modules over <code>Wire1</code> object. I2C pins <code>SDA1</code>, <code>SCL1</code>. Or access pins IO32, IO33, 3V3, GND using \"Qwiic jumper cable\".  </p> Name Pin Exclusive function IO26 26 Analog, Touch, DAC, <code>MOSI</code> IO32 32 Analog, Touch, <code>SCL1</code>, <code>MISO</code> IO33 33 Analog, Touch, <code>SDA1</code>, <code>SCK</code> - 15 <code>SDA</code> - 5 <code>SCL</code> SIGA 25 DAC SIGB 14 Touch, <code>SS</code> SIGC 16 Touch SIGD 17 - <ul> <li>Output power 3V3 can be turned off with function <code>Board.setEnable3V3()</code>.</li> <li>SIGx pins can be used when motor is not connected. Contains 120 Ohm resistor!</li> <li>Left yellow port does not have pull-up resistors!</li> <li>SPI can be mapped to any pin (<code>MOSI</code>, <code>MISO</code>, <code>SCK</code>, <code>SS</code> only shows default mapping).</li> <li>All pin definitions can be found in pins_arduino.h file.</li> </ul> <p> Arduino pins: IO26, IO32, IO33. Servo pins: SIGA, SIGB. 3V3: 3.3V (0.5A max), GND: Ground pin. Qwiic port right: Control Qwiic I2C modules over <code>Wire</code> object. I2C pins <code>SDA</code>, <code>SCL</code>.  </p> Name Pin Exclusive function IO26 26 Analog, Touch, DAC, <code>MOSI</code> IO32 32 Analog, Touch, <code>SCL1</code>, <code>MISO</code> IO33 33 Analog, Touch, <code>SDA1</code>, <code>SCK</code> - 15 <code>SDA</code> - 5 <code>SCL</code> SIGA 25 DAC SIGB 14 Touch, <code>SS</code> <ul> <li>Output power 3V3 can be turned off with function <code>Board.setEnable3V3()</code>.</li> <li>SIGx pins can be used when motor is not connected. Contains 120 Ohm resistor!</li> <li>SPI can be mapped to any pin (<code>MOSI</code>, <code>MISO</code>, <code>SCK</code>, <code>SS</code> only shows default mapping).</li> <li>All pin definitions can be found in pins_arduino.h file.</li> </ul>"},{"location":"roboboard/api/gpio-qwiic/#using-i2c","title":"Using I2C","text":"<p>I<sup>2</sup>C (Inter-Integrated Circuit) / TWI (Two-wire Interface) communication protocol used for controlling many different devices and modules. Main communication protocol of Qwiic port. In Arduino environment it is called \"Wire\".</p> <p>General I2C documentation | examples</p> <p><code>Wire</code> object is mapped to pins of Qwiic port and IMU sensor. To start I2C - include <code>Wire.h</code> file and call <code>Wire.begin()</code> inside <code>setup()</code> function to run with default parameters. A few more options available:</p> <ul> <li><code>Wire.begin()</code> - set default pins and frequency (speed) to 100kHz.</li> <li><code>Wire.begin(SDA, SCL, 400000)</code> - set default pins with 400kHz speed.</li> <li><code>Wire.begin(GPIOA, GPIOB, 400000)</code> - set to GPIOA, GPIOB pins with 400kHz speed.</li> <li><code>Wire.begin(GPIOA, GPIOB)</code> - set to GPIOA, GPIOB pins with 100kHz speed.</li> <li><code>Wire.setPins(GPIOA, GPIOB)</code> - set to GPIOA, GPIOB pins before calling <code>Wire.begin()</code>. Used to change SDA, SCL pins for libraries that calls <code>Wire.begin()</code> internally.</li> </ul> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt; // (1) Adafruit-GFX library\n#include &lt;Adafruit_SSD1306.h&gt; // (2) Adafruit_SSD1306 library\n\nAdafruit_SSD1306 display(128, 64);\n\nvoid setup() {\n  delay(500); // Wait for display to turn on\n  // Set I2C SDA pin to GPIOA\n  // Set I2C SCL pin to GPIOB\n  // (other pins can be used also)\n  Wire.setPins(GPIOA, GPIOB);\n  // Initialize display (Wire.begin() is called inside library)\n  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    for(;;); // Don't proceed, loop forever\n  }\n  // Print text\n  display.clearDisplay(); // Clear the buffer\n  display.setTextSize(2); // Change text size\n  display.setTextColor(SSD1306_WHITE); // Set color\n  display.setCursor(10, 25); // Center\n  display.println(\"RoboBoard\"); // Set text\n  display.display(); // Write to display\n}\n\nvoid loop() {\n\n}\n</code></pre> <ol> <li>https://github.com/adafruit/Adafruit-GFX-Library</li> <li>https://github.com/adafruit/Adafruit_SSD1306</li> </ol> <p>ESP32 has two I2C channels: <code>Wire</code> (mapped to Qwiic port) and <code>Wire1</code> (free to use). It's recommended to use <code>Wire1</code> with GPIO pins, as it allows simultaneous use of Qwiic port and GPIO pins. Most Arduino libraries expects to communicate over <code>Wire</code>.</p> Example using Wire1 with GPIO <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt; // (1) Adafruit-GFX library\n#include &lt;Adafruit_SSD1306.h&gt; // (2) Adafruit_SSD1306 library\n// Change to second \"Wire1\" I2C peripheral\nAdafruit_SSD1306 display(128, 64, &amp;Wire1);\n\nvoid setup() {\n  delay(500); // Wait for display to turn on\n  // Set Wire1 I2C SDA pin to GPIOA\n  // Set Wire1 I2C SCL pin to GPIOB\n  // (other pins can be used also)\n  Wire1.setPins(GPIOA, GPIOB);\n  // Initialize display (Wire1.begin() is called inside library)\n  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    for(;;); // Don't proceed, loop forever\n  }\n  // Print text\n  display.clearDisplay(); // Clear the buffer\n  display.setTextSize(2); // Change text size\n  display.setTextColor(SSD1306_WHITE); // Set color\n  display.setCursor(10, 25); // Center\n  display.println(\"RoboBoard\"); // Set text\n  display.display(); // Write to display\n}\n\nvoid loop() {\n\n}\n</code></pre> <ol> <li>https://github.com/adafruit/Adafruit-GFX-Library</li> <li>https://github.com/adafruit/Adafruit_SSD1306</li> </ol>"},{"location":"roboboard/api/gpio-qwiic/#using-uart-serial","title":"Using UART (Serial)","text":"<p>UART (Universal Asynchronous Receiver / Transmitter) protocol is a base of most Serial communications. Can be used to communicate with external devices or printing debug messages inside Serial Monitor. Uses two wires TX, RX for transmit and receive. Both devices (on both ends) has to use same baud rate (communication speed). In Arduino environment it is called \"Serial\".</p> <p>Serial API documentation | examples</p> <p>ESP32 has three separate UART channels:</p> <ul> <li><code>Serial</code> - standard one, mapped to USB (for printing to Serial Monitor).</li> <li><code>Serial1</code> - free to use. Recommended with GPIO pins.</li> <li><code>Serial2</code> - not available on X4, but may be used with X3.</li> </ul> <p><code>Serial</code> object can be also mapped to GPIO pins if required.</p> Example using Serial1 with GPIO pins<pre><code>void setup() {\n  // Map GPIOC to TX &lt;-&gt; FTDI RX\n  // Map GPIOD to RX &lt;-&gt; FTDI TX\n  // (other pins can be used also)\n  // Begin UART over GPIO pins (config: 8bit data, 1 stop bit, no parity)\n  Serial1.begin(115200, SERIAL_8N1, GPIOD, GPIOC); // baud, config, rx, tx\n}\nint counter;\nvoid loop() {\n  // Use \"Serial1\" to print over GPIO pins\n  Serial1.print(\"Test \");\n  Serial1.println(counter++);\n  delay(100);\n}\n</code></pre>"},{"location":"roboboard/api/gpio-qwiic/#using-spi","title":"Using SPI","text":"<p>Serial Peripheral Interface is commonly used for fast communication speed (up to 40 MHz). Uses 4 wires (CS, SCK, MISO, MOSI). In Arduino environment it is called \"SPI\".</p> <p>SPI documentation</p> <pre><code>#include &lt;SPI.h&gt;\n\n// Set GPIOD pin as \"CS\"\nconst static int CS = GPIOD;\n\nvoid setup() {\n  // Set CS pin as output\n  pinMode(CS, OUTPUT);\n  // Set SPI pins SCK, MISO, MOSI\n  // (other pins can be used also)\n  SPI.begin(GPIOC, GPIOB, GPIOA);\n  // Write byte 0x55 over SPI\n  SPI.beginTransaction(SPISettings()); // Transaction settings can be added\n  digitalWrite(CS, LOW); // Pull CS pin LOW to initiate transfer\n  SPI.transfer(0x55); // Transfer byte 0x55\n  digitalWrite(CS, HIGH); // Pull CS pin HIGH to end transfer\n  SPI.endTransaction(); // End transaction\n}\n\nvoid loop() {\n\n}\n</code></pre>"},{"location":"roboboard/api/gpio-qwiic/#using-other-peripherals","title":"Using other peripherals","text":"<p>GPIO pins can be used with multiple peripherals. Each one has its own advantages and use cases. View full list:</p> <ul> <li>ADC - read pin analog value (voltage). documentation | example</li> <li>DAC - output pin analog value (voltage). documentation</li> <li>Digital IO - output pin digital value (GND or VCC). documentation</li> <li>I2C - two wire, master-slave protocol. documentation | examples</li> <li>I2S - serial bus for digital audio (mic and speakers). documentation | examples</li> <li>LEDC - LED Control peripheral, PWM generator. documentation | examples</li> <li>RMT - send infrared or neopixel messages. documentation | examples</li> <li>SigmaDelta - sigma delta modulation generator. documentation | example</li> <li>SPI - Serial Peripheral Interface. Fast master-slave communication. documentation | examples</li> <li>Touch - pin touch sensor (capacitive). documentation | examples</li> <li>TWAI (CANbus) - Two-Wire Automotive Interface (CAN bus). Used internally for TotemBUS. examples</li> </ul>"},{"location":"roboboard/api/gpio-qwiic/#qwiic-port","title":"Qwiic port","text":"<p>A connection system to attach third-party I2C modules. This allows to choose from many available sensors and other interface devices. Small and sturdy connector eliminates need for soldering and enables plug-and-play style modular systems. Each module comes with its own Arduino library (supplied by manufacturer).</p> <p>This port is compatible with SparkFun Qwiic and Adafruit STEMMA QT modules.  </p>"},{"location":"roboboard/api/gpio-qwiic/#connector","title":"Connector","text":"<p>Standard \"Qwiic\" connector with I2C communication and 3.3V power line. Modules usually contain 2 connectors for joining multiple of them (daisy-chaining). Single RoboBoard Qwiic port can host multiple modules.</p> RoboBoard X4RoboBoard X3 v3.1RoboBoard X3 v3.0 <p></p> <p>Standard I2C Qwiic port. Controlled with <code>Wire</code> object. I2C pins <code>SDA</code>, <code>SCL</code>.</p> <p></p> <p>Contains 2 distinctive ports: \u2022 Qwiic - standard I2C Qwiic port. Controlled with <code>Wire</code> object. I2C pins <code>SDA</code>, <code>SCL</code>. \u2022 GPIO - optional I2C port. Controlled with <code>Wire1</code> object. I2C pins <code>SDA1</code>, <code>SCL1</code>. \"GPIO\" does not have pull-up resistors!.</p> <p></p> <p>Standard I2C Qwiic port. Controlled with <code>Wire</code> object. I2C pins <code>SDA</code>, <code>SCL</code>.</p> <p>Wires: \u2022 Black = GND \u2022 Red = 3.3V \u2022 Blue = SDA \u2022 Yellow = SCL </p> <p>Cable: standard \"Qwiic cable\". Can be found in local electronics store. Connector: SM04B-SRSS-TB 4-pin  </p>"},{"location":"roboboard/api/gpio-qwiic/#installing-modules","title":"Installing modules","text":"<p>When module is connected to the RoboBoard - it will simply power on but won't do anything. To make any use of it - you need to install Arduino library, specific to connected module. It should be provided by manufacturer. Libraries also contain example code, explaining how to use it.</p>"},{"location":"roboboard/api/gpio-qwiic/#usage-example","title":"Usage example","text":"<p>Code example to display text as in picture:  </p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;SFE_MicroOLED.h&gt; // (1) SparkFun Micro OLED Breakout library\n\n#define PIN_RESET GPIOA    // Not used\nMicroOLED oled(PIN_RESET); // I2C declaration\n\nvoid setup() {\n  Wire.begin(); // Initialize I2C\n\n  oled.begin(0x3D, Wire); // Initialize OLED\n\n  oled.clear(ALL); // Clear display internal memory\n  oled.clear(PAGE); // Clear buffer\n\n  oled.setFontType(1); // Change font for bigger letters\n\n  oled.setCursor(0, 0); // Set cursor to top-left\n\n  oled.println(\"Robo\"); // Print text\n  oled.println(\"Board\");\n  oled.println(\"X4\");\n\n  oled.display();  // Display what's in the buffer\n}\n\nvoid loop() {\n\n}\n</code></pre> <ol> <li>https://github.com/sparkfun/SparkFun_Micro_OLED_Arduino_Library</li> </ol>"},{"location":"roboboard/api/gpio-qwiic/#qwiic-vs-stemma-qt","title":"Qwiic vs STEMMA QT","text":"<p>A different brand names describing same connector and pin order. One is introduced by SparkFun, another by - Adafruit.</p> <ul> <li>STEMMA QT modules - works with 3.3V and 5V microcontrollers (like Arduino UNO).</li> <li>Qwiic modules - works with 3.3V microcontrollers only! (can't use with Arduino UNO).</li> </ul> <p>Totem RoboBoard is 3.3V so both brand modules can be used.</p>"},{"location":"roboboard/api/gpio-qwiic/#internal-pin-mapping","title":"Internal pin mapping","text":"<p>A list of ESP32 pins that are assigned to specific functions inside RoboBoard. Only for reference and shouldn't be accessed directly. Used internally by RoboBoard API.</p> RoboBoard X3RoboBoard X4 Number Name Description 1 Serial TX UART communication over USB 3 Serial RX UART communication over USB 15 SDA I2C bus pin routed to IMU and Qwiic port. Has external 2k2 Ohm pull-up 5 SCL I2C bus pin routed to IMU and Qwiic port. Has external 2k2 Ohm pull-up 26 IO26 GPIO pin 32 IO32 GPIO pin 33 IO33 GPIO pin 22 MOTORA_INA DC motor port A pin 0 12 MOTORA_INB DC motor port A pin 1 23 MOTORB_INA DC motor port B pin 0 19 MOTORB_INB DC motor port B pin 1 18 MOTORC_INA DC motor port C pin 0 21 MOTORC_INB DC motor port C pin 1 4 MOTORD_INA DC motor port D pin 0 2 MOTORD_INB DC motor port D pin 1 25 SERVOA_IN Servo motor port A (SIG) 14 SERVOB_IN Servo motor port B (SIG) 16 SERVOC_IN Servo motor port C (SIG) 17 SERVOD_IN Servo motor port D (SIG) 0 BUTTON BOOT button 13 RGB RGB light strip data pin 27 3V3_EN Peripheral 3.3V LDO enable pin 34 VERSION_DETECT Detect board revision 35 BATTERY_CHARGE State of battery charging (if charging) 36 BATTERY_CURRENT Battery current measurement 37 BATTERY_VOLTAGE Battery voltage measurement 38 USB_DETECT State of USB port (is plugged in) 39 IMU_INT IMU chip interrupt pin Number Name Description 1 Serial TX UART communication over USB 3 Serial RX UART communication over USB 21 SDA I2C bus pin routed to IMU and Qwiic port. Has external 2k2 Ohm pull-up 22 SCL I2C bus pin routed to IMU and Qwiic port. Has external 2k2 Ohm pull-up 14 GPIOA GPIO pin 23 GPIOB GPIO pin 25 GPIOC GPIO pin 26 GPIOD GPIO pin 17 CAN_TX CAN bus transmit pin routed to TotemBUS 34 CAN_RX CAN bus receive pin routed to TotemBUS 5 CAN_EN CAN bus transceiver enable (active LOW) 4 DRIVER_DFU Device Firmware Update pin of STM32 co-processor 15 DRIVER_RESET Reset pin of STM32 co-processor 16 DRIVER_RX UART RX pin of STM32 co-processor 27 DRIVER_TX UART TX pin of STM32 co-processor 13 LED Status LED bellow ESP32 18 BUTTON User button below ESP32 39 USB_DETECT State of USB port (is plugged in) 36 BATTERY_VOLTAGE Battery voltage measurement 35 IMU_INT IMU chip interrupt pin (v1.1 only) 14 IMU_INT IMU chip interrupt pin (v1.0 only)"},{"location":"roboboard/api/gpio-qwiic/#roboboard-x4-v10-gpio","title":"RoboBoard X4 v1.0 GPIO","text":"<p>First revision of RoboBoard X4 had GPIO pins connected to co-processor instead of ESP32. For this reason Arduino API can't be used and special commands are required to interact. This also limits to digital read / write and analog read / write only.</p> GPIO control functions (click to expand) X410_digitalWrite(<code>pin</code>, <code>state</code>) Set GPIO pin state. Works similar like Arduino function <code>digitalWrite()</code>. Calling this function will reconfigure pin to output. Parameter: <code>pin</code> - pin number [<code>0</code>:<code>3</code>] <code>state</code> - GND (0V) or VCC (3.3V) [<code>LOW</code>:<code>HIGH</code>]   (<code>state</code>) X410_digitalRead(<code>pin</code>) Read GPIO pin state. Works similar like Arduino function <code>digitalRead()</code>. Calling this function will reconfigure pin to input. Returns: <code>pin</code> - pin number [<code>0</code>:<code>3</code>] <code>state</code> - GND (0V) or VCC (3.3V) [<code>LOW</code>:<code>HIGH</code>]   X410_analogWrite(<code>pin</code>, <code>value</code>) Set GPIO pin analog value. Works similar like Arduino function <code>analogWrite()</code>. Calling this function will reconfigure pin to output. Parameter: <code>pin</code> - pin number [<code>0</code>:<code>3</code>] <code>value</code> - analog value [<code>0</code>:<code>20</code>]. (0, 10, 20) = (0V, 1.65V, 3.3V). (<code>value</code>) X410_analogRead(<code>pin</code>) Read GPIO pin analog value. Works similar like Arduino function <code>analogRead()</code>. Calling this function will reconfigure pin to output. Returns: <code>pin</code> - pin number [<code>0</code>:<code>3</code>] <code>value</code> - analog value [<code>0</code>:<code>1023</code>]. (0, 512, 1023) = (0V, 1.65V, 3.3V). X410_pinMode(<code>pin</code>, <code>mode</code>) Turn on GPIO pin pulldown or pullup resistor. Works similar like Arduino function <code>pinMode(pin, INPUT_PULLUP)</code>. Parameter: <code>pin</code> - pin number [<code>0</code>:<code>3</code>] <code>mode</code> - turn on pulldown or pullup [<code>LOW</code>:<code>HIGH</code>]. (LOW, HIGH) = (GND (0V), VCC (3.3V)).   <p>Example: <pre><code>void loop() {\n  // Toggle GPIOA pin\n  X410_digitalWrite(GPIOA, HIGH);\n  delay(1000);\n  X410_digitalWrite(GPIOA, LOW);\n  delay(1000);\n}\n</code></pre></p>"},{"location":"roboboard/api/imu/","title":"IMU","text":"<p>Control interface for integrated RoboBoard I2C accelerometer and gyroscope sensor.</p> <pre><code>#include &lt;Wire.h&gt;\nvoid setup() {\n  Wire.begin(); // Start I2C interface (for communication with sensor)\n  auto result = IMU.read();\n}\n</code></pre> <p>IMU sensor (based on MEMS technology) measures movement in 3 acceleration axis and 3 rotation axis. Allows to determine board movement, position, rotation angles. Sensor is sharing I2C <code>Wire</code> (SDA, SCL pins) with Qwiic port, so it acts as additional module on the bus. Can be also used with third-party library.  </p> <p>Tip</p> <p>In order to use sensor, you must enable I2C by calling <code>Wire.begin()</code> inside <code>setup()</code> function. Otherwise <code>IMU</code> functionality will not work.</p> <p>Only raw sensor measurements available. Advanced orientation algorithms not yet implemented.</p>"},{"location":"roboboard/api/imu/#code-snippets","title":"Code snippets","text":"<pre><code>#include &lt;Wire.h&gt; // Required for \"Wire.begin\"\nvoid setup() {\n  // Start I2C at 400kHz\n  // Calling \"Wire.begin()\" will start in 100kHz mode\n  // SDA, SCL - pins connected to IMU and Qwiic port\n  Wire.begin(SDA, SCL, 400000); // Required for \"IMU\"\n}\nvoid loop() {\n  auto result = IMU.read(); // Store measurements in \"result\"\n  Serial.println(result.getX_G()); // Read unit from \"result\"\n  delay(100); // Wait 100ms for next read\n}\n</code></pre>"},{"location":"roboboard/api/imu/#functions","title":"Functions","text":""},{"location":"roboboard/api/imu/#read-sensor","title":"Read sensor","text":"<p>Called <code>IMU.read()</code> function will sample measurements from IMU sensor and return in a single <code>IMUData</code> object. It contains functions to read data in different measurement units without require for additional conversions.  </p> <p>Initialize IMU sensor. Function <code>IMU.read()</code> calls this internally, so it's only useful if need to prepare sensor before first read operation.</p> <p>Read measurements from IMU sensor. Returns structure with accelerometer, gyroscope and temperature data. Note: <code>Wire.begin()</code> must be called in order for <code>IMU</code> to work! Returns: <code>IMUData</code> - object with sensor data. Read Access data for more info.</p>"},{"location":"roboboard/api/imu/#begin","title":"IMU.begin()","text":""},{"location":"roboboard/api/imu/#read","title":"<code>IMUData</code> IMU.read()","text":""},{"location":"roboboard/api/imu/#access-data","title":"Access data","text":"<p>Available units:</p> <ul> <li>Gravitational force (G)</li> <li>Acceleration in meters per squared seconds (m/s<sup>2</sup>)</li> <li>Rotation speed in degrees per second (dps)</li> <li>Rotation speed in radians per second (rad/s)</li> <li>Rotation speed in rounds per minute (RPM).</li> <li>Orientation in angle degrees (\u00b0)</li> </ul> <p>Accelerometer:</p>"},{"location":"roboboard/api/imu/#getX_G","title":"<code>unit</code> result.getX_G()","text":""},{"location":"roboboard/api/imu/#getY_G","title":"<code>unit</code> result.getY_G()","text":"<p>Get gravitational force (G) measurement of X, Y, Z axis. Returns: <code>unit</code> - (float) gravitational force [<code>-16.0</code>, <code>16.0</code>]G.</p>"},{"location":"roboboard/api/imu/#getZ_G","title":"<code>unit</code> result.getZ_G()","text":""},{"location":"roboboard/api/imu/#getX_mss","title":"<code>unit</code> result.getX_mss()","text":""},{"location":"roboboard/api/imu/#getY_mss","title":"<code>unit</code> result.getY_mss()","text":"<p>Get acceleration in meters per second squared of X, Y, Z axis. Returns: <code>unit</code> - (float) [<code>-157.0</code>, <code>157.0</code>]m/s<sup>2</sup>.  </p> <p>Gyroscope:</p>"},{"location":"roboboard/api/imu/#getZ_mss","title":"<code>unit</code> result.getZ_mss()","text":""},{"location":"roboboard/api/imu/#getX_dps","title":"<code>unit</code> result.getX_dps()","text":""},{"location":"roboboard/api/imu/#getY_dps","title":"<code>unit</code> result.getY_dps()","text":"<p>Get rotation in degrees per second of X, Y, Z axis. Returns: <code>unit</code> - (float) [<code>-2000.0</code>, <code>2000.0</code>]dps.  </p>"},{"location":"roboboard/api/imu/#getZ_dps","title":"<code>unit</code> result.getZ_dps()","text":""},{"location":"roboboard/api/imu/#getX_rads","title":"<code>unit</code> result.getX_rads()","text":""},{"location":"roboboard/api/imu/#getY_rads","title":"<code>unit</code> result.getY_rads()","text":"<p>Get rotation in radians per second of X, Y, Z axis. Returns: <code>unit</code> - (float) [<code>-35.0</code>, <code>35.0</code>]rad/s.  </p>"},{"location":"roboboard/api/imu/#getZ_rads","title":"<code>unit</code> result.getZ_rads()","text":""},{"location":"roboboard/api/imu/#getX_rpm","title":"<code>unit</code> result.getX_rpm()","text":""},{"location":"roboboard/api/imu/#getY_rpm","title":"<code>unit</code> result.getY_rpm()","text":"<p>Get rotation in rounds per minute of X, Y, Z axis. Returns: <code>unit</code> - (float) [<code>-333.0</code>, <code>333.0</code>]RPM.  </p> <p>Temperature:</p> <p>Internal sensor / board temperature (not a room temperature!).</p> <p>Get IMU sensor temperature in Celsius. Returns: <code>unit</code> - (float) temperature <code>25.0</code> \u00b0C.  </p> <p>Get IMU sensor temperature in Fahrenheit. Returns: <code>unit</code> - (float) temperature <code>77.0</code> \u00b0F.  </p> <p>Orientation:</p> <p>Accelerometer based orientation measurements (susceptible to shaking).</p>"},{"location":"roboboard/api/imu/#getZ_rpm","title":"<code>unit</code> result.getZ_rpm()","text":""},{"location":"roboboard/api/imu/#getTempC","title":"<code>unit</code> result.getTempC()","text":""},{"location":"roboboard/api/imu/#getTempF","title":"<code>unit</code> result.getTempF()","text":""},{"location":"roboboard/api/imu/#getOrientX","title":"<code>unit</code> result.getOrientX()","text":"<p>Board orientation in space of X and Y axis. Returns: <code>unit</code> - (float) orientation [<code>-180.0</code>:<code>180.0</code>] degrees.  </p> <p>Get roll estimation. Returns: <code>unit</code> - (float) roll [<code>-180.0</code>:<code>180.0</code>] degrees.  </p> <p>Get pitch estimation. Returns: <code>unit</code> - (float) pitch [<code>-90.0</code>:<code>90.0</code>] degrees.  </p>"},{"location":"roboboard/api/imu/#getOrientY","title":"<code>unit</code> result.getOrientY()","text":""},{"location":"roboboard/api/imu/#getRoll","title":"<code>unit</code> result.getRoll()","text":""},{"location":"roboboard/api/imu/#getPitch","title":"<code>unit</code> result.getPitch()","text":""},{"location":"roboboard/api/imu/#configure-sensor","title":"Configure sensor","text":"<p>Configure accelerometer measurement range (in gravitational force). Can be lowered if higher precision is required. Parameter: <code>range</code> - max (G) range [<code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>]. Default: 16.</p> <p>Configure gyroscope measurement range (in degrees per second). Can be lowered if higher precision is required. Parameter: <code>range</code> - max (dps) range [<code>250</code>, <code>500</code>, <code>1000</code>, <code>2000</code>]. Default 2000.</p> <p>Get configured accelerometer measurement range (in gravitational force). Will return exact value configured in sensor. Returns: <code>range</code> - max (G) range.</p> <p>Get configured gyroscope measurement range (in degrees per second). Will return exact value configured in sensor. Returns: <code>range</code> - max (dps) range.</p> <p>Get name of installed IMU sensor. Different variants exist in RoboBoard. Returns: <code>string</code> - name of IMU sensor.</p> <p>Get I2C address of installed IMU sensor. Different variants exist in RoboBoard. Returns: <code>number</code> - I2C address of IMU sensor.</p> <p>Check if specified <code>address</code> equal to installed IMU sensor. Parameter: <code>address</code> - I2C address. Returns: <code>state</code> - <code>true</code> if address match.  </p>"},{"location":"roboboard/api/imu/#setAccelRange","title":"IMU.setAccelRange(<code>range</code>)","text":""},{"location":"roboboard/api/imu/#setGyroRange","title":"IMU.setGyroRange(<code>range</code>)","text":""},{"location":"roboboard/api/imu/#getAccelRange","title":"<code>range</code> IMU.getAccelRange()","text":""},{"location":"roboboard/api/imu/#getGyroRange","title":"<code>range</code> IMU.getGyroRange()","text":""},{"location":"roboboard/api/imu/#getName","title":"<code>string</code> IMU.getName()","text":""},{"location":"roboboard/api/imu/#getI2CAddr","title":"<code>number</code> IMU.getI2CAddr()","text":""},{"location":"roboboard/api/imu/#isI2CAddr","title":"<code>state</code> IMU.isI2CAddr(<code>address</code>)","text":""},{"location":"roboboard/api/imu/#sensor-variants","title":"Sensor variants","text":"<p>Each RoboBoard contains different IMU sensor. See table below for part number and I2C address. These parameters can be also acquired dynamically using <code>IMU.getName()</code> and <code>IMU.getI2CAddr()</code> functions.</p> RoboBoard X3 v3.x RoboBoard X4 v1.0 RoboBoard X4 v1.1 QMI8658 LSM6DS3 ICM-20689 0x6B 0x6A 0x68"},{"location":"roboboard/api/led/","title":"LED","text":"<p>RoboBoard X3 does not have dedicated LED. It is emulated trough RGB A.</p> <p>Control interface for changing LED state and blinking. Can be used with internal RoboBoard LED or external one connected to GPIO.</p>"},{"location":"roboboard/api/led/#code-snippets","title":"Code snippets","text":"<pre><code>// Turn LED on\nLED.on();\n// Turn LED off\nLED.off();\n// Toggle LED between on / off\nLED.toggle();\n// Check if LED is on\nbool isOn = LED.isOn();\n// Make LED blink (5 times)\nLED.blink();\n</code></pre>"},{"location":"roboboard/api/led/#functions","title":"Functions","text":""},{"location":"roboboard/api/led/#control","title":"Control","text":"<p>Turn LED on.  </p> <p>Turn LED off.  </p> <p>Toggle LED between on / off states.  </p> <p>Get current LED state. Returns: <code>state</code> - state on / off [<code>true</code>:<code>false</code>]  </p> <p>Set LED state on / off. Parameter: <code>state</code> - on / off [<code>true</code>:<code>false</code>].</p> <p>Same as <code>isOn()</code>. Returns: <code>state</code> - on / off [<code>true</code>:<code>false</code>].</p>"},{"location":"roboboard/api/led/#on","title":"LED.on()","text":""},{"location":"roboboard/api/led/#off","title":"LED.off()","text":""},{"location":"roboboard/api/led/#toggle","title":"LED.toggle()","text":""},{"location":"roboboard/api/led/#isOn","title":"<code>state</code> LED.isOn()","text":""},{"location":"roboboard/api/led/#setState","title":"LED.setState(<code>state</code>)","text":""},{"location":"roboboard/api/led/#getState","title":"<code>state</code> LED.getState()","text":""},{"location":"roboboard/api/led/#blink","title":"Blink","text":"<p>Blink LED 5 times.  </p> <p>Blink LED number of times. Parameter: <code>count</code> - number of times to blink LED [<code>1</code>, <code>2</code>, <code>3</code>, ...]  </p> <p>Blink LED number of times with custom on and off durations. Parameter: <code>count</code> - number of times to blink LED [<code>1</code>, <code>2</code>, <code>3</code>, ...] <code>onTime</code> - how long LED is ON (time ms) (default 100) <code>offTime</code> - how long LED is OFF (time ms) (default 200)  </p>"},{"location":"roboboard/api/led/#blink","title":"LED.blink()","text":""},{"location":"roboboard/api/led/#blink-count","title":"LED.blink(<code>count</code>)","text":""},{"location":"roboboard/api/led/#blink-count-time","title":"LED.blink(<code>count</code>,<code>onTime</code>,<code>offTime</code>)","text":""},{"location":"roboboard/api/led/#wait","title":"<code>state</code> LED.wait()","text":"<p>Halts code execution until LED stops blinking. Contains timeout feature for maximum amount of <code>time</code> to wait. Parameter: <code>time</code> - maximum time to wait (ms) for LED blink stop. <code>0</code> - disabled. Returns: <code>state</code> - <code>true</code> if stopped, <code>false</code> if timeout.  </p>"},{"location":"roboboard/api/led/#wait-time","title":"<code>state</code> LED.wait(<code>time</code>)","text":""},{"location":"roboboard/api/led/#external-gpio-led","title":"External GPIO LED","text":"RoboBoard X3RoboBoard X4 <pre><code>IOLED gpioLed(IO33); // LED connected to pin IO33\ngpioLed.on(); // Turn LED on\n</code></pre> <pre><code>IOLED gpioLed(GPIOA); // LED connected to pin GPIOA\ngpioLed.on(); // Turn LED on\n</code></pre> <p><code>IOLED</code> can be used for external LED connected to any GPIO pin. It requires pin number and pin state when lit on (for algorithm to know when LED is on). All same functions are available as for <code>LED</code> object.</p> <p>Note: \"blink()\" can be used only with single LED at a time.</p> <p>Constructor:</p>"},{"location":"roboboard/api/led/#IOLED","title":"IOLED(<code>pin</code>)","text":"<p>Create LED control object. Parameter: <code>pin</code> - GPIO pin number <code>onLevel</code> - pin state when LED is on [LOW:HIGH]. Default - HIGH.  </p> <pre><code>IOLED led1(IO33); // LED on pin IO33. Pin state HIGH to lit on\nIOLED led2(IO33, HIGH); // LED on pin IO33. Pin state HIGH to lit on\nIOLED led2(IO33, LOW); // LED on pin IO33. Pin state LOW to lit on\n</code></pre>"},{"location":"roboboard/api/led/#IOLED","title":"IOLED(<code>pin</code>,<code>onLevel</code>)","text":""},{"location":"roboboard/api/rgb/","title":"RGB","text":"<p>Control 4 individual RGB lights (A, B, C, D) located at the edge of RoboBoard. By default it shines \"Totem\" colors. Can be controlled from smartphone app to customize robot appearance or using API for different colors or animations.</p> <p>May access specific light or all at once:</p> <ul> <li><code>RGB.A</code>, <code>RGB.B</code>, <code>RGB.C</code>, <code>RGB.D</code> - control single light  </li> <li><code>RGB[0]</code> - control LED A [<code>1</code>-B, <code>2</code>-C, <code>3</code>-D] (invalid indexes will be ignored) </li> <li><code>RGB</code> - control all LEDs  </li> </ul>"},{"location":"roboboard/api/rgb/#code-snippets","title":"Code snippets","text":"<pre><code>// Set all LED\nRGB.colorTotem();           // Set all LED to Totem colors\nRGB.color(Color::Violet);   // Set all LED to violet color\nRGB.color(0xFFFF00);        // Set all LED to yellow color\nRGB.color(0, 255, 0);       // Set all LED to green color\nRGB.color(Color::random()); // Set all LED to random generated color\n// Set single LED\nRGB.A.color(Color::White);  // Set RGB A to white color\nRGB.B.color(Color::Red);    // Set RGB B to red color\nRGB.C.color(0x00FFFF);      // Set RGB C to cyan color\nRGB[3].color(0, 0, 255);    // Set RGB D to blue color\n// Control functions\nRGB.on();             // Turn LED on\nRGB.off();            // Turn LED off\nRGB.toggle();         // Toggle on/off\n// Individual random color\nfor (int i=0; i&lt;4; i++) {\n  RGB[i].color(Color::random());\n}\n</code></pre>"},{"location":"roboboard/api/rgb/#functions","title":"Functions","text":""},{"location":"roboboard/api/rgb/#control","title":"Control","text":"<p>Read Color formats for more details how color is represented with numbers.</p> Click to pick RGB color: <p>Lit up all LED with \"Totem\" colors ( ).  </p>"},{"location":"roboboard/api/rgb/#colorTotem","title":"RGB.colorTotem()","text":""},{"location":"roboboard/api/rgb/#color-rgb","title":"RGB.color(<code>red</code>, <code>green</code>, <code>blue</code>)","text":"<p>Set LED color with RGB or HEX format. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0x000000</code>:<code>0xFFFFFF</code>]  </p> <p>Turn LED on to last used color.  </p> <p>Turn LED off.  </p> <p>Toggle LED between on / off states.  </p> <p>Check if LED is currently lit on. Returns: <code>state</code> - <code>true</code> if lit on. <code>false</code> otherwise (off).</p> <p>Get current LED color. Returns: <code>hex</code> - hexadecimal color code [<code>0x000000</code>:<code>0xFFFFFF</code>]  </p> <p>Set LED to specific state (on / off). Parameter: <code>state</code> - state on / off [<code>HIGH</code>:<code>LOW</code>] or [<code>true</code>:<code>false</code>]  </p> <p>Same as <code>isOn()</code>. Returns: <code>state</code> - <code>true</code> if lit on. <code>false</code> otherwise (off).</p>"},{"location":"roboboard/api/rgb/#color-hex","title":"RGB.color(<code>hex</code>)","text":""},{"location":"roboboard/api/rgb/#on","title":"RGB.on()","text":""},{"location":"roboboard/api/rgb/#off","title":"RGB.off()","text":""},{"location":"roboboard/api/rgb/#toggle","title":"RGB.toggle()","text":""},{"location":"roboboard/api/rgb/#isOn","title":"<code>state</code> RGB.isOn()","text":""},{"location":"roboboard/api/rgb/#getColor","title":"<code>hex</code> RGB.getColor()","text":""},{"location":"roboboard/api/rgb/#setState","title":"RGB.setState(<code>state</code>)","text":""},{"location":"roboboard/api/rgb/#getState","title":"<code>state</code> RGB.getState()","text":""},{"location":"roboboard/api/rgb/#configure","title":"Configure","text":"<p>Limit maximum LED brightness. Default values: X3 - <code>128</code>. X4 - <code>255</code>. Parameter: <code>level</code> - [<code>0</code>:<code>255</code>] maximum brightness.</p> <p>Get configured LED brightness. Returns: <code>level</code> - [<code>0</code>:<code>255</code>] maximum brightness.</p> <p>Enable / disable RGB light. Disabled LED will not lit up. Parameter: <code>state</code> - LED is enabled / disabled [<code>true</code>:<code>false</code>].</p> <p>Check if RGB light is enabled. Returns: <code>state</code> - LED is enabled / disabled [<code>true</code>:<code>false</code>].</p>"},{"location":"roboboard/api/rgb/#setBrightness","title":"RGB.setBrightness(<code>level</code>)","text":""},{"location":"roboboard/api/rgb/#getBrightness","title":"<code>level</code> RGB.getBrightness()","text":""},{"location":"roboboard/api/rgb/#setEnable","title":"RGB.setEnable(<code>state</code>)","text":""},{"location":"roboboard/api/rgb/#getEnable","title":"<code>state</code> RGB.getEnable()","text":""},{"location":"roboboard/api/rgb/#color-names","title":"Color names","text":"totem-color.h<pre><code>namespace Color {\nenum {\n    IndianRed = 0xFFCD5C5C,\n    LightCoral = 0xFFF08080,\n    Salmon = 0xFFFA8072,\n    Crimson = 0xFFDC143C,\n    Red = 0xFFFF0000,\n    FireBrick = 0xFFB22222,\n    DarkRed = 0xFF8B0000,\n    ...\n</code></pre> <p>Object <code>Color</code> contains a list of names with predefined HEX codes. A more convenient way to control LED color, compared to specifying exact RGB values. Full list can be found in totem-color.h file.</p>"},{"location":"roboboard/api/rgb/#color-formats","title":"Color formats","text":"Click to pick RGB color: <p>Available color formats:</p> <ul> <li> NAME: <code>Color::Red</code>, <code>Color::Violet</code>, ...  </li> <li> RGB value: 8-bit amount [<code>0</code>:<code>255</code>] of Red, Green, Blue colors mix.  </li> <li> HEX code: hexadecimal color code <code>0xFFFFFF</code> (similar to HTML code <code>#FFFFFF</code>).  </li> </ul> <p>HEX format encoding:</p> <p>Conversion between HEX and RGB formats.</p> <p>24-bit: <code>0xAABBCC</code> \u2192 <code>0xAA</code> (170 red), <code>0xBB</code> (187 green), <code>0xCC</code> (204 blue).  </p> <p>Use with RoboBoard color functions:</p> <ul> <li><code>RGB.color(Color::Violet)</code> - set color name</li> <li><code>RGB.color(100, 150, 200)</code> - set color mix of Red, Green, Blue [<code>0</code>:<code>255</code>] values</li> <li><code>RGB.color(0xFFAABB)</code> - set color HEX code [<code>0x000000</code>:<code>0xFFFFFF</code>]</li> </ul>"},{"location":"roboboard/api/rgb/#color-mix-functions","title":"Color mix functions","text":"<p>Functions for mixing color from RGB values and returning single HEX code. Useful if color has to be stored to <code>int</code> variable for later use with <code>color()</code> function.</p> <p>Mix color by provided parameters. Returns: 24-bit color code. Parameter: <code>red</code> - amount of red color [<code>0</code>:<code>255</code>] <code>green</code> - amount of green color [<code>0</code>:<code>255</code>] <code>blue</code> - amount of blue color [<code>0</code>:<code>255</code>] <code>hex</code> - hexadecimal color code [<code>0x000000</code>:<code>0xFFFFFF</code>]  </p> <p>Generate random color. Returns: 24-bit color code.  </p>"},{"location":"roboboard/api/rgb/#rgb","title":"<code>hex</code> Color::rgb(<code>red</code>,<code>green</code>,<code>blue</code>)","text":""},{"location":"roboboard/api/rgb/#random","title":"<code>hex</code> Color::random()","text":""},{"location":"roboboard/api/servo/","title":"Servo","text":"<p>Servo wire colors:  \u2022 Orange = Signal (PWM) \u2022 Red = VCC \u2022 Brown = GND </p> <p>Motor control interface for RoboBoard 3-pin SERVO ports.May access specific port or all at once:</p> <ul> <li><code>Servo.A</code>, <code>Servo.B</code>, <code>Servo.C</code>, <code>Servo.D</code> - control single port  </li> <li><code>Servo[0]</code> - control port A [<code>1</code>-B, <code>2</code>-C, <code>3</code>-D] (invalid indexes will be ignored) </li> <li><code>Servo</code> - control all ports (some \"get\" functions are not available in this case) </li> </ul>"},{"location":"roboboard/api/servo/#code-snippets","title":"Code snippets","text":"Function usage example<pre><code>// Control all servo ports\nServo.spinPos(0); // Move to center\nServo.spinPos(60); // Move 60% right\nServo.spinPosDuration(0, 1500); // Move to center in 1.5s\nServo.spinPosRPM(60, 30); // Move 60% right at 30RPM speed\nServo.spinAngle(0); // Move left\nServo.spinAngle(90); // Move to 90\u00b0 (center)\nServo.spinPulse(1500); // Move to 1500\u00b5s (center)\nServo.coast(); // Motor free spin (no hold)\n// Stop servo port B\nServo[1].stop();\n// Configure servo A port\nServo.A.setInvert(true); // Invert spin direction\nServo.A.setSpeedRPM(30); // Set arm speed to 30RPM\nServo.A.setSpeedS60(0.17); // Set arm speed to 0.17s/60\u00b0\nServo.A.setTrim(-38, -7, 18); // Map pos to L: -38, C: -7, R: 18\n// Change all ports period\nServo.setPeriod(20000); // Set period to 20000\u00b5s\n</code></pre> <p>Most servos can turn its arm 180 degrees. This is controlled by applying range of 500-2500 \u03bcs (microseconds) pulse to signal wire. This corresponds to servo arm position. For convenience - there are 3 different control units:</p> <ul> <li><code>spinPos()</code> - set position in percentage of range [<code>-100</code>:<code>100</code>]%. <code>0</code> - center.</li> <li><code>spinAngle()</code> - set position in angle degrees [<code>0</code>:<code>180</code>]\u00b0. <code>90</code> - center.</li> <li><code>spinPulse()</code> - set actual microseconds pulse [<code>500</code>:<code>2500</code>]\u03bcs. <code>1500</code> - center.</li> </ul> <p>In case <code>setInvert(true)</code> is enabled - servo arm will move to different direction, thus \"pos\" and \"angle\" values are inverted. \"pulse\" stays the same.</p>"},{"location":"roboboard/api/servo/#calibration-trimming","title":"Calibration / trimming","text":"<p><code>Servo</code> contains trimming feature to limit motor position to configured range. Mainly used for car steering with calibrated center position and maximum travel to left and right.</p> <p></p> <p>When configured, function <code>spinPos()</code> [<code>-100</code>:<code>100</code>] can be used to steer robot wheels.</p> <p>Select motor parameters</p> <p>Most servos operate in 500 to 2500\u03bcsec range and can turn its arm either 180\u00b0 or 270\u00b0. Set correct parameters if you are using different type of motor:</p> <ul> <li><code>setMotor(180, 500, 2500)</code> - 180\u00b0, 500-2500 \u03bcs (default)</li> <li><code>setMotor(180, 1000, 2000)</code> - 180\u00b0, 1000-2000 \u03bcs</li> <li><code>setMotor(270, 500, 2500)</code> - 270\u00b0, 500-2500 \u03bcs</li> <li><code>setMotor(270, 1000, 2000)</code> - 270\u00b0, 1000-2000 \u03bcs</li> </ul> <p>These values may be adjusted to match correct (calibrated) motor angle and pulses. Function <code>spinPulseRaw()</code> can be used to find actual limits. Can use <code>SerialServoControl.ino</code> example.  </p> <p>Tip</p> <p>Some RoboBoard X3 kits contain motor with different microseconds range. Add this configuration line to make it work properly: <code>Servo.A.setMotor(180, 650, 2350)</code></p> <p>Change spin direction</p> <p>Using function <code>spinPos()</code> with negative / positive value [<code>-100</code>:<code>100</code>] will move motor between configured [<code>500</code>:<code>2500</code>] pulse range. If direction should be reversed - use function: <code>setInvert(true)</code>.</p> <p>Trim motor position</p> <p>Typically, function <code>spinPos()</code> [<code>-100</code>:<code>100</code>] will turn servo motor in its full range. When placed in a robot - most of the times there are mechanical limits that should be accounted for and center position is shifted. Trimming allows to offset center position and specify how far motor should spin to either side.  </p> <ol> <li>Use function <code>spinPos()</code> to find center position and maximum turn to left and right</li> <li>Enter discovered values to function <code>setTrim(-38, -7, 18)</code></li> </ol> <p>Now function <code>spinPos()</code> [<code>-100</code>:<code>100</code>] will operate inside configured limits.</p> <pre><code>// Calibrate\nServo.A.setMotor(180, 500, 2500); // angle, usMin, usMax\nServo.A.setInvert(true); // invert\nServo.A.setTrim(-38, -7, 18); // position limits left, center, right\n// Move (spin to position)\nServo.A.spinPos(0); // [-100:100] (spins to -7)\n</code></pre>"},{"location":"roboboard/api/servo/#functions","title":"Functions","text":""},{"location":"roboboard/api/servo/#position-control","title":"Position control","text":""},{"location":"roboboard/api/servo/#spinPos","title":"Servo.A.spinPos(<code>position</code>)","text":""},{"location":"roboboard/api/servo/#spinPosDuration","title":"Servo.A.spinPosDuration(<code>position</code>,<code>duration</code>)","text":"<p>Move servo to position (%). Parameter: <code>position</code> - servo position [<code>-100</code>:<code>100</code>]% <code>duration</code> - time duration for position to change time in ms <code>speed</code> - motor speed in rounds per minute (RPM) units [<code>1</code>:<code>~60</code>].  </p>"},{"location":"roboboard/api/servo/#spinPosRPM","title":"Servo.A.spinPosRPM(<code>position</code>,<code>speed</code>)","text":""},{"location":"roboboard/api/servo/#spinAngle","title":"Servo.A.spinAngle(<code>angle</code>)","text":""},{"location":"roboboard/api/servo/#spinAngleDuration","title":"Servo.A.spinAngleDuration(<code>angle</code>,<code>duration</code>)","text":"<p>Move servo to angle (\u00b0). Note: maximum angle depends on <code>setMotor()</code> configuration. Parameter: <code>angle</code> - servo angle [<code>0</code>:<code>180</code>]\u00b0 <code>duration</code> - time duration for position to change time in ms <code>speed</code> - motor speed in rounds per minute (RPM) units [<code>1</code>:<code>~60</code>]  </p>"},{"location":"roboboard/api/servo/#spinAngleRPM","title":"Servo.A.spinAngleRPM(<code>angle</code>,<code>speed</code>)","text":""},{"location":"roboboard/api/servo/#spinPulse","title":"Servo.A.spinPulse(<code>pulse</code>)","text":""},{"location":"roboboard/api/servo/#spinPulseDuration","title":"Servo.A.spinPulseDuration(<code>pulse</code>,<code>duration</code>)","text":"<p>Move servo to exact pulse (\u00b5s). Parameter: <code>pulse</code> - time [<code>500</code>:<code>2500</code>]\u00b5s (microseconds) <code>duration</code> - time duration for position to change time in ms <code>speed</code> - motor speed in rounds per minute (RPM) units [<code>1</code>:<code>~60</code>]  </p> <p>Write pulse directly, without any value filter and conversion. Also ignores <code>setInvert()</code>. Parameter: <code>pulse</code> - time [<code>0</code>:period]\u00b5s (microseconds)  </p> <p>Set motor to free spin (can be moved by hand). Stops PWM signal output. Note: Some motors may not support this feature (holds position even without PWM signal).</p> <p>Get current servo position (%). Returns: <code>position</code> - servo position [<code>-100</code>:<code>100</code>]%  </p> <p>Get current servo angle (\u00b0). Returns: <code>angle</code> - servo angle [<code>0</code>:<code>180</code>]\u00b0  </p> <p>Get current servo pulse (\u00b5s). Returns: <code>pulse</code> - pulse time [<code>500</code>:<code>2500</code>]\u00b5s (microseconds)  </p>"},{"location":"roboboard/api/servo/#spinPulseRPM","title":"Servo.A.spinPulseRPM(<code>pulse</code>,<code>speed</code>)","text":""},{"location":"roboboard/api/servo/#spinPulseRaw","title":"Servo.A.spinPulseRaw(<code>pulse</code>)","text":""},{"location":"roboboard/api/servo/#coast","title":"Servo.A.coast()","text":""},{"location":"roboboard/api/servo/#getPos","title":"<code>position</code> Servo.A.getPos()","text":""},{"location":"roboboard/api/servo/#getAngle","title":"<code>angle</code> Servo.A.getAngle()","text":""},{"location":"roboboard/api/servo/#getPulse","title":"<code>pulse</code> Servo.A.getPulse()","text":""},{"location":"roboboard/api/servo/#limit-trimming","title":"Limit trimming","text":""},{"location":"roboboard/api/servo/#setTrim","title":"Servo.A.setTrim(<code>left</code>,<code>right</code>)","text":"<p>Set motor rotation limits for <code>spinPos()</code> function. Uses position percentage parameters. \u2022 Parameter values must come in order! left &lt; center &lt; right. \u2022 <code>setInvert()</code> must be set correctly before calling this function. Position values internally are converted to pulses. \u2022 If <code>center</code> parameter is not provided - it is set to middle value between <code>left</code> and <code>right</code>. Parameter: <code>left</code> - steer to left limit [<code>-100</code>:<code>100</code>]% <code>center</code> - center position [<code>-100</code>:<code>100</code>]% <code>right</code> - steer to right limit [<code>-100</code>:<code>100</code>]%  </p>"},{"location":"roboboard/api/servo/#setTrim-center","title":"Servo.A.setTrim(<code>left</code>,<code>center</code>,<code>right</code>)","text":""},{"location":"roboboard/api/servo/#setTrimPulse","title":"Servo.A.setTrimPulse(<code>min</code>,<code>max</code>)","text":"<p>Set motor rotation limits for <code>spinPos()</code> function. Uses exact pulse (\u00b5s) parameters. Function <code>spinPulseRaw()</code> can be used to discover required values. \u2022 Parameter values must come in order! min &lt; center &lt; max. \u2022 [<code>usMin</code>:<code>usMax</code>] range depends on <code>setMotor()</code> configuration. Typically [<code>500</code>:<code>2500</code>]. \u2022 If <code>center</code> parameter is not provided - it is set to middle value between <code>min</code> and <code>max</code>. Parameter: <code>min</code> - minimum pulse limit [<code>usMin</code>:<code>usMax</code>]\u00b5s (microseconds) <code>center</code> - center pulse position [<code>usMin</code>:<code>usMax</code>]\u00b5s (microseconds) <code>max</code> - maximum pulse limit [<code>usMin</code>:<code>usMax</code>]\u00b5s (microseconds)  </p>"},{"location":"roboboard/api/servo/#setTrimPulse-center","title":"Servo.A.setTrimPulse(<code>min</code>,<code>center</code>,<code>max</code>)","text":""},{"location":"roboboard/api/servo/#spin-speed","title":"Spin speed","text":""},{"location":"roboboard/api/servo/#setSpeedRPM","title":"Servo.A.setSpeedRPM(<code>speed</code>)","text":"<p>Set constant servo speed (to slow it down). Servo motors are capable ~60 RPM at top. Setting value <code>0</code> will use maximum motor speed. Parameter: <code>speed</code> - motor speed in rounds per minute (RPM) units [<code>1</code>:<code>~60</code>]. <code>seconds</code> - (float) motor speed in seconds / 60 degree units (e.g. <code>0.16</code> = 62.5RPM). It is commonly found in servo motors description. </p>"},{"location":"roboboard/api/servo/#setSpeedS60","title":"Servo.A.setSpeedS60(<code>seconds</code>)","text":""},{"location":"roboboard/api/servo/#getSpeedRPM","title":"<code>speed</code> Servo.A.getSpeedRPM()","text":"<p>Get configured servo speed. Returns: <code>speed</code> - motor speed in rounds per minute (RPM) units [<code>1</code>:<code>~60</code>]. <code>seconds</code> - (float) motor speed in seconds / 60 degree units (e.g. <code>0.16</code> = 62.5RPM). It is commonly found in servo motors description. </p>"},{"location":"roboboard/api/servo/#getSpeedS60","title":"<code>seconds</code> Servo.A.getSpeedS60()","text":""},{"location":"roboboard/api/servo/#move-sequences","title":"Move sequences","text":"<p>Run list of predefined servo movements with position and delay. Convenient to use when some repetitive action has to be performed in background.  </p> <pre><code>void setup() {\n  // Run list of inline servo movements\n  Servo.A.run({\n    {500, 0},    // delay:500, position:0\n    {500, -50},  // delay:500, position:-50\n    {1000, 0},   // delay:1s, position:0\n    {500, 50},   // delay:500, position:-50\n  });\n  Servo.A.wait(); // Wait for started sequence to end\n  // Define sequence list\n  ServoSequence list[] = {\n    {500, 40},     // delay:500, position:40\n    {500, 0},      // delay:500, position:0\n    {500, -40},    // delay:500, position:-40\n    {500, 0},      // delay:500, position:0\n  };\n  // Run specified list 3 times and stop\n  Servo.A.run(list, 3);\n}\nvoid loop() { }\n</code></pre> <p>Maximum of 6 moves in sequence available.</p>"},{"location":"roboboard/api/servo/#run","title":"Servo.A.run(<code>sequence[]</code>)","text":"<p>Run provided list of movements in order. Executed in background and does not block code. Additionally, <code>times</code> parameter can be provided to repeat this list number of times. Parameter: <code>sequence[]</code> - array of <code>ServoSequence</code>. <code>times</code> - number of times to repeat sequence. <code>0</code> - repeat. Default: <code>1</code>.  </p> <p>Check if servo motor is currently moving. Works in a few cases: 1. Motor is executing servo sequence <code>run()</code>. 2. Motor is moving with custom speed <code>setSpeedRPM()</code>. 3. Motor is moving with duration/RPM <code>spinPosDuration()</code>. Other cases it will return <code>false</code>! Returns: <code>state</code> - <code>true</code> if motor is moving, <code>false</code> if stationary.  </p>"},{"location":"roboboard/api/servo/#run-times","title":"Servo.A.run(<code>sequence[]</code>, <code>times</code>)","text":""},{"location":"roboboard/api/servo/#isMoving","title":"<code>state</code> Servo.A.isMoving()","text":""},{"location":"roboboard/api/servo/#wait","title":"<code>state</code> Servo.A.wait()","text":"<p>Wait for motor to stop moving (block code until). Works in a few cases: 1. Motor is executing servo sequence <code>run()</code>. 2. Motor is moving with custom speed <code>setSpeedRPM()</code>. 3. Motor is moving with duration/RPM <code>spinPosDuration()</code>. Other cases it will return <code>true</code> right away without blocking! Parameter: <code>time</code> - maximum time to wait (ms) for motor move end. <code>0</code> - disabled. Returns: <code>state</code> - <code>true</code> motor finish moving, <code>false</code> timeout.  </p> <p>Stop currently moving servo motor: 1. Running servo sequence (started with <code>run()</code>). 2. Moving with configured duration/RPM.  </p>"},{"location":"roboboard/api/servo/#wait-time","title":"<code>state</code> Servo.A.wait(<code>time</code>)","text":""},{"location":"roboboard/api/servo/#stop","title":"Servo.A.stop()","text":""},{"location":"roboboard/api/servo/#configuration","title":"Configuration","text":"<p>Enable / disable servo output. Will stop signal generation if disabled. Parameter: <code>state</code> - turn motor port on / off [<code>true</code>:<code>false</code>].  </p> <p>Invert servo spin direction. Parameter: <code>state</code> - invert spin direction [<code>true</code>:<code>false</code>]  </p> <p>Set Servo motor configuration. Default: 180deg, 500us, 2500us Parameter: <code>angle</code> - maximum motor spin angle (180deg or 270deg) <code>usMin</code> - min position pulse [<code>0</code>:period]\u00b5s (microseconds) <code>usMax</code> - max position pulse [<code>0</code>:period]\u00b5s (microseconds)  </p> <p>Check if servo output is enabled (yes / no). Returns: <code>state</code> - enabled / disabled [<code>true</code>:<code>false</code>].  </p> <p>Check if motor spin direction is inverted (yes / no). Returns: <code>state</code> - yes / no [<code>true</code>:<code>false</code>].  </p> <p>Get servo motor configuration of <code>setMotor()</code>. Default (<code>180</code>,<code>500</code>,<code>2500</code>) \u00b5s. Returns: <code>Params</code> - MotorType structure. <pre><code>void setup() {\n    auto range = Servo.A.getMotor();\n    range.angle; // Max angle\n    range.usMin; // Min microseconds limit\n    range.usMax; // Max microseconds limit\n    // Alternative use\n    Servo.A.getMotor().angle;\n    Servo.A.getMotor().usMin;\n    Servo.A.getMotor().usMax;\n}\n</code></pre></p>"},{"location":"roboboard/api/servo/#setEnable","title":"Servo.A.setEnable(<code>state</code>)","text":""},{"location":"roboboard/api/servo/#setInvert","title":"Servo.A.setInvert(<code>state</code>)","text":""},{"location":"roboboard/api/servo/#setMotor","title":"Servo.A.setMotor(<code>angle</code>,<code>usMin</code>,<code>usMax</code>)","text":""},{"location":"roboboard/api/servo/#getEnable","title":"<code>state</code> Servo.A.getEnable()","text":""},{"location":"roboboard/api/servo/#getInvert","title":"<code>state</code> Servo.A.getInvert()","text":""},{"location":"roboboard/api/servo/#getMotor","title":"<code>Params</code> Servo.A.getMotor()","text":""},{"location":"roboboard/api/servo/#getTrim","title":"<code>Range</code> Servo.A.getTrim()","text":"<p>Get configured position range of <code>setTrim()</code>. Default: [<code>-100</code>:<code>0</code>:<code>100</code>]. Returns: <code>Range</code> - Range structure. <pre><code>void setup() {\n    auto range = Servo.A.getTrim();\n    range.min;\n    range.mid;\n    range.max;\n    // Alternative use\n    Servo.A.getTrim().min;\n    Servo.A.getTrim().mid;\n    Servo.A.getTrim().max;\n}\n</code></pre></p> <p>Get number of servo ports board has. Returns: <code>number</code> - servo ports count [<code>2</code>:<code>4</code>]  </p> <p>Change PWM period:</p> <p>Set custom servo signal period (default 20000\u00b5s (50Hz)) (all ports) Parameter: <code>period</code> - signal window time [<code>0</code>:<code>65535</code>]\u00b5s (microseconds)  </p> <p>Get configured servo signal period (default 20000\u00b5s (50Hz)). Returns: <code>number</code> - signal window time [<code>0</code>:<code>65535</code>]\u00b5s (microseconds)  </p>"},{"location":"roboboard/api/servo/#getTrimPulse","title":"<code>Range</code> Servo.A.getTrimPulse()","text":""},{"location":"roboboard/api/servo/#getPortsCount","title":"<code>number</code> Servo.getPortsCount()","text":""},{"location":"roboboard/api/servo/#setPeriod","title":"Servo.setPeriod(<code>period</code>)","text":""},{"location":"roboboard/api/servo/#getPeriod","title":"<code>number</code> Servo.getPeriod()","text":""},{"location":"roboboard/api/totemapp/","title":"TotemApp","text":"<p><code>TotemApp.</code> object allows to interact with Totem App, TotemLibrary and get connection events or value changes when button is pressed. Combination of app button editor and RoboBoard programming creates ability to make custom remote controls for particular robot or embedded application. Available for Android and iOS.</p> <p>See guide Custom functions for more detail instructions on executing custom actions on app button press.</p> <p>Related configuration functions: <code>Board.setStatusRGB()</code> and <code>Board.setStatusSound()</code>.</p> <p>Enabled automatically if <code>TotemApp</code> is used inside the code. Enabling this feature increases compiled binary size by 800KB.</p>"},{"location":"roboboard/api/totemapp/#code-snippets","title":"Code snippets","text":"<pre><code>// Got Totem App specific event\nvoid appEvent(int evt, int value) {\n  if (evt == TotemApp.evtFunctionA) {\n    Serial.print(\"Got '/0/functionA': \"); Serial.println(value);\n  }\n  if (evt == TotemApp.evtConnect) {\n    Serial.println(\"Totem App connected\");\n  }\n  if (evt == TotemApp.evtDisconnect) {\n    Serial.println(\"Totem App disconnected\");\n  }\n}\n// Override function called on app button click\n// Allows to modify value before RoboBoard processes it\nbool appOverride(int cmd, int value) {\n  if (cmd == TotemApp.cmdPosA) { // Invert \"/0/serv/posA\" direction\n    Servo.A.spinPos(-value); // Set servo position\n    return false; // Block app command (override)\n  }\n  if (cmd == TotemApp.cmdPowerA) { // Limit \"/0/dc/powerA\" to [-50:50]\n    if (value &gt;= -50 &amp;&amp; value &lt;= 50) return true; // Allow app command\n    // value is above limit. Constrain it\n    DC.A.spin(constrain(value, -50, 50)); // Write motor power\n    return false; // Block app command (override)\n  }\n  // Allow other app commands to be processed by RoboBoard\n  return true;\n}\nvoid setup() {\n  Serial.begin(115200);\n  // Register TotemApp event function\n  TotemApp.addEvent(appEvent);\n  // Register Totem App override function\n  TotemApp.addOverride(appOverride);\n}\n// Loop program\nvoid loop() {\n  // Empty\n}\n</code></pre>"},{"location":"roboboard/api/totemapp/#runtime-control","title":"Runtime control","text":""},{"location":"roboboard/api/totemapp/#begin","title":"TotemApp.begin()","text":"<p>Start Totem App service. Board will be discoverable in connect menu. Note: call to any other <code>TotemApp</code> function will enable this service internally, so <code>TotemApp.begin()</code> is not mandatory. Parameter: <code>name</code> - (optional) change board name displayed in Totem App.  </p> <p>Force to disconnect Totem App.  </p>"},{"location":"roboboard/api/totemapp/#begin-name","title":"TotemApp.begin(<code>name</code>)","text":""},{"location":"roboboard/api/totemapp/#disconnect","title":"TotemApp.disconnect()","text":""},{"location":"roboboard/api/totemapp/#wait","title":"<code>state</code> TotemApp.wait()","text":"<p>Wait for Totem App to connect (block code until). Parameter: <code>time</code> - maximum time to wait (ms) for app connection. <code>0</code> - disabled. Returns: <code>state</code> - <code>true</code> if connected, <code>false</code> if timeout.  </p>"},{"location":"roboboard/api/totemapp/#wait-time","title":"<code>state</code> TotemApp.wait(<code>time</code>)","text":""},{"location":"roboboard/api/totemapp/#receive-events","title":"Receive events","text":"<p>Warning</p> <p>At the moment <code>evtFunction</code> is only available with Android version of Totem App. Use Override commands as an alternative for iOS.</p> <p>Register function to receive data sent from Totem App. Available event types: \u2022 <code>evtFunctionA</code> - topic <code>/0/functionA</code> data received. \u2022 <code>evtFunctionB</code> - topic <code>/0/functionB</code> data received. \u2022 <code>evtFunctionC</code> - topic <code>/0/functionC</code> data received. \u2022 <code>evtFunctionD</code> - topic <code>/0/functionD</code> data received. \u2022 <code>evtConnect</code> - Totem App connected. \u2022 <code>evtDisconnect</code> - Totem App disconnected. Parameter: <code>function</code> - function name [<code>appEvent</code>]. <pre><code>void appEvent(int evt, int value) {\n  if (evt == TotemApp.evtFunctionA) {\n    Serial.print(\"Function A: \"); Serial.println(value);\n  }\n  if (evt == TotemApp.evtFunctionB) {\n    Serial.print(\"Function B: \"); Serial.println(value);\n  }\n  if (evt == TotemApp.evtFunctionC) {\n    Serial.print(\"Function C: \"); Serial.println(value);\n  }\n  if (evt == TotemApp.evtFunctionD) {\n    Serial.print(\"Function D: \"); Serial.println(value);\n  }\n  if (evt == TotemApp.evtConnect) {\n    Serial.println(\"Totem App connected\");\n  }\n  if (evt == TotemApp.evtDisconnect) {\n    Serial.println(\"Totem App disconnected\");\n  }\n}\nvoid setup() {\n  Serial.begin(115200);\n  TotemApp.addEvent(appEvent); // Register TotemApp event function\n}\nvoid loop() {\n\n}\n</code></pre></p>"},{"location":"roboboard/api/totemapp/#addEvent","title":"TotemApp.addEvent(<code>function</code>)","text":""},{"location":"roboboard/api/totemapp/#override-commands","title":"Override commands","text":"<p>Functionality allowing to intercept commands sent by Totem App. Typically button press will apply motor power directly (e.g. <code>/0/dc/powerA</code> \u2192 <code>DC.A.spin()</code>). Any action will be presented in <code>bool appOverride(int cmd, int value)</code> function, providing <code>value</code> and ability to choose either block or allow RoboBoard to process this command.</p> <p>Can be used to intercept standard \"Model\" controls and make your own drive logic or actions.</p> <p>List of app commands:</p> <p>\u2022 <code>TotemApp.cmdPosA</code> - topic <code>/0/serv/posA</code>. \u2022 <code>TotemApp.cmdPosB</code> - topic <code>/0/serv/posB</code>. \u2022 <code>TotemApp.cmdPosC</code> - topic <code>/0/serv/posC</code>. \u2022 <code>TotemApp.cmdPowerA</code> - topic <code>/0/dc/powerA</code>. \u2022 <code>TotemApp.cmdPowerB</code> - topic <code>/0/dc/powerB</code>. \u2022 <code>TotemApp.cmdPowerC</code> - topic <code>/0/dc/powerC</code>. \u2022 <code>TotemApp.cmdPowerD</code> - topic <code>/0/dc/powerD</code>. \u2022 <code>TotemApp.cmdFunctionA</code> - topic <code>/0/functionA</code>. \u2022 <code>TotemApp.cmdFunctionB</code> - topic <code>/0/functionB</code>. \u2022 <code>TotemApp.cmdFunctionC</code> - topic <code>/0/functionC</code>. \u2022 <code>TotemApp.cmdFunctionD</code> - topic <code>/0/functionD</code>.  </p> <p>Known behavior</p> <p>Totem App always sends <code>cmdPowerA</code>, <code>cmdPowerB</code>, <code>cmdPowerC</code>, <code>cmdPowerD</code> as a single message. Even if <code>/0/dc/powerA</code> is the only one set - others will trigger event with value <code>0</code>.</p> <p>Register function to override commands sent from Totem App. Function declaration: <code>bool appOverride(int cmd, int value)</code> <code>cmd</code> - command identifier. <code>value</code> - integer sent from app. Use <code>return false</code> to block command and <code>return true</code> to allow it. Parameter: <code>function</code> - function name [<code>appOverride</code>]. Note: this function is called from Bluetooth environment, running on Core 0. It is not recommended to use heavy operations (like print or delay) inside function body. <pre><code>// Override function called on app button click\nbool appOverride(int cmd, int value) {\n  if (cmd == TotemApp.cmdPosA) {\n    Serial.print(\"/0/serv/posA -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPosB) {\n    Serial.print(\"/0/serv/posB -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPosC) {\n    Serial.print(\"/0/serv/posC -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPowerA) {\n    Serial.print(\"/0/dc/powerA -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPowerB) {\n    Serial.print(\"/0/dc/powerB -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPowerC) {\n    Serial.print(\"/0/dc/powerC -&gt; \"); Serial.println(value);\n  }\n  if (cmd == TotemApp.cmdPowerD) {\n    Serial.print(\"/0/dc/powerD -&gt; \"); Serial.println(value);\n  }\n  // This function requires return!\n  // `true` - pass received command back to RoboBoard\n  // `false` - RoboBoard won't get this command (override)\n  return false;\n}\n// Initialize program\nvoid setup() {\n  Serial.begin(115200);\n  // Register Totem App override function\n  TotemApp.addOverride(appOverride);\n}\n// Loop program\nvoid loop() {\n  // Empty\n}\n</code></pre></p>"},{"location":"roboboard/api/totemapp/#addOverride","title":"TotemApp.addOverride(<code>function</code>)","text":""},{"location":"roboboard/api/totemapp/#totem-library","title":"Totem Library","text":"<p>Exchange user defined data between RoboBoard and Totem Arduino library. It can be used to simulate Totem iOS/Android app and remotely control the board from any other ESP32 Arduino development board.</p> <p>Register receive functions for remote <code>sendValue</code>, <code>sendString</code> in TotemArduino library. It accepts value and string functions. Both can be added at the same time. Note: will be renamed to <code>TotemApp.addOnReceive()</code>. Parameter: <code>function</code> - <code>void onReceiveValue(int id, int value)</code> <code>function</code> - <code>void onReceiveString(int id, String str)</code> <pre><code>// Intercept value sent by sendValue() (from Totem Library)\nvoid onReceiveValue(int id, int value) {\n\n}\n// Intercept string sent by sendString() (from Totem Library)\nvoid onReceiveString(int id, String string) {\n\n}\nvoid setup() {\n  // Start Totem App service\n  TotemApp.begin();\n  // Register receive value handlers\n  TotemApp.addOnSend(onReceiveValue);\n  TotemApp.addOnSend(onReceiveString);\n}\n</code></pre></p> <p>Register read handlers for remote <code>readValue</code>, <code>readString</code> in TotemArduino library. It accepts value and string functions. Both can be added at the same time. Parameter: <code>function</code> - <code>int onReadValue(int id)</code> <code>function</code> - <code>String onReadString(int id)</code> <pre><code>// Return value requested by readValue() (from Totem Library)\nint onReadValue(int id) {\n  return 0;\n}\n// Return string requested by readString() (from Totem Library)\nString onReadString(int id) {\n  return \"\";\n}\nvoid setup() {\n  // Start Totem App service\n  TotemApp.begin();\n  // Register read value handlers\n  TotemApp.addOnRead(onReadValue);\n  TotemApp.addOnRead(onReadString);\n}\n</code></pre></p> <p>Send 32-bit value to TotemArduino library. Receive using <code>addOnReceive()</code>. Parameter: <code>id</code> - 32-bit identifier <code>value</code> - 32-bit value Returns: <code>state</code> - send [<code>true</code>]-success, [<code>false</code>]-error</p> <p>Function sendString bug</p> <p>Calling <code>TotemApp.sendString(10, \"Message\")</code> will send empty message. Temporary fix:  </p> <ul> <li>Wrap message into String() object <code>TotemApp.sendString(10, String(\"Message\"))</code></li> </ul> <p>Send string (text) to TotemArduino library. Receive using <code>addOnReceive()</code>. Parameter: <code>id</code> - 32-bit identifier <code>string</code> - String object Returns: <code>state</code> - send [<code>true</code>]-success, [<code>false</code>]-error</p> <p>Send data array to TotemArduino library. Receive using <code>addOnReceive()</code>. Parameter: <code>id</code> - 32-bit identifier <code>data</code> - pointer to string or data array <code>len</code> - data length Returns: <code>state</code> - send [<code>true</code>]-success, [<code>false</code>]-error</p>"},{"location":"roboboard/api/totemapp/#addOnSend","title":"TotemApp.addOnSend(<code>function</code>)","text":""},{"location":"roboboard/api/totemapp/#addOnRead","title":"TotemApp.addOnRead(<code>function</code>)","text":""},{"location":"roboboard/api/totemapp/#sendValue","title":"<code>state</code> TotemApp.sendValue(<code>id</code>, <code>value</code>)","text":""},{"location":"roboboard/api/totemapp/#sendString","title":"<code>state</code> TotemApp.sendString(<code>id</code>, <code>string</code>)","text":""},{"location":"roboboard/api/totemapp/#sendString","title":"<code>state</code> TotemApp.sendString(<code>id</code>, <code>data</code>, <code>len</code>)","text":""},{"location":"roboboard-x3/","title":"RoboBoard X3","text":"<p>A programmable controller, designed for small to medium sized robots with strict space requirements or low power applications. This tiny package features components that are essential for robotic applications: battery input, charging, motor drivers, modules and sensors extensions, orientation sensor, powerful processor, wireless connectivity, software support and more. To start programming install Arduino and check RoboBoard API section.</p> <p>Find at:  Totemmaker.net store \u2192 RoboBoard X3 </p> <p>Note: older revision v3.0 has only 2 servo ports. Check Revision changelog.</p>  Arduino setup  Smartphone control  Arduino examples"},{"location":"roboboard-x3/#feature-list","title":"Feature list","text":"Click orange box to jump to explanation <p>Processor: \u2022 ESP32 chip (ESP32-D0WD) \u2022 Dual-core 240Mhz (Xtensa LX6) \u2022 320KB SRAM, 8MB flash \u2022 Bluetooth (classic and BLE) \u2022 Wi-Fi  </p> <p>Board features: \u2022 4 Servo motor ports (3.7 Volt) \u2022 4 DC motor ports (3.7 Volt) \u2022 3 GPIO pins + (4 servo SIG) \u2022 2 LDO regulators \u2022 4 RGB lights \u2022 IMU sensor (accel and gyro) \u2022 Reset, Boot buttons \u2022 On/Off switch \u2022 Battery input, integrated charger \u2022 Qwiic (STEMMA QT compatible) \u2022 USB-C (power, data, charging) \u2022 GPIO connector  </p> <p>Power: \u2022 USB-C: 5V \u2022 Battery: LiPo, 3.7V, 250 mAh  </p> <p>Dimensions: \u2022 65 x 25 x 8 mm (L x W x H) </p>"},{"location":"roboboard-x3/#esp32","title":"ESP32","text":"<p>RoboBoard is powered by ESP32 - a capable SoC with rich peripherals and wireless connectivity. This combinations makes it perfect for robotic applications where motor driving and wireless control is required.</p> <p>For a past few years ESP32 is one of the most popular microcontroller among maker community. While its hardware capabilities are no doubt it also comes with vast software support, maintained officially by Espressif company and a help from community. This led to well established Arduino support for ESP32, powering many projects all over the world. Our Arduino support for RoboBoard is based on official core for maintaining compatibility with libraries and examples with addition to well integrated RoboBoard features.</p> <p>For more ESP32 specific details read ESP32 section.</p>"},{"location":"roboboard-x3/#board-features","title":"Board features","text":""},{"location":"roboboard-x3/#qwiic-port","title":"Qwiic port","text":"<p>Wires: \u2022 Black = GND \u2022 Red = 3.3V \u2022 Blue = SDA \u2022 Yellow = SCL </p> <p>Cable: standard \"Qwiic cable\". Can be found in local electronics store. Connector: SM04B-SRSS-TB 4-pin  </p> <p>A connection system to attach third-party I2C modules. This allows to choose from many available sensors and other interface devices. Small and sturdy connector eliminates need for soldering and enables plug-and-play style modular systems. Each module comes with it's own Arduino library (supplied by manufacturer).</p> <p>This port is compatible with SparkFun Qwiic and Adafruit STEMMA QT modules. For using Qwiic modules with RoboBoard read GPIO / Qwiic section.  </p> <p>3.3V is provided by second LDO converter and can be switched on/off with <code>Board.setEnable3V3()</code>. Read Power circuit section for more details. </p>"},{"location":"roboboard-x3/#imu-sensor","title":"IMU sensor","text":"<p>6DOF IMU sensor (3-axis accelerometer and 3-axis gyroscope) allows to detect board movement and orientation. Very useful in many robotic projects. Chip is connected to I2C line (same as Qwiic connector) and can be accessed trough API functions <code>IMU</code>.</p> <pre><code>#include &lt;Wire.h&gt;\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n}\nvoid loop() {\n  auto result = IMU.read(); // Read sensor measurements\n  Serial.println(result.getX_G()); // Read unit from \"result\"\n  delay(100); // Wait 100ms for next read\n}\n</code></pre>"},{"location":"roboboard-x3/#rgb-lights","title":"RGB lights","text":"<p>A light bar containing 4 RGB lights for using with multiple purposes. Note: some features must be enabled in Board settings.</p> <p>Connection indication (Totem App):</p> <ul> <li>Running animation - no connection</li> <li>Steady color - connected to robot</li> </ul> <p>Appearance customization (Totem App):</p> <ul> <li>Change color - click Settings (when connected) and drag slider to configure robot RGB and connection color.</li> </ul> <p>Battery State Of Charge:</p> <p>Upon power on - battery charge level will be displayed by playing \"loading\" animation with specific color:  </p> <ul> <li> - battery is full</li> <li> - battery is medium</li> <li> - battery is low</li> <li> - battery is discharged (blink 3 times)</li> </ul> <p>In case battery is too low - board will power itself off, indicating by  LED.</p> <p>Programming:</p> <p>Use <code>RGB</code> API to change colors to your likeness or application.</p> <pre><code>RGB.color(Color::Green); // Color name\nRGB.color(0, 0, 125); // Color RGB value\n</code></pre>"},{"location":"roboboard-x3/#buttons","title":"Buttons","text":"<p>Contains two types of buttons:  </p> <ul> <li><code>RST</code> - Performs hardware processor reset. Used to restart currently running program.  </li> <li><code>BOOT</code> - Enter ESP32 serial bootloader (hold down and press <code>RESET</code>). Or user button.   <p>This is performed automatically during code upload, so pressing button is not required.   Can be used as programmable user button with <code>Button</code> API. Wired to GPIO pin <code>0</code>.   By default this button is inactive and left for user implementation.  </p> </li> </ul> Example: turn LED off on button press<pre><code>void setup() { }\n\nvoid loop() {\n  if (Button.wasPressed()) {\n    RGB.off();\n  }\n  else if (Button.wasReleased()) {\n    RGB.on();\n  }\n}\n</code></pre>"},{"location":"roboboard-x3/#gpio","title":"GPIO","text":"<p>Board contains in total 7 programmable GPIO pins:</p> <ul> <li>IO26 - trough hole pin (requires soldering)</li> <li>IO32, IO33 - left (yellow) connector and back side of the board</li> <li>SIGA, SIGB, SIGC, SIGD - servo control pins (S) (when motor is not used)</li> </ul> <p>Yellow connector has multiple uses:</p> <ul> <li>Connect I2C modules (Qwiic). Mapped to Arduino <code>Wire1</code> object.</li> <li>Connect jumper cable wire to access <code>3V3</code>, <code>GND</code>, <code>IO32</code>, <code>IO33</code> pins.</li> </ul> <p>3V3 is powered by second LDO converter and can be switched on/off with <code>Board.setEnable3V3()</code>. Read Power circuit section for more details. </p> <p>For more information read GPIO / Qwiic section.</p> <pre><code>void setup() {\n  pinMode(IO32, OUTPUT); // Configure pin to output\n  pinMode(IO33, INPUT); // Configure pin to input\n  digitalWrite(IO32, HIGH); // Set pin state\n  int state = digitalRead(IO33); // Read pin state\n}\nvoid loop() { }\n</code></pre>"},{"location":"roboboard-x3/#motor-drivers","title":"Motor drivers","text":"<p>Integrated drivers allows to connect motors directly to the board, eliminating the need for an external modules. All control functions are built into RoboBoard API <code>DC</code>, <code>Servo</code> and includes some more advanced features:</p> <ul> <li><code>DC</code> - control % of power, electric braking, audible tone generation, acceleration and deceleration control, power limiter, decay mode, configurable frequency, spin direction invert.</li> <li><code>Servo</code> - position, angle, pulse control, timed sequences, configurable pulse range, configurable period, trimming, spin direction invert.</li> </ul>"},{"location":"roboboard-x3/#servo-motor-ports","title":"Servo motor ports","text":"<p>Servo wire colors:  \u2022 Orange = Signal (PWM) \u2022 Red = VCC \u2022 Brown = GND </p> <p>Connector: 0.1\u2033 (2.54 mm) male pin header  </p> <p>Individual (SIG, VCC, GND pin) headers for connecting standard (3 wire) servo motors and other electronics. Ports are marked with letters A, B, C, D for controlling up to 4 motors. VCC pin is connected to the battery and voltage is dependent on State Of Charge (2.8-4.2V).</p> <p>By default, API is configured for 180 degree servo motors, with pulse duration between 500\u03bcs-2500\u03bcs and period of 20ms (50Hz). These parameters can be customized.</p> <p>For more information read <code>Servo</code> section.</p>"},{"location":"roboboard-x3/#dc-motor-ports","title":"DC motor ports","text":"<p>Connector: JST-PH 2-pin  </p> <p>Connectors for 3-6V brushed DC motors. Ports are marked with letters A, B, C, D for controlling up to 4 motors. Power comes straight from the battery (trough H-bridge motor driver) and peak voltage is dependent on State Of Charge (2.8-4.2V). Motor power is controller using 20kHz PWM signal. This parameter can be customized.</p> <p>For more information read <code>DC</code> section.</p> <p>Note: motor wire colors (red, black) does not indicate polarity (+, -). Swapping wires only changes spin direction.</p>"},{"location":"roboboard-x3/#power-circuit","title":"Power circuit","text":"<p>Board contains built-in electronics for power distribution and control. It takes care of battery charging and provides power for all the components:</p> <ul> <li><code>BATT</code> (2 Amps) - used by <code>DC motor ports</code>, <code>Servo motor VCC</code>. Vary between 2.8-5 V</li> <li><code>3.3V main</code> (0.8 Amp) - used by <code>ESP32</code>, <code>IMU</code>, <code>RGB lights</code></li> <li><code>3.3V periph</code> (0.8 Amp) - used by <code>GPIO 3V3</code>, <code>Qwiic port</code></li> </ul> <p>Board contains separate 3.3V LDO voltage regulators for ESP32 and other peripherals. <code>3.3V periph</code> one can be turned on/off with function <code>Board.setEnable3V3()</code> for power saving applications, conveniently disabling all attached Qwiic modules.</p>"},{"location":"roboboard-x3/#charging","title":"Charging","text":"<p>Battery charging circuit activates once USB-C cable is plugged in and continues until battery is full. It even works if power switch is set to OFF position. Any USB power source (computer, phone charger) can be used, providing 0.5A or more current.  </p> <p>If charging mode <code>Board.setChargingMode(true)</code> is enabled - processor enters shutdown mode once USB-C cable is plugged in. It also displays charging process by RGB indication:</p> <p></p> <ol> <li>Plug-in USB-C cable \u2460</li> <li> will blink while charging \u2461</li> <li> will light up when finished \u2462</li> </ol> <p>Charging process is stopped once battery is full and does not overcharge it.</p>"},{"location":"roboboard-x3/#usb-c-input","title":"USB-C input","text":"<p>RoboBoard X3 USB-C 5V input is used for multiple purposes once it's plugged in:</p> <ul> <li>Board will power on, ignoring position of power switch.</li> <li>Battery connected to Battery input will start charging (until it's full).</li> <li>PC discovers a serial port device, used for Serial Monitor and Arduino firmware upload.</li> <li><code>BATT</code> power rail overrides battery and becomes 5V (sourced from USB). DC motor and Servo VCC pins will output 5V.</li> </ul> <p>Keep in mind that PC USB port provides only 0.5 Amps and it's not enough for powering motors. For powering board from USB-C only (without a battery) - use devices that provides more than 0.5A current (e.g. power banks and phone chargers).  </p> <p>Serial converter: CH340C Connector: USB-C (Type-C)  </p>"},{"location":"roboboard-x3/#battery-input","title":"Battery input","text":"<p>Battery input for 1S rechargeable Lithium battery to supply power to the board. When connected it powers <code>BATT</code> rail. Voltage may vary between 2.8-4.2 V, depending on battery State Of Charge.</p> <p>Input voltage: 2.8-4.2 Volts Battery type: 1S 3.7V Lithium (rechargeable) or 18650 cell. Under-voltage protection required Connector: JST-PH 2-pin  </p> <p> Important notices:</p> <ul> <li>Does not feature low voltage protection! Battery must contain its own under voltage protection circuit.  </li> <li>Does not feature reverse voltage protection! Make sure polarity ( + - ) is correct before plugging battery in.  </li> <li>Do not connect other power sources (or different battery types)! May be damaged when USB-C cable is plugged in and charging starts.  </li> </ul> <p>Recommended to use only supplied battery: 1S LiPo, 3.7V, 250mAh battery Or use USB-C port for power if battery is not required.</p>"},{"location":"roboboard-x3/#onoff-switch","title":"On/Off switch","text":"<p>Used to turn X3 board power on/off without a need to disconnect the battery. Push switch \u2460 up or down to toggle power. Upon power on - battery charge level (if enabled) will be displayed. \"Loading\" animation will be played with specific color \u2461:  </p> <ul> <li> - battery is full</li> <li> - battery is medium</li> <li> - battery is low</li> <li> - battery is discharged (blink 3 times)</li> </ul> <p>Setting to OFF position shuts down all power rails (<code>BATT</code>, <code>3.3V main</code>, <code>3.3V periph</code>). This switch is overridden (always ON) if USB-C cable is plugged in. </p>"},{"location":"roboboard-x3/#schematics","title":"Schematics","text":"<p>Mechanical drawing (dimensions):</p> <p></p> <p>RoboBoard X3 v3.0 drawing.png RoboBoard X3 v3.1 drawing.png</p> <p>Schematic:</p> <p>RoboBoard X3 v3.0 schematic.pdf RoboBoard X3 v3.1 schematic.pdf</p>"},{"location":"roboboard-x3/#revision-changelog","title":"Revision changelog","text":"<p>We are always looking to improve our products. Any physical change (components, layout) is indicated with board revision number (printed on top). Each revision may have different features or functionality.</p>"},{"location":"roboboard-x3/#v31","title":"v3.1","text":"<p>Manufactured from 2024-Q1.</p> <ul> <li>Added 2 servo ports (total 4)</li> <li>Added additional JST-SH connector in place of GPIO</li> <li>Added stronger LDO regulators (0.8 Amp)</li> <li>Added RGB strip extension pins</li> <li>Added battery current measurement</li> <li>Qwiic won't be powered in charging mode</li> <li>Easier to press buttons</li> <li>RGB connected to MCU LDO (always powered)</li> <li>Silkscreen changes</li> </ul>"},{"location":"roboboard-x3/#v30","title":"v3.0","text":"<p>Manufactured from 2023-Q2. Replaces discontinued Mini Control Board.</p> <ul> <li>Renamed to \"RoboBoard X3\"</li> <li>Added Arduino programming</li> <li>Added IMU sensor</li> <li>Added Qwiic port</li> <li>Added Reset and Boot buttons</li> <li>Added GPIO pins</li> <li>Backwards compatible with Mini Control Board</li> </ul> <p>For previous revisions check Mini Control Board revisions.</p>"},{"location":"roboboard-x4/","title":"RoboBoard X4","text":"<p>Motor driver firmware</p> <p>New driver firmware v1.60 is available. See Release notes and Driver update</p> <p>A more powerful programmable controller, designed for medium to larger sized robots with high voltage motors and additional expansion options. This compact package features components that are essential for robotic applications: battery input, charging, motor drivers, modules and sensors extensions, orientation sensor, powerful processor, wireless connectivity, software support and more. To start programming install Arduino and check RoboBoard API section.</p> <p>Find at:  Totemmaker.net store \u2192 RoboBoard X4 </p>  Arduino setup  Smartphone control  Arduino examples"},{"location":"roboboard-x4/#details","title":"Details","text":"Click orange box to jump to explanation <p>Processor: \u2022 ESP32 module (ESP32-D0WD) \u2022 Dual-core 240Mhz (Xtensa LX6) \u2022 320KB SRAM, 8MB flash \u2022 Bluetooth (classic and BLE) \u2022 Wi-Fi  </p> <p>Board features: \u2022 3 Servo motor ports (5 Volt) \u2022 4 DC motor ports (11.1 Volt) \u2022 4 GPIO pins \u2022 4 RGB lights \u2022 IMU sensor (accel and gyro) \u2022 Reset, User buttons \u2022 Status LED \u2022 On/Off switch \u2022 DC power input \u2022 Battery input, integrated charger \u2022 Qwiic port (STEMMA QT compatible) \u2022 TBUS (CAN bus) \u2022 USB (data only, no power) </p> <p>Power: \u2022 DC adapter: 30W, 15V, 2A \u2022 Battery: 3S Li-Ion 11.1V 2200mAh  </p> <p>Dimensions: \u2022 70 x 50 x 14 mm (L x W x H) </p>"},{"location":"roboboard-x4/#esp32","title":"ESP32","text":"<p>RoboBoard is powered by ESP32 - a capable SoC with rich peripherals and wireless connectivity. This combinations makes it perfect for robotic applications where motor driving and wireless control is required.</p> <p>For a past few years ESP32 is one of the most popular microcontroller among maker community. While its hardware capabilities are no doubt it also comes with vast software support, maintained officially by Espressif company and a help from community. This led to well established Arduino support for ESP32, powering many projects all over the world. Our Arduino support for RoboBoard is based on official core for maintaining compatibility with libraries and examples with addition to well integrated RoboBoard features.</p> <p>For more ESP32 specific details read ESP32 section.</p>"},{"location":"roboboard-x4/#board-features","title":"Board features","text":""},{"location":"roboboard-x4/#qwiic-port","title":"Qwiic port","text":"<p>Wires: \u2022 Black = GND \u2022 Red = 3.3V \u2022 Blue = SDA \u2022 Yellow = SCL </p> <p>Cable: standard \"Qwiic cable\". Can be found in local electronics store. Connector: SM04B-SRSS-TB 4-pin  </p> <p>A connection system to attach third-party I2C modules. This allows to choose from many available sensors and other interface devices. Small and sturdy connector eliminates need for soldering and enables plug-and-play style modular systems. Each module comes with its own Arduino library (supplied by manufacturer).</p> <p>This port is compatible with SparkFun Qwiic and Adafruit STEMMA QT modules. For using Qwiic modules with RoboBoard read GPIO / Qwiic section.  </p>"},{"location":"roboboard-x4/#totembus","title":"TBUS (CAN bus)","text":"<p>Wires: CAN-H, CAN-L, GND, <code>5V</code> (out), <code>BATT</code> (~12V), N.C. (pinout)  Cable:  Totemmaker.net store \u2192 TOTEMBUS CABLE Connector: Micro-MaTch 6-pin  </p> <p>TBUS (TotemBUS) connectors with dual purpose: Plug into CAN bus networks or attach X4 extension modules. Both are interconnected and used for daisy-chaining.</p> <p>For more information read CAN section.</p> <pre><code>void setup() {\n  // Start CAN peripheral at 500kbps\n  CAN.begin(500);\n}\nvoid loop() {\n  // Wait for CAN packet receive. 300ms timeout\n  if (CAN.readPacketWait(300)) {\n    // Get received packet\n    auto packet = CAN.getPacket();\n    // packet.id, packet.data, packet.len, packet.ext, packet.rtr\n  }\n  // Send CAN packets\n  uint8_t data[8] = {1,2,3,4,5,6,7,8};\n  CAN.writePacketExt(0x112233, data, 8); // Extended\n  CAN.writePacketStd(0x1AB, data, 8);    // Standard\n}\n</code></pre>"},{"location":"roboboard-x4/#usb-port","title":"USB port","text":"<p>USB connector is present for Serial Monitor and Arduino firmware upload. Board cannot be powered from USB alone! It requires either Power or Battery input.  </p> <p>Serial converter: CP2102N Connector: miniUSB  </p>"},{"location":"roboboard-x4/#imu-sensor","title":"IMU sensor","text":"<p>6DOF IMU sensor (3-axis accelerometer and 3-axis gyroscope) allows to detect board movement and orientation. Very useful in many robotic projects. Chip is connected to I2C line (same as Qwiic connector) and can be accessed trough API functions <code>IMU</code>.</p> <pre><code>#include &lt;Wire.h&gt;\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n}\nvoid loop() {\n  auto result = IMU.read(); // Read sensor measurements\n  Serial.println(result.getX_G()); // Read unit from \"result\"\n  delay(100); // Wait 100ms for next read\n}\n</code></pre>"},{"location":"roboboard-x4/#status-led","title":"Status LED","text":"<p>Red LED next to user button for indicating board state:  Short rapid blink - board started.  Blink 3 times - battery is depleted.  Blinking constantly - driver initialization error (consult forum).  On - running.  </p> <p>This LED can be controlled from Arduino code:</p> <p><pre><code>LED.on(); // Turn LED On\nLED.off(); // Turn LED Off\n</code></pre> For more details read <code>LED</code> section.</p>"},{"location":"roboboard-x4/#rgb-lights","title":"RGB lights","text":"<p>Back side of the board contains 4 RGB lights for using with multiple purposes. Note: some features must be enabled in Board settings.</p> <p>Connection indication (Totem App):</p> <ul> <li>Running animation - no connection</li> <li>Steady color - connected to robot</li> </ul> <p>Appearance customization (Totem App):</p> <ul> <li>Change color - click Settings (when connected) and drag slider to configure robot RGB and connection color.</li> </ul> <p>Battery State Of Charge:</p> <p>Upon power on - battery charge level will be displayed by playing \"loading\" animation with specific color:  </p> <ul> <li> - battery is full</li> <li> - battery is medium</li> <li> - battery is low</li> <li> - battery is discharged (blink 3 times)</li> </ul> <p>In case battery is too low - board will power itself off, indicating by  Status LED.</p> <p>Programming:</p> <p>Use <code>RGB</code> API to change colors to your likeness or application.</p> <pre><code>RGB.color(Color::Green); // Color name\nRGB.color(0, 0, 125); // RGB value\n</code></pre>"},{"location":"roboboard-x4/#buttons","title":"Buttons","text":"<p>Contains two types of buttons:  </p> <ul> <li><code>RESET</code> - Performs hardware processor reset. Used to restart currently running program.  </li> <li><code>BUTTON</code> - Programmable user button. Can be used with <code>Button</code> API.  </li> </ul> <p>By default <code>BUTTON</code> is inactive and left for user implementation.  </p> Example: Turn LED off on button press<pre><code>void setup() { }\n\nvoid loop() {\n  if (Button.wasPressed()) {\n    LED.off();\n  }\n  else if (Button.wasReleased()) {\n    LED.on();\n  }\n}\n</code></pre>"},{"location":"roboboard-x4/#gpio-pins","title":"GPIO pins","text":"<p>Pins for external IO and communications (UART, I2C, SPI, ...):</p> <ul> <li>VCC - 3.3 Volt output pin.</li> <li>GPIOA - GPIO pin <code>14</code></li> <li>GPIOB - GPIO pin <code>23</code></li> <li>GPIOC - GPIO pin <code>25</code></li> <li>GPIOD - GPIO pin <code>26</code></li> <li>GND - Ground pin</li> </ul> <p>Connector: 0.1\u2033 (2.54 mm) female pin header  </p> <pre><code>void setup() {\n  pinMode(GPIOA, OUTPUT); // Configure pin to output\n  pinMode(GPIOB, INPUT); // Configure pin to input\n  digitalWrite(GPIOA, HIGH); // Set pin state\n  int state = digitalRead(GPIOB); // Read pin state\n}\nvoid loop() { }\n</code></pre> <p>For more information read GPIO / Qwiic section.</p>"},{"location":"roboboard-x4/#motor-drivers","title":"Motor drivers","text":"<p>Integrated drivers allows to connect motors directly to the board, eliminating the need for an external modules. All control functions are built into RoboBoard API <code>DC</code>, <code>Servo</code> and includes some more advanced features:</p> <ul> <li><code>DC</code> - control % of power, electric braking, audible tone generation, acceleration and deceleration control, power limiter, configurable frequency, spin direction invert.</li> <li><code>Servo</code> - position, angle, pulse control, speed control, timed sequences, configurable pulse range, configurable period, trimming, spin direction invert.</li> </ul>"},{"location":"roboboard-x4/#servo-motor-ports","title":"Servo motor ports","text":"<p>Servo wire colors:  \u2022 (-) Brown = GND \u2022 (+) Red = VCC \u2022 (S) Orange = Signal (PWM)  </p> <p>Connector: 0.1\u2033 (2.54 mm) male pin header  </p> <p>Individual channels for connecting standard (3 wire) servo motors and other electronics. Pins are marked with letters A, B, C for controlling up to 3 motors with regulated 5 Volt output.</p> <p>By default, API is configured for 180 degree servo motors, with pulse duration between 500\u03bcs-2500\u03bcs and period of 20ms (50Hz). These parameters can be customized.</p> <p>For more information read <code>Servo</code> section.</p>"},{"location":"roboboard-x4/#dc-motor-ports","title":"DC motor ports","text":"<p>Connector: JST-PH 2-pin  </p> <p>Connectors for 12V brushed DC motors. Ports are marked with letters A, B, C, D for controlling up to 4 motors. Power comes straight from the battery (trough H-bridge motor driver) and peak voltage is dependent on State Of Charge (8.4-12.6V). Motor power is controller using 20kHz PWM signal (driver v1.60 required). This parameter can be customized.</p> <p>Board contains dual DRV8847S driver chips for total control of 4 individual motor ports. Each driver is rated for 2 Amp peak and grouped into AB and CD ports. In case motor consumes too much current - a thermal protection will trigger when IC heats up over 150\u00b0C. After cool down - it turns back on. This may cause motor power off once a second.  </p> <p>Motors shipped with Totem kits consumes 1.5A at stall and does not trigger thermal protection (only case if motor is stalled for a long time).  </p> <p>For more information read <code>DC</code> section.</p> <p>Note: motor wire colors (red, black) does not indicate polarity (+, -). Swapping wires only changes spin direction.</p>"},{"location":"roboboard-x4/#power-circuit","title":"Power circuit","text":"<p>Board contains built-in electronics for power distribution and control. It takes care of battery charging and provides power for all the components:</p> <ul> <li><code>BATT</code> (6 Amps) - used by <code>DC motor ports</code>, <code>CAN bus BATT pin</code>. Vary between 8.4-15 V</li> <li><code>5V</code> (6 Amps) - used by <code>Servo motor +</code>, <code>RGB lights</code>, <code>CAN bus 5V pin</code></li> <li><code>3.3V</code> (2 Amps) - used by <code>ESP32</code>, <code>co-processor</code>, <code>IMU</code>, <code>GPIO VCC</code>, <code>Qwiic port</code></li> </ul> <p>USB port is for data only and does not power <code>5V</code> or <code>3.3V</code> rails. Either battery or DC adapter is required to program and power up the board.</p>"},{"location":"roboboard-x4/#charging","title":"Charging","text":"<p>Battery charging circuit activates once both battery and DC adapter are plugged in and continues until battery is full. Charging process indicated by status LED  (near to DC jack):</p> <p> Blinking - battery not detected .  On - battery is charging .  Off - battery is charged . Note: Sometimes LED can start blinking when battery is charged. </p>"},{"location":"roboboard-x4/#power-input","title":"Power input","text":"<p>DC barrel-jack input to supply power for board and and battery charging. When connected it starts charging the battery (if not full) and powers <code>BATT</code> rail (overrides battery). In this case <code>BATT</code> will become 15V and DC motors will spin a little faster. If board starts to consume more than 2 Amps, missing energy will be topped off from the battery.</p> <p>Input voltage: 15 Volts Connector: barrel jack 5.5/2.0mm center-positive  </p> <p>Recommended to use only supplied DC power adapter: 30W, 15V, 2A power adapter </p>"},{"location":"roboboard-x4/#battery-input","title":"Battery input","text":"<p>Battery input for board power and charging. When connected it powers <code>BATT</code> rail. Voltage may vary between 8.4-12.6 V, depending on battery State Of Charge.</p> <p>Input voltage: 8.4-12.6 Volts Battery type: 3S 11.1V Lithium (rechargeable). Under-voltage protection required Connector: JST-VH 2-pin  </p> <p> Important notices:</p> <ul> <li>Does not feature low voltage protection! Battery must contain its own under voltage protection circuit.  </li> <li>Does not feature reverse voltage protection! Make sure polarity ( + - ) is correct before plugging battery in.  </li> <li>Do not connect other power sources (or different battery types)! May be damaged when DC power jack is plugged in and charging starts.  </li> </ul> <p>Recommended to use only supplied battery: 3S Li-Ion, 11.1V, 2200mAh battery </p>"},{"location":"roboboard-x4/#onoff-switch","title":"On/Off switch","text":"<p>Used to turn X4 board power on/off without disconnecting DC jack or battery. Upon power on - battery charge level (if enabled) will be displayed. \"Loading\" animation will be played with specific color:  </p> <ul> <li> - battery is full</li> <li> - battery is medium</li> <li> - battery is low</li> <li> - battery is discharged (blink 3 times)</li> </ul> <p>Setting to OFF position shuts down all power rails (<code>BATT</code>, <code>5V</code>, <code>3.3V</code>). Battery can still be charged while switch is set to OFF position.</p>"},{"location":"roboboard-x4/#driver-update","title":"Driver update","text":"<p>RoboBoard contains additional processor for low-level control operations (motor, board, RGB). It works by communicating over UART and relieving some strain from ESP32. This processor is called \"motor driver\" and runs its own firmware.</p> <p>View installed version: Run this Arduino code and open Serial Monitor. Latest version is mentioned in Releases. <pre><code>void setup() {\n    Serial.begin(115200); // Setting baud to 115200\n}\nvoid loop() {\n  Serial.print(\"Driver: \");\n  Serial.println(Board.getDriverVersionStr());\n  delay(500);\n}\n</code></pre></p> <p>Update to latest firmware:</p> <ol> <li>Use Arduino IDE and install latest Totem Boards.  </li> <li>Power on RoboBoard X4 and connect to PC.</li> <li>Select <code>Tools</code> \u2192 <code>Board</code> \u2192 <code>Totem Boards</code> \u2192 <code>RoboBoard X4</code>.   Select <code>Tools</code> \u2192 <code>Port</code>.   Select <code>Tools</code> \u2192 <code>Programmer</code> \u2192 <code>Esptool</code>.  </li> <li>Click <code>Tools</code> \u2192 <code>Burn bootloader</code>.</li> <li>Update procedure will start. Wait for (red) LED to light up and RGB lights go green.</li> </ol> <p>Troubleshooting:</p> <p>If (green) RGB is blinking - firmware is already flashed. If (red) LED starts blinking - there was update error. Try press RESET button and wait. If (red) LED still blinks, follow these steps:</p> <ol> <li>Open <code>Tools</code> \u2192 <code>Serial Monitor</code>.</li> <li>Select <code>115200 baud</code>.</li> <li>Wait for Serial output. Error will be displayed. Contact support for further help.</li> </ol>"},{"location":"roboboard-x4/#schematics","title":"Schematics","text":"<p>Mechanical drawing (dimensions):</p> <p></p>"},{"location":"roboboard-x4/#revision-changelog","title":"Revision changelog","text":"<p>We are always looking to improve our products. Any physical change (components, layout) is indicated with board revision number (printed on top). Each revision may have different features or functionality.</p>"},{"location":"roboboard-x4/#v11","title":"v1.1","text":"<ul> <li>Connected GPIO pins to ESP32</li> <li>Switched to addressable RGB lights</li> <li>Added Reset button</li> <li>Added Qwiic port</li> <li>Changed IMU to ICM-20689</li> </ul>"},{"location":"roboboard-x4/#v10","title":"v1.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"setup/","title":"Arduino development","text":"<p>Totem RoboBoard can be programmed using Arduino development environment. Based on C++ language with hundreds of libraries available - it makes a good candidate to enter world of embedded systems programming. A few different applications are available. For beginners - Arduino IDE 2.3 is recommended.</p> <p></p> <ul> <li> Arduino IDE 2.3 <p>Latest official Arduino</p> <p>Modern UI, Autocomplete, Syntax highlight, Serial Monitor, Serial Plotter</p> </li> <li> Arduino IDE 1.8 <p>Legacy official Arduino</p> <p>Classic UI, Serial Monitor, Serial Plotter </p> </li> </ul> <ul> <li> Arduino Cloud <p>Arduino Web IDE</p> <p>Compile and upload code using web Browser</p> </li> <li> PIO Arduino <p>Visual Studio Code based</p> <p>Modern editor with advanced features</p> </li> </ul> <p></p>"},{"location":"setup/#esp-idf-development","title":"ESP-IDF development","text":"<p>Program RoboBoard using official Espressif SDK framework in C, C++ languages. Contains only low-level drivers, allowing to develop custom implementations.</p> <p></p> <ul> <li>  Command line <p>Official Espressif SDK</p> <p>C, C++ language, low-level drivers, full customization and configuration options</p> </li> </ul>"},{"location":"setup/arduino-cloud/","title":"Setup Arduino Cloud","text":""},{"location":"setup/arduino-cloud/#step-1-login-to-arduino-cloud","title":"Step 1. Login to Arduino Cloud","text":"<p> Open Arduino Cloud</p> <p>Note: install \"Arduino Agent\" if requested.</p>"},{"location":"setup/arduino-cloud/#step-2-upload-code","title":"Step 2. Upload code","text":"<ol> <li>Connect RoboBoard to PC over USB</li> <li>Click CREATE NEW -&gt; Sketch</li> <li>\"Unknown Device Found\" window pops up. Search for <code>ESP32 Dev Module</code>.</li> <li>Paste code inside editor and click upload button. <pre><code>#include &lt;RoboBoard.h&gt;\n\nvoid setup() {\n  Board.begin();\n}\n\nvoid loop() {\n  RGB.color(Color::random());\n  delay(500);\n}\n</code></pre> Note: For MacOS change Upload speed to 460800 if code upload fails. <code>RoboBoard.h</code> is provided by TotemRoboboard library.</li> </ol> Board parameters (optional) <p>Click settings icon to change parameters specific for RoboBoard.  </p> <ul> <li>Upload speed - 921600 (for MacOS select 460800!)</li> <li>CPU Frequency - 240MHz (WiFi/BT)</li> <li>Flash Frequency - 80Mhz</li> <li>Flash Mode - QIO</li> <li>Flash Size - 8MB (64Mb)</li> <li>Partition Scheme - 8M with spiffs (3MB APP/1.5MB SPIFFS)</li> <li>Core Debug Level - None</li> <li>PSRAM - Disabled</li> <li>Arduino Runs On - Core 1</li> <li>Events Run On - Core 1</li> <li>Erase All Flash Before Sketch Upload - Disabled</li> <li>JTAG Adapter - Disabled</li> </ul>"},{"location":"setup/arduino-cloud/#step-3-load-examples","title":"Step 3. Load examples","text":"<ol> <li>Click examples icon. Select tab \"From Libraries\". Search for <code>totem</code>.</li> <li>New window will open with example code. Press SELECT DEVICE and look for <code>ESP32 Dev Module</code> to upload the code.</li> </ol>"},{"location":"setup/arduino-ide-2/","title":"Setup Arduino IDE 2.3","text":"<p> Arduino IDE stands out with its simple design, allowing to write a code, compile a project and upload it to the RoboBoard. This is one of the reasons why it's so popular among beginners. Aside from basic functionality, it has thousands of third-party libraries and code examples to create a project even faster.  </p>"},{"location":"setup/arduino-ide-2/#step-1-download-arduino-ide","title":"Step 1. Download Arduino IDE","text":"<p>Go to Arduino website to download application for your operating system. Install guide: Windows / MacOS / Linux</p> <p> Download Arduino</p>"},{"location":"setup/arduino-ide-2/#step-2-install-totem-boards","title":"Step 2. Install Totem Boards","text":"<p> Install <code>Totem Boards</code> extension to add support for Totem RoboBoard.  </p> <ol> <li>In Arduino IDE select <code>File</code> \u2192 <code>Preferences</code>.  </li> <li>Locate <code>Additional Boards Manager URLs</code> and paste in: <pre><code>https://totemmaker.github.io/TotemArduinoBoards/package_totemmaker_index.json\n</code></pre> If you have multiple URLs, click a button next to input field and add this link to the bottom.</li> <li>Click OK.  </li> <li>Open Boards Manager in side panel and type <code>totem</code> in search field.  </li> <li>Click Install on <code>Totem Boards</code> and wait for it to complete. It can take a few minutes.  </li> </ol> <p>Full tutorial how to use board manager: Using the Board Manager.</p> <p>RoboBoard X4 (only)</p> <p>Update motor driver firmware to latest version. See driver update guide.</p>"},{"location":"setup/arduino-ide-2/#step-3-compile-and-upload-code","title":"Step 3. Compile and upload code","text":"<p> Load example code and upload it to RoboBoard.  </p> <ol> <li>Connect RoboBoard to PC over USB cable and power it on.  </li> <li>Click on boards field and select <code>Select other board and port...</code> </li> <li>Inside new dialog search for <code>roboboard</code> and select <code>RoboBoard X4</code> (or <code>RoboBoard X3</code>). Also select USB port board is connected to and click OK </li> <li>Select <code>File</code> \u2192 <code>Examples</code> \u2192 <code>&gt; RoboBoard</code> \u2192 <code>RGB</code> \u2192 <code>ColorRun</code>.  </li> <li>Select <code>Tools</code> \u2192 <code>Port</code> and click on the port displayed there. If <code>Port</code> is not available - check if RoboBoard is on and plugged to PC with USB cable. If there are multiple ports, disconnect USB cable and check which one is gone. Reconnect and select it. </li> <li>Select <code>Sketch</code> \u2192 <code>Upload</code> and wait till it completes (can take a few minutes first time). Note: in case upload fails - try selecting lower speed in <code>Tools</code> \u2192 <code>Upload speed</code>. </li> <li>RoboBoard RGB will start to blink in different colors. There is an example for each functionality, including a simple description.  </li> </ol> <p></p> <p>Full tutorial how to compile and upload code: Upload a sketch. In case of RoboBoard X4 - make sure the battery or DC jack is connected and power switch is turned on. It won't work from USB alone!.  </p>"},{"location":"setup/arduino-ide-2/#step-4-project-settings","title":"Step 4. Project settings","text":"<p>Menu option <code>Tools</code> contains Board settings that can change code build and upload parameters.</p> <ul> <li>Board - board type selection</li> <li>Upload speed - firmware upload speed. Use highest, unless upload errors occur</li> <li>Erase All Flash Before Sketch Upload - fully erase ESP32 flash before new firmware upload</li> <li>Remote Control - makes RoboBoard discoverable by Totem App when selected</li> <li>Board Status - enable RoboBoard status with RGB lights and beeping</li> <li>Charging Mode - enable RoboBoard X3 charging mode</li> <li>Totem Prefix - append \"totem::\" prefix to every RoboBoard function Totem Prefix</li> <li>Port - USB port name RoboBoard is connected to (required for Serial Monitor and upload)</li> </ul>"},{"location":"setup/arduino-ide-2/#step-5-using-arduino-ide","title":"Step 5. Using Arduino IDE","text":"<p>For more information about getting started with Arduino, read following topics:  </p> <p>User interface:</p> <ul> <li>Getting Started with Arduino IDE - walk around Arduino IDE UI</li> <li>Uploading sketch with the Arduino IDE - upload compiled code to RoboBoard</li> <li>Installing libraries - install third-party libraries</li> <li>Autocomplete feature - displays code suggestions while typing</li> </ul> <p>Monitor:</p> <ul> <li>Using Serial Monitor - view <code>Serial.print()</code> output</li> <li>Using Serial Plotter - view plotted graphs</li> </ul> <p>Code documentation:</p> <ul> <li>RoboBoard board settings - RoboBoard settings and default firmware</li> <li>RoboBoard API documentation - RoboBoard functions documentation</li> <li>Arduino code reference - Arduino functions documentation</li> </ul> <p>Code examples:</p> <ul> <li>Connect GPIO and Qwiic - interface GPIO pins and Qwiic modules</li> <li>Interface with Totem App - read commands from Totem App</li> <li>RoboBoard code examples - RoboBoard specific code examples</li> <li>ESP32 code examples - ESP32 processor specific code examples</li> <li>Arduino examples / projects - general Arduino example projects</li> </ul> <p>Question</p> <p>Visit  Support page to find more information or help from our community.</p>"},{"location":"setup/arduino-ide/","title":"Setup Arduino IDE 1.8","text":"<p> Arduino IDE stands out with its simple design, allowing to write a code, compile a project and upload it to the RoboBoard. This is one of the reasons why it's so popular among beginners. Aside from basic functionality, it has thousands of third-party libraries and code examples to create a project even faster.  </p>"},{"location":"setup/arduino-ide/#step-1-download-arduino-ide","title":"Step 1. Download Arduino IDE","text":"<p>Go to Arduino website to download application for your operating system. For this tutorial select version 1.8.x (not 2.2). Install guide: Windows | macOS | Linux </p> <p> Download Arduino</p>"},{"location":"setup/arduino-ide/#step-2-install-totem-boards","title":"Step 2. Install Totem Boards","text":"<p> Install <code>Totem Boards</code> extension to add support for Totem RoboBoard.  </p> <ol> <li>In Arduino IDE select <code>File</code> \u2192 <code>Preferences</code>.  </li> <li>Locate <code>Additional Boards Manager URLs</code> and paste in: <pre><code>https://totemmaker.github.io/TotemArduinoBoards/package_totemmaker_index.json\n</code></pre> If you have multiple URLs, click a button next to input field and add this link to the bottom.</li> <li>Click OK.  </li> <li>Select <code>Tools</code> \u2192 <code>Board</code> \u2192 <code>Boards Manager..</code> </li> <li>In search field type in <code>totem</code>.  </li> <li>Click Install and wait for it to complete. It can take a few minutes.  </li> <li>Close Boards Manager window.  </li> </ol> <p>RoboBoard X4 (only)</p> <p>Update motor driver firmware to latest version. See driver update guide.</p>"},{"location":"setup/arduino-ide/#step-3-compile-and-upload-code","title":"Step 3. Compile and upload code","text":"<p> Load example code and upload it to RoboBoard.  </p> <ol> <li>Select <code>Tools</code> \u2192 <code>Board</code> \u2192 <code>Totem Boards</code> \u2192 <code>RoboBoard X4</code> (or <code>RoboBoard X3</code>).  </li> <li>Select <code>File</code> \u2192 <code>Examples</code> \u2192 <code>&gt; RoboBoard</code> \u2192 <code>RGB</code> \u2192 <code>ColorRun</code>.  </li> <li>Connect RoboBoard to PC over USB cable and power it on.  </li> <li>Select <code>Tools</code> \u2192 <code>Port</code> and click on the port displayed there. If <code>Port</code> is not available - check if RoboBoard is on and plugged to PC with USB cable. If there are multiple ports, disconnect USB cable and check which one is gone. Reconnect and select it. </li> <li>Select <code>Sketch</code> \u2192 <code>Upload</code> and wait till it completes (can take a few minutes first time). Note: in case upload fails - try selecting lower speed in <code>Tools</code> \u2192 <code>Upload speed</code>. </li> <li>RGB lights will start to blink in different colors. There is an example for each functionality, including a simple description.  </li> </ol> <p></p> <p>For RoboBoard X4 make sure the battery or DC jack is connected and power switch is turned on. It won't work from USB alone! </p>"},{"location":"setup/arduino-ide/#step-4-project-settings","title":"Step 4. Project settings","text":"<p>Menu option <code>Tools</code> contains Board settings that can change code build and upload parameters.</p> <ul> <li>Board - board type selection</li> <li>Upload speed - firmware upload speed. Use highest, unless upload errors occur</li> <li>Erase All Flash Before Sketch Upload - fully erase ESP32 flash before new firmware upload</li> <li>Remote Control - makes RoboBoard discoverable by Totem App when selected</li> <li>Board Status - enable RoboBoard status with RGB lights and beeping</li> <li>Charging Mode - enable RoboBoard X3 charging mode</li> <li>Totem Prefix - append \"totem::\" prefix to every RoboBoard function Totem Prefix</li> <li>Port - USB port name RoboBoard is connected to (required for Serial Monitor and upload)</li> </ul>"},{"location":"setup/arduino-ide/#step-5-using-arduino-ide","title":"Step 5. Using Arduino IDE","text":"<p>For more information about getting started with Arduino, read following topics:  </p> <p>User interface:</p> <ul> <li>Getting Started with Arduino IDE - walk around Arduino IDE UI</li> <li>Installing libraries  - install third-party libraries</li> </ul> <p>Code documentation:</p> <ul> <li>RoboBoard board settings - RoboBoard settings and default firmware</li> <li>RoboBoard API documentation - RoboBoard functions documentation</li> <li>Arduino code reference - Arduino functions documentation</li> </ul> <p>Code examples:</p> <ul> <li>Connect GPIO and Qwiic - interface GPIO pins and Qwiic modules</li> <li>Interface with Totem App - read commands from Totem App</li> <li>RoboBoard code examples - RoboBoard specific code examples</li> <li>ESP32 code examples - ESP32 processor specific code examples</li> <li>Arduino examples / projects - general Arduino example projects</li> </ul> <p>Question</p> <p>Visit  Support page to find more information or help from our community.</p>"},{"location":"setup/esp-idf-cmd/","title":"Setup ESP-IDF","text":"<p>ESP-IDF is an official Espressif SDK for ESP32 development. It contains latest features and provides full access to chip functionality and configuration. Almost any ESP32 framework (like ESP32 Arduino) is based on ESP-IDF, which provides required low-level drivers. In combination, Totemmaker provides totem-bsp (Board Support Package) for RoboBoard development using ESP-IDF. It contains required drivers to control on board features (like motor drivers).</p>"},{"location":"setup/esp-idf-cmd/#step-1-setup-esp-idf","title":"Step 1. Setup ESP-IDF","text":"<p>Visit Getting Started to setup ESP-IDF toolchain.</p> Manual setup (click to expand) <p>Clone esp-idf project: <pre><code>mkdir ~/esp\ncd ~/esp\ngit clone --recursive https://github.com/espressif/esp-idf.git\ncd esp-idf\n</code></pre> Install required tools (<code>install.ps1</code> for PowerShell): <pre><code>./install.sh\n</code></pre> Load esp-idf environment (<code>export.ps1</code> for PowerShell): <pre><code>./export.sh\n</code></pre> Go to your project and run: <pre><code>idf.py build\n</code></pre></p>"},{"location":"setup/esp-idf-cmd/#step-2-create-a-project","title":"Step 2. Create a project","text":"<ol> <li>Create new ESP-IDF project or use command: <pre><code>idf.py create-project roboboard_project\n</code></pre></li> <li>Inside project create manifest file <code>main/idf_component.yml</code> or use command: <pre><code>idf.py create-manifest\n</code></pre></li> <li>Add <code>roboboard_x3</code> or <code>roboboard_x4</code> as dependency:  </li> </ol> RoboBoard X3RoboBoard X4 <pre><code>## IDF Component Manager Manifest File\ndependencies:\n  # Include roboboard_x3 component\n  roboboard_x3:\n    path: roboboard_x3\n    git: https://github.com/totemmaker/totem-bsp.git\n</code></pre> <pre><code>## IDF Component Manager Manifest File\ndependencies:\n  # Include roboboard_x4 component\n  roboboard_x4:\n    path: roboboard_x4\n    git: https://github.com/totemmaker/totem-bsp.git\n</code></pre> <p>RoboBoard X4</p> <p>Update motor driver firmware to latest version. See driver update guide.</p>"},{"location":"setup/esp-idf-cmd/#step-3-write-firmware","title":"Step 3. Write firmware","text":"<p>Include <code>totem-bsp.h</code> header and code into project <code>main/roboboard_project.c</code> file: <pre><code>#include \"bsp/totem-bsp.h\"\n\nvoid app_main(void)\n{\n    // Initialize board\n    bsp_board_init();\n    // Spin motor A at 100% power\n    bsp_dc_spin(BSP_PORT_A, 100);\n    // Spin servo A to 500us pulse\n    bsp_servo_spin(BSP_PORT_A, 500);\n    // RoboBoard X4 LED on\n    // bsp_board_set_led(1);\n    // bsp_rgb_color(BSP_PORT_ALL, 0xFF00FF00);\n}\n</code></pre></p>"},{"location":"setup/esp-idf-cmd/#step-4-build-project","title":"Step 4. Build project","text":"<p>Build project: <pre><code>idf.py build\n</code></pre></p> <p>Flash to board: <pre><code>idf.py flash monitor\n</code></pre></p>"},{"location":"setup/esp-idf-cmd/#step-5-using-esp-idf","title":"Step 5. Using ESP-IDF","text":"<p>For more information read following topics:  </p> <p>Code documentation:</p> <ul> <li>RoboBoard X3<ul> <li>roboboard_x3.h header file - RoboBoard X3 low-level API</li> <li>RoboBoard X3 imu.h - RoboBoard X3 accelerometer &amp; gyroscope API</li> <li>RoboBoard X3 rgb.h - RoboBoard X3 RGB lights API</li> </ul> </li> <li>RoboBoard X4<ul> <li>roboboard_x4.h header file - RoboBoard X4 low-level API</li> <li>RoboBoard X4 imu.h - RoboBoard X4 accelerometer &amp; gyroscope API</li> </ul> </li> <li>ESP-IDF API Reference - ESP32 API Reference</li> <li>ESP-IDF API Guides - More details about ESP-IDF</li> </ul> <p>Code examples:</p> <ul> <li>RoboBoard X3 - example of board feature control</li> <li>RoboBoard X4 - example of board feature control</li> </ul> <p>Question</p> <p>Visit  Support page to find more information or help from our community.</p>"},{"location":"setup/pioarduino/","title":"Setup PIO Arduino","text":"<p> An extension for Visual Studio Code editor to enable ESP32 boards programming. Supports multiple development boards, Arduino libraries, syntax highlighting, autocomplete, indexing, extensions and many more.</p>"},{"location":"setup/pioarduino/#step-1-install-pio-arduino","title":"Step 1. Install PIO Arduino","text":"<p> Download Visual Studio Code</p> <p>Click Extensions icon -&gt; search for <code>pioarduino</code> -&gt; click Install.</p> <p></p>"},{"location":"setup/pioarduino/#step-2-create-project","title":"Step 2. Create project","text":"<ol> <li>Open PIO Home by clicking   \u2192 <code>PIO Home</code> \u2192 <code>Open</code>.</li> <li>Click + New Project and select: Name: any project name. Board: select <code>Espressif ESP32 Dev Module</code>. Framework: select <code>Arduino</code>.  </li> <li>Click Finish and project will be created. Note: creating project first time can take a few minutes. Wait for it to finish.</li> <li>Open <code>platformio.ini</code> file and replace its content with: platformio.ini<pre><code>; Project Configuration File\n[env:roboboard]\nplatform = https://github.com/pioarduino/platform-espressif32/releases/download/stable/platform-espressif32.zip\nboard = esp32dev\nframework = arduino\n\nlib_deps = totemmaker/Totem Roboboard\n\nmonitor_dtr = 0\nmonitor_rts = 0\nmonitor_speed = 115200\nmonitor_filters = esp32_exception_decoder\n\nupload_speed = 1000000\n\nboard_build.f_flash = 80000000L\nboard_build.partitions = default_8MB.csv\nboard_upload.flash_size = 8MB\nboard_upload.maximum_size = 8388608\n</code></pre> Save file and wait for loading to finish.  </li> <li>Inside <code>src/main.cpp</code> write Arduino code ant build a project. <pre><code>#include &lt;Roboboard.h&gt; # Include RoboBoard control functions\n\nvoid setup() {\n  Board.begin(); // Initialize RoboBoard\n}\n\nvoid loop() {\n  RGB.color(Color::random()); // Set random color\n  delay(500); // Wait 500ms\n}\n</code></pre> Code and configuration is the same for RoboBoard X3 and RoboBoard X4. <code>RoboBoard.h</code> is provided by TotemRoboboard library.</li> </ol>"},{"location":"setup/pioarduino/#step-3-using-pio-arduino","title":"Step 3. Using PIO Arduino","text":"<p>Now you can build and upload the code to develop custom program for Totem RoboBoard. PIO Arduino is modified PlatformIO extension, enabling to use latest ESP32 Arduino Core. For more information read following topics:  </p> <p>User interface:</p> <ul> <li>Home - main page</li> <li>Quick Start guide - quick walk around UI</li> <li><code>platformio.ini</code> configuration - project configuration file</li> </ul> <p>Code documentation:</p> <ul> <li>RoboBoard board settings - RoboBoard settings and default firmware</li> <li>RoboBoard API documentation - RoboBoard functions documentation</li> <li>Arduino code reference - Arduino functions documentation</li> </ul> <p>Code examples:</p> <ul> <li>Connect GPIO and Qwiic - interface GPIO pins and Qwiic modules</li> <li>Interface with Totem App - read commands from Totem App</li> <li>RoboBoard code examples - RoboBoard specific code examples</li> <li>ESP32 code examples - ESP32 processor specific code examples</li> <li>Arduino examples / projects - general Arduino example projects</li> </ul> <p>Question</p> <p>Visit  Support page to find more information or help from our community.</p>"},{"location":"side-panels/","title":"Side panels","text":"<p>While Mini Lab will work on its own, but you can easily expand it with side panels. A side panel is a collection of basic most commonly used electronics blocks that can be used together with Mini Lab to even further extends it\u2019s abilities.</p> <p>Together with each side panel you\u2019ll get a quick start guide on how to work with each of the module in the side panel together with code samples. While modules in side panels are indented to be self-contained and not rely on one another, this gives you a chance to experiment on integrating parts of it to build a connected system - as an example you could program it to control the DC motor by rotating the potentiometer and displaying the current value on the OLED screen or making a sound-activated relay switch.</p> #1 I/O panel #2 Sensor panel #3 Audio panel"},{"location":"side-panels/#mounting","title":"Mounting","text":"<p>Panel mounting to side of Mini Lab frame.</p> <p></p>"},{"location":"side-panels/#stand-assembly","title":"Stand assembly","text":"<p>Side-Panel-Rack-Instructions.pdf</p>"},{"location":"side-panels/audio-panel/","title":"Audio panel #3","text":"Click image to jump to specific module <p>Contains: </p> <ul> <li>Audio amplifier + speaker</li> <li>LED VU-meter</li> <li>Function generator</li> <li>Filter bench (v3.7)</li> </ul> <p>Arduino examples:  Github |  TE-SP03-B </p> <p>This side panel is dedicated for experimenting with signal generation, allowing to visualize and hear its output. It can generate different types of waveforms with configurable frequency. Integrated loudspeaker can be used to listen how signal affects the sound or use external source to play music. Also contains VU meter to visualize signal level in LED bar.</p> <p>Note: previous side panel version (ver 3.5) contained XR2206 analog signal generator. In (ver 3.7) it has changed to digital AD9833 with addition of filter bench module. Image on the right is older side panel ver 3.5.</p>"},{"location":"side-panels/audio-panel/#power","title":"Power","text":"<p>On the top of the board there is (POWER IN) pin header to supply power to side panel components. Some of them requires certain voltage to operate, but otherwise they\u2019re fully isolated from one another, and can be used independently.</p> <p>Side panel requires power (3.3V, 5V, 12V) for certain modules to work. It does not have its own voltage regulator so typically, regulated voltage has to be sourced from TotemDuino or LabBoard. Recommended to plug in all 4 wires as some modules use different voltages. 12V input can accept different voltages. Typically it should be connected to VIN. </p> <p>Older side panel (ver 3.5) had voltage selector. This was removed in later version 3.7, as it can work with any voltage level.</p>"},{"location":"side-panels/audio-panel/#audio-amplifier-speaker","title":"Audio amplifier + speaker","text":"<p>Contains audio amplifier to boost signal strength from INPUT pin. Amplified signal is routed to OUTPUT pin. Additionally it can be played trough integrated loudspeaker. Select panel type matching yours:</p> Panel ver 3.5Panel ver 3.7 <p></p> <p>Control: </p> <ul> <li>Volume - control OUT signal volume (amplitude)</li> <li>JP: SP - connect OUT to speaker</li> </ul> <p>Pin header:</p> <ul> <li>Audio IN: pin 1 - source signal IN</li> <li>Audio IN: pin 2 - GND</li> <li>OUT: pin 1 - amplified signal OUT</li> <li>OUT: pin 2 - GND</li> <li>12V: pin 1, 2 - amplifier power IN</li> <li>Screw term. 1 - amplifier power IN (same as pin header)</li> <li>Screw term. 2 - GND</li> </ul> <p></p> <p>Control: </p> <ul> <li>Volume - control OUTPUT signal volume (amplitude)</li> <li>JP: SPEAKER - connect OUTPUT to speaker</li> </ul> <p>Pin header:</p> <ul> <li>INPUT: pin 1 - source signal IN</li> <li>INPUT: pin 2 - GND</li> <li>OUTPUT: pin 1 - amp. signal OUT</li> <li>OUTPUT: pin 2 - GND</li> <li>+12V: pin 1, 2 - amplifier power IN</li> </ul> <p>Power:</p> <ul> <li>Uses +12v pin header to power amplification circuit and loudspeaker. Usually should be connected to VIN pin. Voltage can be higher (e.g. 15V).</li> </ul> <p>This is an AB class discrete audio amplifier module, capable of up to 1W output RMS power. Input volume is adjusted with potentiometer.</p> <p>Inbuilt speaker is enabled by connecting SPEAKER ON/OFF jumper, amplified signal output can be connected with a OUTPUT female connector.</p> <p>You can use the function generator as a signal source (described below) by just connecting a jumper cable between amplifier input and generator output. Another possible input source is using Totem side panel #1 microphone module.</p> Schematic Experiment Play generated signal trough loudspeaker."},{"location":"side-panels/audio-panel/#vu-meter","title":"VU Meter","text":"<p>LED bar to visualize input signal Volumetric Unit (VU).</p> <p></p> <p>Control: </p> <ul> <li>Jumper - connect IN to speaker</li> <li>Trimpot - adjust sensitivity (gain)</li> </ul> <p>Pin header:</p> <ul> <li>IN: pin 1, 2 - source signal IN</li> </ul> <p>Power:</p> <ul> <li>Uses +5V from POWER IN.</li> <li>Uses +12v from audio amplifier module input.</li> </ul> <p>An Audio Volumetric Unit (VU) meter module is relying on a 10-bar LED display as an output. Each bar represents a 3dB change in the input signal level. The module shares the same 12 V voltage supply line as the audio amplifier module described above.</p> <p>Input signal level sensitivity can be adjusted by potentiometer (trimpot). We suggest that before using the module a calibration sequence be performed - apply the maximum allowed input signal to the module, and turn the potentiometer until all LED are lit, except top 3 which are red. During use lit red LEDs will then indicate overload of the input level.</p> Schematic Experiment Wire signal generator and visualize its intensity."},{"location":"side-panels/audio-panel/#function-generator","title":"Function generator","text":"<p>Function generator module able to output up to 1Mhz variable frequency signal with different waveform types. Can be used to play different sounds trough loudspeaker or to drive some other circuits. Select panel type matching yours:</p> Panel ver 3.5Panel ver 3.7 <p></p> <p>Control: </p> <ul> <li>DIP switch - select frequency range</li> <li>Amplitude - adjust sine amplitude</li> <li>Course - adjust frequency</li> <li>Fine - adjust frequency (precise)</li> <li>SINE: AC/DC - sine wave offset type</li> </ul> <p>Pin header:</p> <ul> <li>OUT: pin 1 - square signal wave output</li> <li>OUT: pin 2 - sine signal wave output</li> </ul> <p>Power:</p> <ul> <li>Uses VCC power from voltage selector.</li> <li>Uses +12v from audio amplifier module input.</li> </ul> <p>This module contains analog XR2206 chip capable to generate either sine or square wave signals up to 1MHz frequency. Module shares the same 12 V power supply line as the audio amplifier, described above. Frequency range can be changed by sliding switches S1 and further adjusted either in coarse or fine detail with two potentiometer. Sine wave amplitude can be adjusted with a separate potentiometer.</p> <p>Output sine wave can be selected to be output either with a DC offset, when output is from 0 to VCC with a bias of VCC/ 2, or shifted to AC when the jumper is not connected on the JP4.</p> <p>Note that only one switch should be active on the S1. We suggest by starting with the range selection, then using coarse adjustment potentiometer to roughly select the desired frequency, and then using fine adjustment potentiometer to fine-tune it.</p> Schematic Experiment Play generated signal trough loudspeaker. <p></p> <p>Control: </p> <ul> <li>Amplitude - adjust signal amplitude</li> </ul> <p>Pin header:</p> <ul> <li>OUT: pin 1 - signal OUTPUT</li> <li>OUT: pin 2 - GND</li> <li>SYNC - AD9833 control pin</li> <li>CLK - AD9833 control pin</li> <li>DATA - AD9833 control pin</li> </ul> <p>Power:</p> <ul> <li>Uses +3.3V from POWER IN.</li> </ul> <p>This module contains digital AD9833 chip capable to generate sine, triangle and square wave output signal up to 12.5 MHz frequency. Generated signal is buffered with an operation amplifier, giving the ability to control output signal amplitude. Note that circuit itself is only good for up to around 1Mhz. Higher frequency signals may be unstable or too weak.</p> <p>LabBoard AD9833 mode can be used to wire and control this chip directly. Arduino MD_AD9833 library can be used to control this chip from TotemDuino. Arduino example: Music player. Arduino example: MIDI interface. Arduino example: Minimal generator.  </p> <p>Output of the function generator can be wired to the input of audio amplifier, allowing you to hear the sound of if with no extra parts. Additionally, filter bench module can be placed between those modules to also experiment with pi-filters, and its effect to the signal.</p> Schematic Experiment"},{"location":"side-panels/audio-panel/#filter-bench","title":"Filter Bench","text":"<p>Only available in later panel ver 3.7.</p> <p>This is a simple framework for experimenting with pi-type filters. It allows you to easily connect different THT components, such as resistors, capacitors and inductors. Filter bench module is meant to be used as middle module between signal generator and audio amplifier modules, allowing user to quickly experience the effect that various components has on the signal.</p> Schematic <p>Legacy documentation of #3 Audio side panel:</p> <p>This page contains latest documentation of audio side panel. Links below are outdated and only specified for reference.</p> <p>Version 1.0 datasheet (legacy) Version 1.1 datasheet (legacy)  </p>"},{"location":"side-panels/io-panel/","title":"I/O panel #1","text":"Click image to jump to specific module <p>Contains: </p> <ul> <li>3 push-push switches with LED indicators</li> <li>3 Potentiometers</li> <li>1 Rotary encoder switch</li> <li>3 push button switches</li> <li>1 RGB-LED (can show virtually any color)</li> <li>1 Relay with LED indicator</li> <li>1 3.5mm jack connector</li> </ul> <p>Arduino examples:  Github |  TE-SP01-B </p> <p>This side panel is oriented to user input components. Various switches and buttons provides regulated control of connected circuits. This is useful to start some action (connect circuit), set specific configuration, regulate resistance or voltage. RGB LED can be conveniently used to display circuit state or to play around learning electronics.</p>"},{"location":"side-panels/io-panel/#power","title":"Power","text":"<p>On the top of the board there is (POWER IN) pin header to supply power to side panel components. Some of them requires certain voltage to operate, but otherwise they\u2019re fully isolated from one another, and can be used independently.</p> <p>Power up side panel: Side panel requires power (3.3V, 5V) for certain modules to work. It does not have its own voltage regulator so typically, regulated voltage has to be sourced from TotemDuino or LabBoard. Recommended to plug in all 3 wires as some modules use different voltages. </p> <p></p> <p>Select logic voltage level: Side panel contains logic level voltage (VCC) select for digital signals to work either at 3.3 or 5 Volt. Marked OBS! (Observe!). By moving JP7 jumper up or down - you can select between 3.3V and 5V. This is useful if you have some components that are 3.3 Volt only (could be damaged if used with 5V). In that case place jumper on 3.3V position and use side panel pins safely. It\u2019s important to have the same logic level as the controller board (e.g., TotemDuino), for best results. </p> <p></p> <p>Places where selected voltage (VCC) is used:  </p> <ul> <li>VCC for potentiometers</li> <li>pull-up resistors (R4, R5, R6) for encoder</li> <li>power for RGB-LED</li> </ul> <p>Switch and relay modules are always using +5v to power indication LED and relay itself.</p>"},{"location":"side-panels/io-panel/#switches","title":"Switches","text":"<p>Latched switches with LED indication - can be wired to use normally-on or normally-off position.</p> <p>Pin header: </p> <ul> <li>pin 1 - switch pressed in (LED on)</li> <li>pin 2 - common pin (connects to pin 1 or pin 3)</li> <li>pin 3 - switch pressed out (LED off)</li> </ul> <p>Info:</p> <ul> <li>Green LED indicates switch state.  </li> <li>All 3 (A, B, C) switches are separate and can be used individually.  </li> <li>Image on silkscreen displays pin contact when switch is pressed out (LED off).  </li> </ul> <p>Power:</p> <ul> <li>Uses +5v POWER IN to light up indication LEDs. This circuit is isolated and does not connect to switch pin headers.</li> </ul> Schematic Experiment Toggle switch A to see RGB color change."},{"location":"side-panels/io-panel/#potentiometers","title":"Potentiometers","text":"<p>Group of potentiometers to adjust amount of resistance or use as voltage divider.</p> <p>Pin header: </p> <ul> <li>pin 1 - potentiometer VCC </li> <li>pin 2 - potentiometer Output</li> <li>pin 3 - potentiometer GND</li> <li>JP1 - jumper to connect pin 1 to VCC</li> <li>JP2 - jumper to connect pin 3 to GND</li> </ul> <p>Info:</p> <ul> <li>Turning counterclockwise (left) - increases resistance pin 2 - pin 1 (VCC). In case voltage divider - decreases voltage on Output.</li> <li>Turning clockwise (right) - increases resistance pin 2 - pin 3 (GND \u23da). In case voltage divider - increases voltage on Output.</li> <li>When jumpers JP1 and JP2 are in place - potentiometer works as voltage divider.   Removing them leaves pin 1 and pin 3 unconnected to VCC and GND.</li> <li>All 3 (A, B, C) potentiometers are separate and can be used individually.  </li> <li>Potentiometer are rated for ~100k\u03a9 resistance.  </li> <li>Connect potentiometer output to TotemDuino pin A0 and use function <code>analogRead(A0)</code> to get its position (value between 0-1023).  </li> </ul> <p>Power:</p> <ul> <li>Uses VCC. 3.3V or 5V, depending on JP7 position.</li> </ul> Schematic Experiment Mix color by turning potentiometers."},{"location":"side-panels/io-panel/#rotary-encoder","title":"Rotary encoder","text":"<p>Rotary knob that gives out pulses when rotated. Also includes a pushable button.</p> <p>Pin header: </p> <ul> <li>pin 1 - knob press</li> <li>pin 2 - rotate signal A</li> <li>pin 3 - rotate signal B</li> </ul> <p>Info:</p> <ul> <li>Arduino example: Tracking encoder position.</li> <li>Captures control knob rotation and outputs two phase-locked signals on it\u2019s output at header H7, pin 2 and pin 3. As these signals are always delayed by 90 degrees from each other, its possible to extract direction information, together with rotation speed from the frequency of it.  </li> <li>Pressing knob connects pin 1 to GND (\u23da). Otherwise it's pulled high to VCC (using R4 resistor).  </li> <li>Signals A, B connects to GND (\u23da) when turning knob. Otherwise they are pulled high to VCC (using R5, R6 resistors). Also using C1 and C2 capacitors to prevent debouncing.  </li> </ul> <p>Power:</p> <ul> <li>Uses VCC for pull-up resistors (R4, R5, R6).</li> </ul> Schematic Experiment Turn knob to view encoder signal output."},{"location":"side-panels/io-panel/#buttons","title":"Buttons","text":"<p>Group of simple tactile push buttons.</p> <p>Pin header: </p> <ul> <li>pin 1 - button A</li> <li>pin 2 - button B</li> <li>pin 3 - button C</li> </ul> <p>Info: </p> <ul> <li>Arduino example: Detecting button click.</li> <li>Simple non-locked buttons that connect the signals from header H8 to GND (\u23da).  </li> <li>Does not have pull-up resistor or debouncing circuit.  </li> </ul> Schematic Experiment Light up RGB color when button is pressed."},{"location":"side-panels/io-panel/#rgb-led","title":"RGB LED","text":"<p>Three color RGB LED. Can be used to mix specific color.</p> <p>Pin header: </p> <ul> <li>pin 1 - blue color</li> <li>pin 2 - green color</li> <li>pin 3 - red color</li> </ul> <p>Info: </p> <ul> <li>Arduino example: Mixing colors.</li> <li>Three color LED in one package. Each LED can be controlled independently from header H9.  </li> <li>Lights up when pin is connected to GND (\u23da).  </li> </ul> <p>Power: </p> <ul> <li>Uses VCC to power LED over R7, R8, R9 resistors.  </li> </ul> Schematic Experiment Light up red color by wiring R to GND (\u23da)."},{"location":"side-panels/io-panel/#relay","title":"Relay","text":"<p>Mechanical high power switch. Can be used to control high current and voltage loads.</p> <p>Pin header: </p> <ul> <li>pin 1, 2 - relay contactor signal</li> </ul> <p>Info: </p> <ul> <li>Arduino example: Schmitt trigger.</li> <li>Works same as Switch, but withstands high voltage and loads up to 10A.  </li> <li>Single relay, driven by a transistor. Relay latches when HIGH signal is provided to H11 header. Activation state is shown with LED4. Output changes on B1 terminals.  </li> <li>N.O. - Normally Open (relay is latched, LED on).  </li> <li>N.C. - Normally Closed (relay is not latched, LED off).  </li> <li>It is not recommended to connect loads from power outlet, as these high voltages are dangerous.</li> </ul> <p>Power:</p> <ul> <li>Uses +5v POWER IN to supply power for relay and indication LED. </li> </ul> Schematic Experiment Connect red wire to H11 to toggle relay. RGB color changes between red and green."},{"location":"side-panels/io-panel/#35mm-adapter","title":"3.5mm adapter","text":"<p>Easy access to 3.5mm audio jack connector.</p> <p>Pin header: </p> <ul> <li>pin 1 - ground</li> <li>pin 2 - right audio channel</li> <li>pin 3 - left audio channel</li> </ul> <p>Info:</p> <ul> <li>Easy access to a difficult to mount on a breadboard part. All signals from the jack are connected to H10 header.  </li> <li>Pinout depends on connected device. Ground, Right, Left is just most common for headphones.</li> </ul> Schematic Visual <p>Legacy documentation of #1 I/O side panel:</p> <p>This page contains latest documentation of audio side panel. Link below is outdated and only specified for reference.</p> <p>Version 1.1 datasheet (legacy)  </p>"},{"location":"side-panels/sensor-panel/","title":"Sensor panel #2","text":"Click image to jump to specific module <p>Contains: </p> <ul> <li>Microphone</li> <li>128\u00d764 OLED display</li> <li>DHT11 humidity sensor</li> <li>NTC thermistor</li> <li>Piezo electric buzzer</li> <li>DC motor driver</li> </ul> <p>Arduino examples:  Github |  TE-SP02-B </p> <p>This side panel is a combination of sensors with display and motor driver as a bonus. Can be used to detect sound, room temperature, visualize data or alert with buzzer. Motor driver allows to control it manually or digitally using TotemDuino.</p>"},{"location":"side-panels/sensor-panel/#power","title":"Power","text":"<p>On the top of the board there is (POWER IN) pin header to supply power to side panel components. Some of them requires certain voltage to operate, but otherwise they\u2019re fully isolated from one another, and can be used independently.</p> <p>Power up side panel: Side panel requires power (3.3V, 5V) for certain modules to work. It does not have its own voltage regulator so typically, regulated voltage has to be sourced from TotemDuino or LabBoard. Recommended to plug in all 3 wires as some modules use different voltages. </p> <p></p> <p>Select logic voltage level: Side panel contains logic level voltage (VCC) select for digital signals to work either at 3.3 or 5 Volt. Marked OBS! (Observe!). By moving JP7 jumper up or down - you can select between 3.3V and 5V. This is useful if you have some components that are 3.3 Volt only (could be damaged if used with 5V). In that case place jumper on 3.3V position and use side panel pins safely. It\u2019s important to have the same logic level as the controller board (e.g., TotemDuino), for best results. </p> <p></p> <p>Places where selected voltage (VCC) is used:  </p> <ul> <li>Display power and logic</li> <li>Humidity sensor power and logic</li> <li>NTC reference voltage</li> <li>DC motor control buttons</li> </ul> <p>Microphone and buzzer modules are always using +5v to power their circuit.</p>"},{"location":"side-panels/sensor-panel/#microphone","title":"Microphone","text":"<p>Microphone module with integrated amplifier. Outputs analog audio signal in 0..5V range.</p> <p>Pin header: </p> <ul> <li>pin 1, 2 - microphone signal output</li> </ul> <p>Info:</p> <ul> <li>Arduino example: Sound alarm.</li> </ul> <p>Power: </p> <ul> <li>Uses +5v POWER IN for amplification circuit.</li> </ul> Schematic Experiment Read microphone using TotemDuino."},{"location":"side-panels/sensor-panel/#display","title":"Display","text":"<p>Monochrome I2C display to show text and simple graphics. Uses SSD1306 driver with 0x3C I2C address.</p> <p>Pin header: </p> <ul> <li>pin 1 - data signal SDA</li> <li>pin 2 - clock signal SCL</li> </ul> <p>Info:</p> <ul> <li>Arduino library: Adafruit SSD1306.</li> <li>Arduino example: Display test.</li> <li>Integrated pull-up resistors for I2C communication.</li> </ul> <p>Power:</p> <ul> <li>Uses VCC to power display. Works with both 3.3 or 5 V supply voltages.</li> </ul> Schematic Experiment Control display using TotemDuino."},{"location":"side-panels/sensor-panel/#humidity-sensor","title":"Humidity sensor","text":"<p>Digital temperature and humidity sensor DHT11. Uses 1-wire protocol to communicate with a microcontroller.</p> <p>Pin header: </p> <ul> <li>pin 1, 2 - 1-wire data signal</li> </ul> <p>Info:</p> <ul> <li>Arduino library: DHT sensor library.</li> <li>Arduino example: Temperature and humidity read.</li> <li>Measures temperature in Celsius and humidity in percentage.</li> </ul> <p>Power:</p> <ul> <li>Uses VCC to power sensor. Works with both 3.3 or 5 V supply voltages.</li> </ul> Schematic Experiment Read measurements using LabBoard."},{"location":"side-panels/sensor-panel/#ntc-thermistor","title":"NTC thermistor","text":"<p>Analog temperature sensor.</p> <p>Pin header: </p> <ul> <li>pin 1, 2 - thermistor signal output</li> </ul> <p>Info:</p> <ul> <li>Arduino example: NTC temperature read.</li> <li>Negative temperature coefficient (NTC) thermistor working in voltage divider configuration. OUT voltages goes down if temperature increases.</li> <li>At room temperature (25 \u00b0C) has 10k resistance.</li> </ul> <p>Power:</p> <ul> <li>Uses VCC for reference voltage.</li> </ul> Schematic Experiment"},{"location":"side-panels/sensor-panel/#buzzer","title":"Buzzer","text":"<p>Piezo speaker to produce beeping sounds.</p> <p>Pin header: </p> <ul> <li>pin 1, 2 - buzzer enable signal (HIGH - on, LOW - off)</li> </ul> <p>Info:</p> <ul> <li>Buzzer type: active.</li> <li>Can't be used with <code>tone()</code> function to generate different frequencies. For that case - passive buzzer is required or use Audio side panel.</li> </ul> <p>Power:</p> <ul> <li>Uses +5v POWER IN to drive buzzer.</li> </ul> Schematic Experiment Turn on buzzer by connecting VCC to H7."},{"location":"side-panels/sensor-panel/#dc-motor-driver","title":"DC motor driver","text":"<p>DC motor driver with BD6220F chip. Supports two speed control types: manual with potentiometer and buttons or modulated signal input.</p> <p>Control: </p> <ul> <li>button FW - manual spin motor forward.</li> <li>button RW - manual spin motor reverse.</li> <li>potentiometer - manual motor speed control.</li> <li>JP2: POT CONTROL - use potentiometer control.</li> <li>JP2: PWM CONTROL - use PWM pin control.</li> </ul> <p>Pin header:</p> <ul> <li>PWM IN FW - PWM motor speed control (forward direction)</li> <li>PWM IN RW - PWM motor speed control (reverse direction)</li> <li>POWER IN 1, 2 - supply power for motor (18V max)</li> <li>K1 power in - supply power for motor (screw terminal)</li> <li>K2 motor output - motor output pins (screw terminal)</li> </ul> <p>Info:</p> <ul> <li>Arduino example: Speed and direction control.</li> </ul> <p>Manual control mode:</p> <p>Place JP2 to POT CONTROL. In this mode motor speed and direction can be controlled using buttons and potentiometer. Wire motor to screw terminals. Supply power for motor trough POWER IN (or screw terminal). Click FW button to spin motor forward direction. Click RW button to spin motor reverse direction. Turn potentiometer to control motor speed.  </p> <p>Signal control mode:</p> <p>Place JP2 to PWM CONTROL. In this mode motor speed and direction is controlled using PWM IN input pins. Potentiometer won't work. Wire motor to screw terminals. Supply power for motor trough POWER IN (or screw terminal). Supply PWM signal to PWM IN FW pin to spin motor forward. Control speed with duty cycle. Supply PWM signal to PWM IN RW pin to spin motor reverse. Control speed with duty cycle. May use LabBoard Pulse generator mode to supply control signal. Wire TXD (typically set 100Hz and adjust duty cycle to change speed).</p> <p>Motor state depending on input signal:  </p> Input FW Input RW Motor state LOW LOW Idle HIGH (PWM) LOW Rotation FW LOW HIGH (PWM) Rotation RW HIGH HIGH Brake <p>Power:</p> <ul> <li>All required power has to be supplied trough POWER IN 1, 2 pins or K1 power in. It does not use main power input (top of side panel).</li> <li>POWER IN pin is used to power motor from LabBoard (e.g. connecting to VIN pin). K1 power in screw terminal is used to power motor from external battery or power supply by connecting - and +.  </li> </ul> Schematic Experiment Press FW of RW button to spin motor. Turn potentiometer to control speed. <p>Legacy documentation of #2 Sensor side panel:</p> <p>This page contains latest documentation of audio side panel. Link below is outdated and only specified for reference.</p> <p>Version 1.1 datasheet (legacy)  </p>"},{"location":"totemduino/","title":"Overview","text":"<ul> <li>TotemDuino v2.0 </li> <li>TotemDuino v1.x </li> </ul> <p>Revision v2.0</p> <p>New version is released with following improvements:</p> <ul> <li>Changed USB-Serial chip to CH340 (works with Windows 11)</li> <li>Added USB-C, Qwiic (I2C) connector, ICSP header</li> <li>Design update, power and serial LED</li> </ul> <p> TE-PR-2 TotemDuino expands upon the great Arduino UNO platform idea. While it is kept fully backwards compatible with Arduino, a lot of additional features are included as well, such as:</p> <ul> <li>Output protection - comes with all of its output pins going into LabBoard protected against over-voltage or short-circuit conditions.</li> <li>Expansion port - a 34 pin flat-cable connection connects to the LabBoard for easy pin access.</li> <li>Powerful 5 V regulator - you'll be less likely to run out of power while experimenting with higher power loads such as motors.</li> <li>Selectable microcontroller logic voltage - as the world progresses from 5 V towards 3.3 V logic voltage, TotemDuino can work with both just by the flip of a switch, without the need for any additional adapters or converters.</li> </ul>"},{"location":"totemduino/#features","title":"Features","text":"<ul> <li>ATmega328P microcontroller</li> <li>100% Arduino Uno compatible, works with Arduino shields</li> <li>Works in Arduino IDE</li> <li>9-30 V DC or 5V USB supply power range</li> <li>Selectable 5V or 3.3V logic voltage</li> <li>Noise immune design</li> <li>Additional filtering for precise analog voltage measurements</li> <li>Integrated programmer - no extra parts needed to start coding.</li> <li>Arduino and Totem compatible mounting holes</li> <li>34-pin flat cable connector for integration with Totem Mini Lab</li> </ul>"},{"location":"totemduino/#layout","title":"Layout","text":"<ul> <li>Arduino pin headers - programmable pin headers of ATmega328P processor. <code>D</code> - digital, <code>A</code> - analog, others - power supply. Layout is compatible with Arduino Uno form factor and shields.</li> <li>LED - LED on the right indicates if TotemDuino is powered on. LED D13 displays state of D13 pin. Can be used with classical blinking example:  <pre><code>void setup() {\n  pinMode(13, OUTPUT);\n}\nvoid loop() {\n  digitalWrite(13, HIGH);  // turn the LED on (HIGH is the voltage level)\n  delay(1000);             // wait for a second\n  digitalWrite(13, LOW);   // turn the LED off by making the voltage LOW\n  delay(1000);             // wait for a second\n}\n</code></pre></li> <li>Voltage switch - Switch to select between 3.3V (down) or 5V (up) logic level. Processor will function on the selected voltage. Standard Arduino (ATmega328P) boards always works on 5V logic level. This is convenient if you need to connect sensors that are 3.3V only (could be damaged if using with 5V).</li> <li>Reset button - reset processor. Will restart running sketch. Same as connecting RST to GND.</li> <li>Protection circuit - pin protection circuit for over-voltage or short-circuit conditions.</li> <li>USB input - allows to connect TotemDuino to PC. Used for power (if DC not connected), programming (sketch upload), print messages (Serial Monitor).</li> <li>DC input - provides power for TotemDuino (and Mini Lab). Center positive. Can accept voltages between 9-30VDC. Directly routed to VIN pin. Used to create regulated 3.3V and 5V.</li> <li>Flat cable - port to connect TotemDuino with LabBoard. It routes power and all Arduino pin headers to LabBoard.</li> <li>Serial header - header of USB-Serial converter output. Not used.</li> <li>ICSP header - standard pins for In Circuit Serial Programming. Not used and header is not soldered.</li> <li>Qwiic connector - Connect external I2C modules. Pull white switches to ON position in order to connect A4, A5 pins to connector (board v2.0 only).</li> </ul>"},{"location":"totemduino/driver-install/","title":"Driver install","text":"<p>TotemDuino v1.x contains PL2303 USB to Serial chip that is no more supported in Windows 11. This results in problems when trying to flash code sketch using Arduino. This tutorial will instruct on resolving this issue. Other operating systems should work out of the box.</p> <p></p> <p>Driver status can be view in Windows \u2192 Device Manager application.</p> <p>Note</p> <p>This guide is only for Windows 11 and older TotemDuino v1.x (PL2303) boards. Windows 10 or TotemDuino v2.0 (CH340) doesn't need this driver.</p>"},{"location":"totemduino/driver-install/#install-driver","title":"Install driver","text":"<p>Windows 11 uses latest Prolific driver that does not work with this chip. Installing older version resolves the issue.</p> <ol> <li>Make sure TotemDuino is disconnected from the computer.</li> <li>Download driver.  Download Prolific Driver</li> <li>Extract <code>PL2303_Prolific_DriverInstaller_v1_12_0.zip</code> archive file.</li> <li>Run <code>PL2303_Prolific_DriverInstaller_v1.12.0.exe</code> installer file.</li> <li>If <code>User Account Control</code> window appeared - click Yes.</li> <li>Driver install window opens. </li> <li>Click Next &gt;</li> <li>Click Finish</li> <li>Now TotemDuino should be fully working. </li> </ol> <p>If message \"DO NOT SUPPORT ...\" is still displayed in Device Manager - run same installer again:</p> <ol> <li>Select <code>Repair</code> and click Next &gt;</li> <li>Select <code>No</code> to restart and click Finish</li> </ol>"},{"location":"totemduino/driver-install/#lock-driver","title":"Lock driver","text":"<p>Windows will try to update driver on each computer restart. This step will prevent to overwrite installed version.</p> <ol> <li>Download <code>Show or hide updates troubleshooter</code>. Microsoft Edge may show this file as \"harmfull\". Select <code>Keep</code> option.  Download application</li> <li>Run <code>wushowhide.diagcab</code> file.</li> <li>Click Next. Wait for detection process to finish.</li> <li>Click \u2192 Hide updates. </li> <li>Select <code>Prolific - ports - 3.9.1.0</code> </li> <li>Click Next, wait for \"Resolving problems\" screen to finish. </li> <li>Click Close</li> </ol> <p>Now TotemDuino should be fully working, even after computer restart or Windows Update.</p>"},{"location":"totemduino/driver-install/#restore-driver","title":"Restore driver","text":"<p>Follow these instructions if you want to restore driver to original state. This will undo changes done in previous tutorial.</p> <ol> <li>Download <code>Show or hide updates troubleshooter</code>.  Download application</li> <li>Run <code>wushowhide.diagcab</code> file.</li> <li>Click Next. Wait for detection process to finish.</li> <li>Click \u2192 Show hidden updates. </li> <li>Select <code>Prolific - ports - 3.9.1.0</code> </li> <li>Click Next, wait for \"Resolving problems\" screen to finish. </li> <li>Click Close</li> </ol> <p>Restart computer and Prolific driver should roll back to the latest version.</p>"},{"location":"totemduino/micro-lab/","title":"Micro Lab","text":"<p> TKM-MCL1 Totem Micro Lab is a standalone kit based on TotemDuino. Like its bigger brother, Micro Lab has sturdy rack to comfortably hold everything together. With included breadboard, you can easy connect various components to TotemDuino. It can also be expanded with Side Panels.</p>"},{"location":"totemduino/micro-lab/#use-with-side-panels","title":"Use with side panels","text":"<p>Totem Micro Lab can be used with Side Panels - they give you access to various pre-built sensors, drivers, buttons and relays. Side Panels attach directly to the Micro Lab structure and simple breadboard wires are used for connections.</p> <p></p>"},{"location":"totemduino/micro-lab/#assembly-guide","title":"Assembly guide","text":"<p>Micro-lab-building-instructions.pdf</p>"},{"location":"totemduino/schematics/","title":"Schematics","text":""},{"location":"totemduino/schematics/#electrical-wiring","title":"Electrical wiring","text":"<p>TotemDuino-Schematics.pdf</p>"},{"location":"totemduino/schematics/#mechanical-drawing","title":"Mechanical drawing","text":"<p>TotemDuino-Mechanical-Drawing.pdf</p>"},{"location":"totemduino/setup/","title":"Arduino IDE setup","text":"<p>Arduino IDE stands out with its simple design, allowing to write a code, compile a project and upload it to the TotemDuino. This is one of the reasons why it's so popular among beginners. Aside from basic functionality, it has thousands of third-party libraries and code examples to create a project even faster.  </p> <p>Windows 11 driver</p> <p>TotemDuino were manufactured with PL2303TA chip that is no more supported in Windows 11 OS. Follow Driver install tutorial to solve this issue.</p>"},{"location":"totemduino/setup/#step-1-download-arduino-ide","title":"Step 1. Download Arduino IDE","text":"<p>Go to Arduino website to download application for your operating system. Install guide (1.8): Windows | macOS | Linux Install guide (2.2): Windows / MacOS / Linux</p> <p> Download Arduino</p>"},{"location":"totemduino/setup/#step-2-select-board","title":"Step 2. Select Board","text":"<p>TotemDuino is represented as \"Arduino UNO\".</p> <ol> <li>Select <code>Tools</code> \u2192 <code>Board</code> \u2192 <code>Arduino AVR Boards</code> \u2192 <code>Arduino UNO</code>.  </li> </ol>"},{"location":"totemduino/setup/#step-3-compile-and-upload-code","title":"Step 3. Compile and upload code","text":"<p>Load example code and upload it to TotemDuino.  </p> <ol> <li>Select <code>File</code> \u2192 <code>Examples</code> \u2192 <code>01.Basics</code> \u2192 <code>Blink</code>.  </li> <li>Connect TotemDuino to PC over USB cable.  </li> <li>Select <code>Tools</code> \u2192 <code>Port</code> and click on the port displayed there. If there are multiple ports, disconnect USB cable and check which one is gone. Reconnect and select it. </li> <li>Select <code>Sketch</code> \u2192 <code>Upload</code> and wait till it completes.  </li> <li>LED will start to blink in 1 second interval.  </li> </ol> <p></p>"},{"location":"totemduino/setup/#step-4-using-arduino-ide","title":"Step 4. Using Arduino IDE","text":"<p>For more information about getting started with Arduino, read following topics:  </p> <p>User interface:</p> <ul> <li>Arduino IDE 2.3 | Arduino IDE 1.8 - walk around Arduino IDE UI</li> <li>Install libraries IDE 2.2 | Install libraries IDE 1.8 - install third-party libraries</li> <li>Upload sketch IDE 2.2 - upload compiled code to TotemDuino</li> <li>Autocomplete feature IDE 2.2 - displays code suggestions while typing</li> </ul> <p>Monitor:</p> <ul> <li>Serial Monitor IDE 2.2 - view <code>Serial.print()</code> output</li> <li>Serial Plotter IDE 2.2 - view plotted graphs</li> </ul> <p>Code documentation:</p> <ul> <li>Arduino code documentation - Arduino functions documentation</li> </ul> <p>Code examples:</p> <ul> <li>Arduino examples / projects - general Arduino example projects</li> <li>Mini Lab projects - Mini Lab specific example projects</li> </ul> <p>Question</p> <p>Visit  Support page to find more information or help from our community.</p>"}]}